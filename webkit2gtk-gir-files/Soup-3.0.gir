<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="Gio" version="2.0"/>
  <package name="libsoup-3.0"/>
  <c:include name="libsoup/soup.h"/>
  <namespace name="Soup" version="3.0" shared-library="libsoup-3.0.so.0" c:identifier-prefixes="Soup" c:symbol-prefixes="soup">
    <class name="Auth" c:symbol-prefix="auth" c:type="SoupAuth" parent="GObject.Object" abstract="1" glib:type-name="SoupAuth" glib:get-type="soup_auth_get_type" glib:type-struct="AuthClass">
      <doc xml:space="preserve">The abstract base class for handling authentication.

Specific HTTP Authentication mechanisms are implemented by its subclasses,
but applications never need to be aware of the specific subclasses being
used.

#SoupAuth objects store the authentication data associated with a given bit
of web space. They are created automatically by [class@Session].</doc>
      <constructor name="new" c:identifier="soup_auth_new">
        <doc xml:space="preserve">Creates a new #SoupAuth of type @type with the information from
@msg and @auth_header.

This is called by [class@Session]; you will normally not create auths
yourself.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupAuth, or %NULL if it could
  not be created</doc>
          <type name="Auth" c:type="SoupAuth*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of auth to create (a subtype of #SoupAuth)</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage the auth is being created for</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth_header" transfer-ownership="none">
            <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="authenticate" invoker="authenticate">
        <doc xml:space="preserve">Call this on an auth to authenticate it.

Normally this will cause the auth's message to be requeued with the new
authentication info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">the username provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="can_authenticate" invoker="can_authenticate">
        <doc xml:space="preserve">Tests if @auth is able to authenticate by providing credentials to the
[method@Auth.authenticate].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is able to accept credentials.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_authorization" invoker="get_authorization">
        <doc xml:space="preserve">Generates an appropriate "Authorization" header for @msg.

(The session will only call this if [method@Auth.is_authenticated] returned
%TRUE.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the "Authorization" header, which must be freed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage to be authorized</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_protection_space" invoker="get_protection_space">
        <doc xml:space="preserve">Returns a list of paths on the server which @auth extends over.

(All subdirectories of these paths are also assumed to be part
of @auth's protection space, unless otherwise discovered not to
be.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the list of
  paths, which can be freed with [method@Auth.free_protection_space].</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="source_uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI of the request that @auth was generated in
  response to.</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_authenticated" invoker="is_authenticated">
        <attribute name="org.gtk.Method.get_property" value="is-authenticated"/>
        <doc xml:space="preserve">Tests if @auth has been given a username and password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth has been given a username and password</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_ready" invoker="is_ready">
        <doc xml:space="preserve">Tests if @auth is ready to make a request for @msg with.

For most auths, this is equivalent to [method@Auth.is_authenticated], but for
some auth types (eg, NTLM), the auth may be sendable (eg, as an
authentication request) even before it is authenticated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is ready to make a request with.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update" invoker="update">
        <doc xml:space="preserve">Updates @auth with the information from @msg and @auth_header,
possibly un-authenticating it.

As with [ctor@Auth.new], this is normally only used by [class@Session].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is still a valid (but potentially
  unauthenticated) #SoupAuth. %FALSE if something about @auth_params
  could not be parsed or incorporated into @auth at all.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage @auth is being updated for</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth_header" transfer-ownership="none">
            <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="authenticate" c:identifier="soup_auth_authenticate">
        <doc xml:space="preserve">Call this on an auth to authenticate it.

Normally this will cause the auth's message to be requeued with the new
authentication info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">the username provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password provided by the user or client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_authenticate" c:identifier="soup_auth_can_authenticate">
        <doc xml:space="preserve">Tests if @auth is able to authenticate by providing credentials to the
[method@Auth.authenticate].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is able to accept credentials.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cancel" c:identifier="soup_auth_cancel">
        <doc xml:space="preserve">Call this on an auth to cancel it.

You need to cancel an auth to complete an asynchronous authenticate operation
when no credentials are provided ([method@Auth.authenticate] is not called).
The #SoupAuth will be cancelled on dispose if it hans't been authenticated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_protection_space" c:identifier="soup_auth_free_protection_space" introspectable="0">
        <doc xml:space="preserve">Frees @space.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="space" transfer-ownership="none">
            <doc xml:space="preserve">the return value from [method@Auth.get_protection_space]</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_authority" c:identifier="soup_auth_get_authority" glib:get-property="authority">
        <attribute name="org.gtk.Method.get_property" value="authority"/>
        <doc xml:space="preserve">Returns the authority (host:port) that @auth is associated with.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the authority</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_authorization" c:identifier="soup_auth_get_authorization">
        <doc xml:space="preserve">Generates an appropriate "Authorization" header for @msg.

(The session will only call this if [method@Auth.is_authenticated] returned
%TRUE.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the "Authorization" header, which must be freed.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage to be authorized</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="soup_auth_get_info">
        <doc xml:space="preserve">Gets an opaque identifier for @auth.

The identifier can be used as a hash key or the like. #SoupAuth objects from
the same server with the same identifier refer to the same authentication
domain (eg, the URLs associated with them take the same usernames and
passwords).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the identifier</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protection_space" c:identifier="soup_auth_get_protection_space">
        <doc xml:space="preserve">Returns a list of paths on the server which @auth extends over.

(All subdirectories of these paths are also assumed to be part
of @auth's protection space, unless otherwise discovered not to
be.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the list of
  paths, which can be freed with [method@Auth.free_protection_space].</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="source_uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI of the request that @auth was generated in
  response to.</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_realm" c:identifier="soup_auth_get_realm" glib:get-property="realm">
        <attribute name="org.gtk.Method.get_property" value="realm"/>
        <doc xml:space="preserve">Returns @auth's realm.

This is an identifier that distinguishes separate authentication spaces on a
given server, and may be some string that is meaningful to the user.
(Although it is probably not localized.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the realm name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scheme_name" c:identifier="soup_auth_get_scheme_name" glib:get-property="scheme-name">
        <doc xml:space="preserve">soup_auth_get_scheme_name: (attributes org.gtk.Method.get_property=scheme-name)
Returns @auth's scheme name. (Eg, "Basic", "Digest", or "NTLM")</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scheme name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_authenticated" c:identifier="soup_auth_is_authenticated" glib:get-property="is-authenticated">
        <attribute name="org.gtk.Method.get_property" value="is-authenticated"/>
        <doc xml:space="preserve">Tests if @auth has been given a username and password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth has been given a username and password</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_cancelled" c:identifier="soup_auth_is_cancelled" glib:get-property="is-cancelled">
        <attribute name="org.gtk.Method.get_property" value="is-cancelled"/>
        <doc xml:space="preserve">Tests if @auth has been cancelled</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth has been cancelled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_for_proxy" c:identifier="soup_auth_is_for_proxy">
        <attribute name="org.gtk.Method.get_property" value="is-for-proxy"/>
        <doc xml:space="preserve">Tests whether or not @auth is associated with a proxy server rather
than an "origin" server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_ready" c:identifier="soup_auth_is_ready">
        <doc xml:space="preserve">Tests if @auth is ready to make a request for @msg with.

For most auths, this is equivalent to [method@Auth.is_authenticated], but for
some auth types (eg, NTLM), the auth may be sendable (eg, as an
authentication request) even before it is authenticated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is ready to make a request with.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="soup_auth_update">
        <doc xml:space="preserve">Updates @auth with the information from @msg and @auth_header,
possibly un-authenticating it.

As with [ctor@Auth.new], this is normally only used by [class@Session].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @auth is still a valid (but potentially
  unauthenticated) #SoupAuth. %FALSE if something about @auth_params
  could not be parsed or incorporated into @auth at all.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuth</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage @auth is being updated for</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="auth_header" transfer-ownership="none">
            <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="authority" writable="1" transfer-ownership="none" getter="get_authority">
        <attribute name="org.gtk.Property.get" value="soup_auth_get_authority"/>
        <doc xml:space="preserve">The authority (host:port) being authenticated to.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="is-authenticated" transfer-ownership="none" getter="is_authenticated">
        <attribute name="org.gtk.Property.get" value="soup_auth_is_authenticated"/>
        <doc xml:space="preserve">Whether or not the auth has been authenticated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-cancelled" transfer-ownership="none" getter="is_cancelled">
        <attribute name="org.gtk.Property.get" value="soup_auth_is_cancelled"/>
        <doc xml:space="preserve">Whether or not the auth has been cancelled.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-for-proxy" writable="1" transfer-ownership="none">
        <attribute name="org.gtk.Property.get" value="soup_auth_is_for_proxy"/>
        <doc xml:space="preserve">Whether or not the auth is for a proxy server.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="realm" writable="1" transfer-ownership="none" getter="get_realm">
        <attribute name="org.gtk.Property.get" value="soup_auth_get_realm"/>
        <doc xml:space="preserve">The authentication realm.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="scheme-name" transfer-ownership="none" getter="get_scheme_name">
        <attribute name="org.gtk.Property.get" value="soup_auth_get_scheme_name"/>
        <doc xml:space="preserve">The authentication scheme name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="AuthBasic" c:symbol-prefix="auth_basic" parent="Auth" final="1" glib:type-name="SoupAuthBasic" glib:get-type="soup_auth_basic_get_type">
      <doc xml:space="preserve">HTTP "Basic" authentication.

[class@Session]s support this by default; if you want to disable
support for it, call [method@Session.remove_feature_by_type],
passing %SOUP_TYPE_AUTH_BASIC.</doc>
    </class>
    <record name="AuthClass" c:type="SoupAuthClass" glib:is-gtype-struct-for="Auth">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="scheme_name">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="strength">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="update">
        <callback name="update">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @auth is still a valid (but potentially
  unauthenticated) #SoupAuth. %FALSE if something about @auth_params
  could not be parsed or incorporated into @auth at all.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupMessage @auth is being updated for</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
            <parameter name="auth_header" transfer-ownership="none">
              <doc xml:space="preserve">the WWW-Authenticate/Proxy-Authenticate header</doc>
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_protection_space">
        <callback name="get_protection_space">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the list of
  paths, which can be freed with [method@Auth.free_protection_space].</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="utf8"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="source_uri" transfer-ownership="none">
              <doc xml:space="preserve">the URI of the request that @auth was generated in
  response to.</doc>
              <type name="GLib.Uri" c:type="GUri*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="authenticate">
        <callback name="authenticate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="username" transfer-ownership="none">
              <doc xml:space="preserve">the username provided by the user or client</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">the password provided by the user or client</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_authenticated">
        <callback name="is_authenticated">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @auth has been given a username and password</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_authorization">
        <callback name="get_authorization">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the "Authorization" header, which must be freed.</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">the #SoupMessage to be authorized</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_ready">
        <callback name="is_ready">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @auth is ready to make a request with.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupMessage</doc>
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="can_authenticate">
        <callback name="can_authenticate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @auth is able to accept credentials.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="auth" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuth</doc>
              <type name="Auth" c:type="SoupAuth*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AuthDigest" c:symbol-prefix="auth_digest" parent="Auth" final="1" glib:type-name="SoupAuthDigest" glib:get-type="soup_auth_digest_get_type">
      <doc xml:space="preserve">HTTP "Digest" authentication.

[class@Session]s support this by default; if you want to disable
support for it, call [method@Session.remove_feature_by_type]
passing %SOUP_TYPE_AUTH_DIGEST.</doc>
    </class>
    <class name="AuthDomain" c:symbol-prefix="auth_domain" c:type="SoupAuthDomain" parent="GObject.Object" abstract="1" glib:type-name="SoupAuthDomain" glib:get-type="soup_auth_domain_get_type" glib:type-struct="AuthDomainClass">
      <doc xml:space="preserve">Server-side authentication.

A #SoupAuthDomain manages authentication for all or part of a
[class@Server]. To make a server require authentication, first create
an appropriate subclass of #SoupAuthDomain, and then add it to the
server with [method@Server.add_auth_domain].

In order for an auth domain to have any effect, you must add one or more
paths to it (via [method@AuthDomain.add_path]). To require authentication for
all ordinary requests, add the path `"/"`. (Note that this does not include
the special `"*"` URI (eg, "OPTIONS *"), which must be added as a separate
path if you want to cover it.)

If you need greater control over which requests should and shouldn't be
authenticated, add paths covering everything you *might* want authenticated,
and then use a filter ([method@AuthDomain.set_filter] to bypass
authentication for those requests that don't need it.</doc>
      <virtual-method name="accepts">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
          <parameter name="header" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="challenge" invoker="challenge">
        <doc xml:space="preserve">Adds a "WWW-Authenticate" or "Proxy-Authenticate" header to @msg.

It requests that the client authenticate, and sets @msg's status accordingly.

This is used by [class@Server] internally and is probably of no use to
anyone else.</doc>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="check_password" invoker="check_password">
        <doc xml:space="preserve">Checks if @msg authenticates to @domain via @username and
@password.

This would normally be called from a
[callback@AuthDomainGenericAuthCallback].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the message is authenticated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">a username</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a password</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="accepts" c:identifier="soup_auth_domain_accepts">
        <doc xml:space="preserve">Checks if @msg contains appropriate authorization for @domain to
accept it.

Mirroring [method@AuthDomain.covers], this does not check whether or not
@domain *cares* if @msg is authorized.

This is used by [class@Server] internally and is probably of no use to
anyone else.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the username that @msg has authenticated
  as, if in fact it has authenticated. %NULL otherwise.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_path" c:identifier="soup_auth_domain_add_path">
        <doc xml:space="preserve">Adds @path to @domain.

Requests under @path on @domain's server will require authentication (unless
overridden by [method@AuthDomain.remove_path] or
[method@AuthDomain.set_filter]).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to add to @domain</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="challenge" c:identifier="soup_auth_domain_challenge">
        <doc xml:space="preserve">Adds a "WWW-Authenticate" or "Proxy-Authenticate" header to @msg.

It requests that the client authenticate, and sets @msg's status accordingly.

This is used by [class@Server] internally and is probably of no use to
anyone else.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_password" c:identifier="soup_auth_domain_check_password">
        <doc xml:space="preserve">Checks if @msg authenticates to @domain via @username and
@password.

This would normally be called from a
[callback@AuthDomainGenericAuthCallback].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the message is authenticated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">a username</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">a password</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="covers" c:identifier="soup_auth_domain_covers">
        <doc xml:space="preserve">Checks if @domain requires @msg to be authenticated (according to
its paths and filter function).

This does not actually look at whether @msg *is* authenticated, merely
whether or not it needs to be.

This is used by [class@Server] internally and is probably of no use to
anyone else.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @domain requires @msg to be authenticated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_realm" c:identifier="soup_auth_domain_get_realm" glib:get-property="realm">
        <attribute name="org.gtk.Method.get_property" value="realm"/>
        <doc xml:space="preserve">Gets the realm name associated with @domain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@domain's realm</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_path" c:identifier="soup_auth_domain_remove_path">
        <doc xml:space="preserve">Removes @path from @domain.

Requests under @path on @domain's server will NOT require
authentication.

This is not simply an undo-er for [method@AuthDomain.add_path]; it
can be used to "carve out" a subtree that does not require
authentication inside a hierarchy that does. Note also that unlike
with [method@AuthDomain.add_path], this cannot be overridden by
adding a filter, as filters can only bypass authentication that
would otherwise be required, not require it where it would
otherwise be unnecessary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to remove from @domain</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filter" c:identifier="soup_auth_domain_set_filter" glib:set-property="filter">
        <attribute name="org.gtk.Method.set_property" value="filter"/>
        <doc xml:space="preserve">Adds @filter as an authentication filter to @domain.

The filter gets a chance to bypass authentication for certain requests that
would otherwise require it. Eg, it might check the message's path in some way
that is too complicated to do via the other methods, or it might check the
message's method, and allow GETs but not PUTs.

The filter function returns %TRUE if the request should still
require authentication, or %FALSE if authentication is unnecessary
for this request.

To help prevent security holes, your filter should return %TRUE by
default, and only return %FALSE under specifically-tested
circumstances, rather than the other way around. Eg, in the example
above, where you want to authenticate PUTs but not GETs, you should
check if the method is GET and return %FALSE in that case, and then
return %TRUE for all other methods (rather than returning %TRUE for
PUT and %FALSE for all other methods). This way if it turned out
(now or later) that some paths supported additional methods besides
GET and PUT, those methods would default to being NOT allowed for
unauthenticated users.

You can also set the filter by setting the SoupAuthDomain:filter
and [property@AuthDomain:filter-data properties], which can also be
used to set the filter at construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the auth filter for @domain</doc>
            <type name="AuthDomainFilter" c:type="SoupAuthDomainFilter"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @filter</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @filter_data when @domain
  is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_generic_auth_callback" c:identifier="soup_auth_domain_set_generic_auth_callback" glib:set-property="generic-auth-callback">
        <attribute name="org.gtk.Method.get_property" value="generic-auth-callback"/>
        <doc xml:space="preserve">Sets @auth_callback as an authentication-handling callback for @domain.

Whenever a request comes in to @domain which cannot be authenticated via a
domain-specific auth callback (eg, [callback@AuthDomainDigestAuthCallback]),
the generic auth callback will be invoked. See
[callback@AuthDomainGenericAuthCallback] for information on what the callback
should do.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="auth_callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the auth callback</doc>
            <type name="AuthDomainGenericAuthCallback" c:type="SoupAuthDomainGenericAuthCallback"/>
          </parameter>
          <parameter name="auth_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @auth_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @auth_data when @domain
  is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <property name="filter" writable="1" transfer-ownership="none" setter="set_filter">
        <attribute name="org.gtk.Property.set" value="soup_auth_domain_set_filter"/>
        <doc xml:space="preserve">The [callback@AuthDomainFilter] for the domain.</doc>
        <type name="AuthDomainFilter" c:type="gpointer"/>
      </property>
      <property name="filter-data" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Data to pass to the [callback@AuthDomainFilter].</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="generic-auth-callback" writable="1" transfer-ownership="none" setter="set_generic_auth_callback">
        <attribute name="org.gtk.Property.set" value="soup_auth_domain_set_generic_auth_callback"/>
        <doc xml:space="preserve">The [callback@AuthDomainGenericAuthCallback].</doc>
        <type name="AuthDomainGenericAuthCallback" c:type="gpointer"/>
      </property>
      <property name="generic-auth-data" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The data to pass to the [callback@AuthDomainGenericAuthCallback].</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="proxy" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not this is a proxy auth domain.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="realm" writable="1" construct-only="1" transfer-ownership="none" getter="get_realm">
        <attribute name="org.gtk.Property.get" value="soup_auth_domain_get_realm"/>
        <doc xml:space="preserve">The realm of this auth domain.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="AuthDomainBasic" c:symbol-prefix="auth_domain_basic" c:type="SoupAuthDomainBasic" parent="AuthDomain" final="1" glib:type-name="SoupAuthDomainBasic" glib:get-type="soup_auth_domain_basic_get_type" glib:type-struct="AuthDomainBasicClass">
      <doc xml:space="preserve">Server-side "Basic" authentication.

#SoupAuthDomainBasic handles the server side of HTTP "Basic" (ie,
cleartext password) authentication.</doc>
      <constructor name="new" c:identifier="soup_auth_domain_basic_new" introspectable="0">
        <doc xml:space="preserve">Creates a #SoupAuthDomainBasic.

You must set the [property@AuthDomain:realm] property, to indicate the realm
name to be returned with the authentication challenge to the client. Other
parameters are optional.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first option, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">option name/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <method name="set_auth_callback" c:identifier="soup_auth_domain_basic_set_auth_callback" glib:set-property="auth-callback">
        <attribute name="org.gtk.Method.set_property" value="auth-callback"/>
        <doc xml:space="preserve">Sets the callback that @domain will use to authenticate incoming
requests.

For each request containing authorization, @domain will invoke the callback,
and then either accept or reject the request based on @callback's return
value.

You can also set the auth callback by setting the
[property@AuthDomainBasic:auth-callback] and
[property@AuthDomainBasic:auth-data] properties, which can also be used to
set the callback at construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the domain</doc>
            <type name="AuthDomainBasic" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the callback</doc>
            <type name="AuthDomainBasicAuthCallback" c:type="SoupAuthDomainBasicAuthCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @auth_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data when @domain
  is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <property name="auth-callback" writable="1" transfer-ownership="none" setter="set_auth_callback">
        <attribute name="org.gtk.Property.set" value="soup_auth_domain_basic_set_auth_callback"/>
        <doc xml:space="preserve">The [callback@AuthDomainBasicAuthCallback].</doc>
        <type name="AuthDomainBasicAuthCallback" c:type="gpointer"/>
      </property>
      <property name="auth-data" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The data to pass to the [callback@AuthDomainBasicAuthCallback].</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
    </class>
    <callback name="AuthDomainBasicAuthCallback" c:type="SoupAuthDomainBasicAuthCallback">
      <doc xml:space="preserve">Callback used by #SoupAuthDomainBasic for authentication purposes.

The application should verify that @username and @password and valid
and return %TRUE or %FALSE.

If you are maintaining your own password database (rather than
using the password to authenticate against some other system like
PAM or a remote server), you should make sure you know what you are
doing. In particular, don't store cleartext passwords, or
easily-computed hashes of cleartext passwords, even if you don't
care that much about the security of your server, because users
will frequently use the same password for multiple sites, and so
compromising any site with a cleartext (or easily-cracked) password
database may give attackers access to other more-interesting sites
as well.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @username and @password are valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the domain</doc>
          <type name="AuthDomainBasic" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being authenticated</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="username" transfer-ownership="none">
          <doc xml:space="preserve">the username provided by the client</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve">the password provided by the client</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
          <doc xml:space="preserve">the data passed to [method@AuthDomainBasic.set_auth_callback]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AuthDomainBasicClass" c:type="SoupAuthDomainBasicClass" glib:is-gtype-struct-for="AuthDomainBasic">
      <field name="parent_class">
        <type name="AuthDomainClass" c:type="SoupAuthDomainClass"/>
      </field>
    </record>
    <record name="AuthDomainClass" c:type="SoupAuthDomainClass" glib:is-gtype-struct-for="AuthDomain">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="accepts">
        <callback name="accepts">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="domain" transfer-ownership="none">
              <type name="AuthDomain" c:type="SoupAuthDomain*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="ServerMessage" c:type="SoupServerMessage*"/>
            </parameter>
            <parameter name="header" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="challenge">
        <callback name="challenge">
          <return-value transfer-ownership="full">
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="domain" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuthDomain</doc>
              <type name="AuthDomain" c:type="SoupAuthDomain*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupServerMessage</doc>
              <type name="ServerMessage" c:type="SoupServerMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="check_password">
        <callback name="check_password">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether or not the message is authenticated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="domain" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupAuthDomain</doc>
              <type name="AuthDomain" c:type="SoupAuthDomain*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupServerMessage</doc>
              <type name="ServerMessage" c:type="SoupServerMessage*"/>
            </parameter>
            <parameter name="username" transfer-ownership="none">
              <doc xml:space="preserve">a username</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="password" transfer-ownership="none">
              <doc xml:space="preserve">a password</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AuthDomainDigest" c:symbol-prefix="auth_domain_digest" c:type="SoupAuthDomainDigest" parent="AuthDomain" final="1" glib:type-name="SoupAuthDomainDigest" glib:get-type="soup_auth_domain_digest_get_type" glib:type-struct="AuthDomainDigestClass">
      <doc xml:space="preserve">Server-side "Digest" authentication.

#SoupAuthDomainDigest handles the server side of HTTP "Digest"
authentication.</doc>
      <constructor name="new" c:identifier="soup_auth_domain_digest_new" introspectable="0">
        <doc xml:space="preserve">Creates a #SoupAuthDomainDigest.

You must set the [property@AuthDomain:realm] property, to indicate the realm name to
be returned with the authentication challenge to the client. Other parameters
are optional.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first option, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">option name/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <function name="encode_password" c:identifier="soup_auth_domain_digest_encode_password">
        <doc xml:space="preserve">Encodes the username/realm/password triplet for Digest
authentication.

That is, it returns a stringified MD5 hash of
@username, @realm, and @password concatenated together. This is
the form that is needed as the return value of
#SoupAuthDomainDigest's auth handler.

For security reasons, you should store the encoded hash, rather
than storing the cleartext password itself and calling this method
only when you need to verify it. This way, if your server is
compromised, the attackers will not gain access to cleartext
passwords which might also be usable at other sites. (Note also
that the encoded password returned by this method is identical to
the encoded password stored in an Apache .htdigest file.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded password</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">a username</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="realm" transfer-ownership="none">
            <doc xml:space="preserve">an auth realm name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password for @username in @realm</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="set_auth_callback" c:identifier="soup_auth_domain_digest_set_auth_callback" glib:set-property="auth-callback">
        <attribute name="org.gtk.Method.set_property" value="auth-callback"/>
        <doc xml:space="preserve">Sets the callback that @domain will use to authenticate incoming
requests.

For each request containing authorization, @domain will
invoke the callback, and then either accept or reject the request
based on @callback's return value.

You can also set the auth callback by setting the
[property@AuthDomainDigest:auth-callback] and
[property@AuthDomainDigest:auth-data] properties, which can also be used to
set the callback at construct time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the domain</doc>
            <type name="AuthDomainDigest" c:type="SoupAuthDomain*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the callback</doc>
            <type name="AuthDomainDigestAuthCallback" c:type="SoupAuthDomainDigestAuthCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @auth_callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="dnotify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data when @domain
  is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <property name="auth-callback" writable="1" transfer-ownership="none" setter="set_auth_callback">
        <attribute name="org.gtk.Property.set" value="soup_auth_domain_digest_set_auth_callback"/>
        <doc xml:space="preserve">The [callback@AuthDomainDigestAuthCallback].</doc>
        <type name="AuthDomainDigestAuthCallback" c:type="gpointer"/>
      </property>
      <property name="auth-data" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The data to pass to the [callback@AuthDomainDigestAuthCallback].</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
    </class>
    <callback name="AuthDomainDigestAuthCallback" c:type="SoupAuthDomainDigestAuthCallback">
      <doc xml:space="preserve">Callback used by #SoupAuthDomainDigest for authentication purposes.

The application should look up @username in its password database,
and return the corresponding encoded password (see
[func@AuthDomainDigest.encode_password].</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the encoded password, or %NULL if
  @username is not a valid user. @domain will free the password when
  it is done with it.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">the domain</doc>
          <type name="AuthDomainDigest" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being authenticated</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="username" transfer-ownership="none">
          <doc xml:space="preserve">the username provided by the client</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">the data passed to [method@AuthDomainDigest.set_auth_callback]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AuthDomainDigestClass" c:type="SoupAuthDomainDigestClass" glib:is-gtype-struct-for="AuthDomainDigest">
      <field name="parent_class">
        <type name="AuthDomainClass" c:type="SoupAuthDomainClass"/>
      </field>
    </record>
    <callback name="AuthDomainFilter" c:type="SoupAuthDomainFilter">
      <doc xml:space="preserve">The prototype for a #SoupAuthDomain filter.

See [method@AuthDomain.set_filter] for details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg requires authentication, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupServerMessage</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">the data passed to [method@AuthDomain.set_filter]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="AuthDomainGenericAuthCallback" c:type="SoupAuthDomainGenericAuthCallback">
      <doc xml:space="preserve">The prototype for a #SoupAuthDomain generic authentication callback.

The callback should look up the user's password, call
[method@AuthDomain.check_password], and use the return value from that method
as its own return value.

In general, for security reasons, it is preferable to use the
auth-domain-specific auth callbacks (eg,
[callback@AuthDomainBasicAuthCallback] and
[callback@AuthDomainDigestAuthCallback]), because they don't require
keeping a cleartext password database. Most users will use the same
password for many different sites, meaning if any site with a
cleartext password database is compromised, accounts on other
servers might be compromised as well. For many of the cases where
[class@Server] is used, this is not really relevant, but it may still
be worth considering.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg is authenticated, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupAuthDomain</doc>
          <type name="AuthDomain" c:type="SoupAuthDomain*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupServerMessage being authenticated</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="username" transfer-ownership="none">
          <doc xml:space="preserve">the username from @msg</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="3">
          <doc xml:space="preserve">the data passed to [method@AuthDomain.set_generic_auth_callback]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AuthManager" c:symbol-prefix="auth_manager" c:type="SoupAuthManager" parent="GObject.Object" final="1" glib:type-name="SoupAuthManager" glib:get-type="soup_auth_manager_get_type" glib:type-struct="AuthManagerClass">
      <doc xml:space="preserve">HTTP client-side authentication handler.

#SoupAuthManager is the [iface@SessionFeature] that handles HTTP
authentication for a [class@Session].

A #SoupAuthManager is added to the session by default, and normally
you don't need to worry about it at all. However, if you want to
disable HTTP authentication, you can remove the feature from the
session with [method@Session.remove_feature_by_type] or disable it on
individual requests with [method@Message.disable_feature].

You can use this with [method@Session.remove_feature_by_type] or
[method@Message.disable_feature].

(Although this type has only been publicly visible since libsoup 2.42, it has
always existed in the background, and you can use `g_type_from_name
("SoupAuthManager")` to get its [alias@GLib.Type] in earlier releases.)</doc>
      <implements name="SessionFeature"/>
      <method name="clear_cached_credentials" c:identifier="soup_auth_manager_clear_cached_credentials">
        <doc xml:space="preserve">Clear all credentials cached by @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthManager</doc>
            <type name="AuthManager" c:type="SoupAuthManager*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="use_auth" c:identifier="soup_auth_manager_use_auth">
        <doc xml:space="preserve">Records that @auth is to be used under @uri, as though a
WWW-Authenticate header had been received at that URI.

This can be used to "preload" @manager's auth cache, to avoid an extra HTTP
round trip in the case where you know ahead of time that a 401 response will
be returned.

This is only useful for authentication types where the initial
Authorization header does not depend on any additional information
from the server. (Eg, Basic or NTLM, but not Digest.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="manager" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthManager</doc>
            <type name="AuthManager" c:type="SoupAuthManager*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the #GUri under which @auth is to be used</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupAuth to use</doc>
            <type name="Auth" c:type="SoupAuth*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="AuthManagerClass" c:type="SoupAuthManagerClass" glib:is-gtype-struct-for="AuthManager">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="AuthNTLM" c:symbol-prefix="auth_ntlm" parent="Auth" final="1" glib:type-name="SoupAuthNTLM" glib:get-type="soup_auth_ntlm_get_type">
      <doc xml:space="preserve">HTTP-based NTLM authentication.

[class@Session]s do not support this type by default; if you want to
enable support for it, call [method@Session.add_feature_by_type],
passing %SOUP_TYPE_AUTH_NTLM.</doc>
    </class>
    <class name="AuthNegotiate" c:symbol-prefix="auth_negotiate" parent="Auth" final="1" glib:type-name="SoupAuthNegotiate" glib:get-type="soup_auth_negotiate_get_type">
      <doc xml:space="preserve">HTTP-based GSS-Negotiate authentication, as defined by
[RFC 4559](https://datatracker.ietf.org/doc/html/rfc4559).

[class@Session]s do not support this type by default; if you want to
enable support for it, call [method@Session.add_feature_by_type],
passing %SOUP_TYPE_AUTH_NEGOTIATE.

This auth type will only work if libsoup was compiled with GSSAPI
support; you can check [func@AuthNegotiate.supported] to see if it
was.</doc>
      <function name="supported" c:identifier="soup_auth_negotiate_supported">
        <doc xml:space="preserve">Indicates whether libsoup was built with GSSAPI support.

If this is %FALSE, %SOUP_TYPE_AUTH_NEGOTIATE will still be defined and can
still be added to a [class@Session], but libsoup will never attempt to
actually use this auth type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if supported otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
    </class>
    <function-macro name="CHECK_VERSION" c:identifier="SOUP_CHECK_VERSION" introspectable="0">
      <doc xml:space="preserve">Macro to test the version of libsoup being compiled against.

Returns %TRUE if the version of the libsoup header files
is the same as or newer than the passed-in version.</doc>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve">major version (e.g. 2 for version 2.42.0)</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve">minor version (e.g. 42 for version 2.42.0)</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve">micro version (e.g. 0 for version 2.42.0)</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="COOKIE_MAX_AGE_ONE_DAY" value="0" c:type="SOUP_COOKIE_MAX_AGE_ONE_DAY">
      <doc xml:space="preserve">A constant corresponding to 1 day.

For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_MAX_AGE_ONE_HOUR" value="3600" c:type="SOUP_COOKIE_MAX_AGE_ONE_HOUR">
      <doc xml:space="preserve">A constant corresponding to 1 hour.

For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_MAX_AGE_ONE_WEEK" value="0" c:type="SOUP_COOKIE_MAX_AGE_ONE_WEEK">
      <doc xml:space="preserve">A constant corresponding to 1 week.

For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="COOKIE_MAX_AGE_ONE_YEAR" value="0" c:type="SOUP_COOKIE_MAX_AGE_ONE_YEAR">
      <doc xml:space="preserve">A constant corresponding to 1 year.

For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Cache" c:symbol-prefix="cache" c:type="SoupCache" parent="GObject.Object" glib:type-name="SoupCache" glib:get-type="soup_cache_get_type" glib:type-struct="CacheClass">
      <doc xml:space="preserve">File-based cache for HTTP resources.</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_cache_new">
        <doc xml:space="preserve">Creates a new #SoupCache.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupCache</doc>
          <type name="Cache" c:type="SoupCache*"/>
        </return-value>
        <parameters>
          <parameter name="cache_dir" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the directory to store the cached data, or %NULL
  to use the default one. Note that since the cache isn't safe to access for
  multiple processes at once, and the default directory isn't namespaced by
  process, clients are strongly discouraged from passing %NULL.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="cache_type" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupCacheType of the cache</doc>
            <type name="CacheType" c:type="SoupCacheType"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="get_cacheability">
        <return-value transfer-ownership="none">
          <type name="Cacheability" c:type="SoupCacheability"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear" c:identifier="soup_cache_clear">
        <doc xml:space="preserve">Will remove all entries in the @cache plus all the cache files.

This is not thread safe and must be called only from the thread that created the #SoupCache</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="soup_cache_dump">
        <doc xml:space="preserve">Synchronously writes the cache index out to disk.

Contrast with [method@Cache.flush], which writes pending cache *entries* to
disk.

You must call this before exiting if you want your cache data to
persist between sessions.

This is not thread safe and must be called only from the thread that created the #SoupCache</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="soup_cache_flush">
        <doc xml:space="preserve">Forces all pending writes in the @cache to be
committed to disk.

For doing so it will iterate the [struct@GLib.MainContext] associated with
@cache's session as long as needed.

Contrast with [method@Cache.dump], which writes out the cache index file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_size" c:identifier="soup_cache_get_max_size">
        <doc xml:space="preserve">Gets the maximum size of the cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum size of the cache, in bytes.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load" c:identifier="soup_cache_load">
        <doc xml:space="preserve">Loads the contents of @cache's index into memory.

This is not thread safe and must be called only from the thread that created the #SoupCache</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_max_size" c:identifier="soup_cache_set_max_size">
        <doc xml:space="preserve">Sets the maximum size of the cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCache</doc>
            <type name="Cache" c:type="SoupCache*"/>
          </instance-parameter>
          <parameter name="max_size" transfer-ownership="none">
            <doc xml:space="preserve">the maximum size of the cache, in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="cache-dir" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The directory to store the cache files.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="cache-type" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the cache is private or shared.</doc>
        <type name="CacheType"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="CacheClass" c:type="SoupCacheClass" glib:is-gtype-struct-for="Cache">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="get_cacheability">
        <callback name="get_cacheability">
          <return-value transfer-ownership="none">
            <type name="Cacheability" c:type="SoupCacheability"/>
          </return-value>
          <parameters>
            <parameter name="cache" transfer-ownership="none">
              <type name="Cache" c:type="SoupCache*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="CacheType" glib:type-name="SoupCacheType" glib:get-type="soup_cache_type_get_type" c:type="SoupCacheType">
      <doc xml:space="preserve">The type of cache; this affects what kinds of responses will be
saved.</doc>
      <member name="single_user" value="0" c:identifier="SOUP_CACHE_SINGLE_USER" glib:nick="single-user" glib:name="SOUP_CACHE_SINGLE_USER">
        <doc xml:space="preserve">a single-user cache</doc>
      </member>
      <member name="shared" value="1" c:identifier="SOUP_CACHE_SHARED" glib:nick="shared" glib:name="SOUP_CACHE_SHARED">
        <doc xml:space="preserve">a shared cache</doc>
      </member>
    </enumeration>
    <bitfield name="Cacheability" glib:type-name="SoupCacheability" glib:get-type="soup_cacheability_get_type" c:type="SoupCacheability">
      <doc xml:space="preserve">Indicates if a message should or shouldn't be cached.</doc>
      <member name="cacheable" value="1" c:identifier="SOUP_CACHE_CACHEABLE" glib:nick="cacheable" glib:name="SOUP_CACHE_CACHEABLE">
        <doc xml:space="preserve">The message should be cached</doc>
      </member>
      <member name="uncacheable" value="2" c:identifier="SOUP_CACHE_UNCACHEABLE" glib:nick="uncacheable" glib:name="SOUP_CACHE_UNCACHEABLE">
        <doc xml:space="preserve">The message shouldn't be cached</doc>
      </member>
      <member name="invalidates" value="4" c:identifier="SOUP_CACHE_INVALIDATES" glib:nick="invalidates" glib:name="SOUP_CACHE_INVALIDATES">
        <doc xml:space="preserve">The messages cache should be invalidated</doc>
      </member>
      <member name="validates" value="8" c:identifier="SOUP_CACHE_VALIDATES" glib:nick="validates" glib:name="SOUP_CACHE_VALIDATES">
        <doc xml:space="preserve">The messages cache should be updated</doc>
      </member>
    </bitfield>
    <class name="ContentDecoder" c:symbol-prefix="content_decoder" c:type="SoupContentDecoder" parent="GObject.Object" final="1" glib:type-name="SoupContentDecoder" glib:get-type="soup_content_decoder_get_type" glib:type-struct="ContentDecoderClass">
      <doc xml:space="preserve">Handles decoding of HTTP messages.

#SoupContentDecoder handles adding the "Accept-Encoding" header on
outgoing messages, and processing the "Content-Encoding" header on
incoming ones. Currently it supports the "gzip", "deflate", and "br"
content codings.

A #SoupContentDecoder will automatically be
added to the session by default. (You can use
[method@Session.remove_feature_by_type] if you don't
want this.)

If #SoupContentDecoder successfully decodes the Content-Encoding,
the message body will contain the decoded data; however, the message headers
will be unchanged (and so "Content-Encoding" will still be present,
"Content-Length" will describe the original encoded length, etc).

If "Content-Encoding" contains any encoding types that
#SoupContentDecoder doesn't recognize, then none of the encodings
will be decoded.

(Note that currently there is no way to (automatically) use
Content-Encoding when sending a request body, or to pick specific
encoding types to support.)</doc>
      <implements name="SessionFeature"/>
    </class>
    <record name="ContentDecoderClass" c:type="SoupContentDecoderClass" glib:is-gtype-struct-for="ContentDecoder">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="ContentSniffer" c:symbol-prefix="content_sniffer" c:type="SoupContentSniffer" parent="GObject.Object" final="1" glib:type-name="SoupContentSniffer" glib:get-type="soup_content_sniffer_get_type" glib:type-struct="ContentSnifferClass">
      <doc xml:space="preserve">Sniffs the mime type of messages.

A #SoupContentSniffer tries to detect the actual content type of
the files that are being downloaded by looking at some of the data
before the [class@Message] emits its [signal@Message::got-headers] signal.
#SoupContentSniffer implements [iface@SessionFeature], so you can add
content sniffing to a session with [method@Session.add_feature] or
[method@Session.add_feature_by_type].</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_content_sniffer_new">
        <doc xml:space="preserve">Creates a new #SoupContentSniffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupContentSniffer</doc>
          <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
        </return-value>
      </constructor>
      <method name="sniff" c:identifier="soup_content_sniffer_sniff">
        <doc xml:space="preserve">Sniffs @buffer to determine its Content-Type.

The result may also be influenced by the Content-Type declared in @msg's
response headers.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the sniffed Content-Type of @buffer; this will never be %NULL,
  but may be `application/octet-stream`.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sniffer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupContentSniffer</doc>
            <type name="ContentSniffer" c:type="SoupContentSniffer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message to sniff</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a buffer containing the start of @msg's response body</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
          <parameter name="params" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">return
  location for Content-Type parameters (eg, "charset"), or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="ContentSnifferClass" c:type="SoupContentSnifferClass" glib:is-gtype-struct-for="ContentSniffer">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="Cookie" c:type="SoupCookie" glib:type-name="SoupCookie" glib:get-type="soup_cookie_get_type" c:symbol-prefix="cookie">
      <doc xml:space="preserve">Implements HTTP cookies, as described by
[RFC 6265](http://tools.ietf.org/html/rfc6265.txt).

To have a [class@Session] handle cookies for your appliction
automatically, use a [class@CookieJar].

@name and @value will be set for all cookies. If the cookie is
generated from a string that appears to have no name, then @name
will be the empty string.

@domain and @path give the host or domain, and path within that
host/domain, to restrict this cookie to. If @domain starts with
".", that indicates a domain (which matches the string after the
".", or any hostname that has @domain as a suffix). Otherwise, it
is a hostname and must match exactly.

@expires will be non-%NULL if the cookie uses either the original
"expires" attribute, or the newer "max-age" attribute. If @expires
is %NULL, it indicates that neither "expires" nor "max-age" was
specified, and the cookie expires at the end of the session.

If @http_only is set, the cookie should not be exposed to untrusted
code (eg, javascript), so as to minimize the danger posed by
cross-site scripting attacks.</doc>
      <constructor name="new" c:identifier="soup_cookie_new">
        <doc xml:space="preserve">Creates a new #SoupCookie with the given attributes.

Use [method@Cookie.set_secure] and [method@Cookie.set_http_only] if you
need to set those attributes on the returned cookie.

If @domain starts with ".", that indicates a domain (which matches
the string after the ".", or any hostname that has @domain as a
suffix). Otherwise, it is a hostname and must match exactly.

@max_age is used to set the "expires" attribute on the cookie; pass
-1 to not include the attribute (indicating that the cookie expires
with the current session), 0 for an already-expired cookie, or a
lifetime in seconds. You can use the constants
%SOUP_COOKIE_MAX_AGE_ONE_HOUR, %SOUP_COOKIE_MAX_AGE_ONE_DAY,
%SOUP_COOKIE_MAX_AGE_ONE_WEEK and %SOUP_COOKIE_MAX_AGE_ONE_YEAR (or
multiples thereof) to calculate this value. (If you really care
about setting the exact time that the cookie will expire, use
[method@Cookie.set_expires].)

As of version 3.4.0 the default value of a cookie's same-site-policy
is %SOUP_SAME_SITE_POLICY_LAX.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupCookie.</doc>
          <type name="Cookie" c:type="SoupCookie*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">cookie name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">cookie value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">cookie domain or hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">cookie path, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="max_age" transfer-ownership="none">
            <doc xml:space="preserve">max age of the cookie, or -1 for a session cookie</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="applies_to_uri" c:identifier="soup_cookie_applies_to_uri">
        <doc xml:space="preserve">Tests if @cookie should be sent to @uri.

(At the moment, this does not check that @cookie's domain matches
@uri, because it assumes that the caller has already done that.
But don't rely on that; it may change in the future.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @cookie should be sent to @uri, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="soup_cookie_copy">
        <doc xml:space="preserve">Copies @cookie.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @cookie</doc>
          <type name="Cookie" c:type="SoupCookie*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="domain_matches" c:identifier="soup_cookie_domain_matches">
        <doc xml:space="preserve">Checks if the @cookie's domain and @host match.

The domains match if @cookie should be sent when making a request to @host,
or that @cookie should be accepted when receiving a response from @host.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the domains match, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="host" transfer-ownership="none">
            <doc xml:space="preserve">a URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="soup_cookie_equal">
        <doc xml:space="preserve">Tests if @cookie1 and @cookie2 are equal.

Note that currently, this does not check that the cookie domains
match. This may change in the future.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the cookies are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie1" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="cookie2" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_cookie_free">
        <doc xml:space="preserve">Frees @cookie.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domain" c:identifier="soup_cookie_get_domain">
        <doc xml:space="preserve">Gets @cookie's domain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's domain</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_expires" c:identifier="soup_cookie_get_expires">
        <doc xml:space="preserve">Gets @cookie's expiration time.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@cookie's expiration time, which is
  owned by @cookie and should not be modified or freed.</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #GDateTime</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_http_only" c:identifier="soup_cookie_get_http_only">
        <doc xml:space="preserve">Gets @cookie's HttpOnly attribute.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's HttpOnly attribute</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="soup_cookie_get_name">
        <doc xml:space="preserve">Gets @cookie's name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="soup_cookie_get_path">
        <doc xml:space="preserve">Gets @cookie's path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's path</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_same_site_policy" c:identifier="soup_cookie_get_same_site_policy">
        <doc xml:space="preserve">Returns the same-site policy for this cookie.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupSameSitePolicy</doc>
          <type name="SameSitePolicy" c:type="SoupSameSitePolicy"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secure" c:identifier="soup_cookie_get_secure">
        <doc xml:space="preserve">Gets @cookie's secure attribute.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's secure attribute</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="soup_cookie_get_value">
        <doc xml:space="preserve">Gets @cookie's value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@cookie's value</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_domain" c:identifier="soup_cookie_set_domain">
        <doc xml:space="preserve">Sets @cookie's domain to @domain.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">the new domain</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expires" c:identifier="soup_cookie_set_expires">
        <doc xml:space="preserve">Sets @cookie's expiration time to @expires.

If @expires is %NULL, @cookie will be a session cookie and will expire at the
end of the client's session.

(This sets the same property as [method@Cookie.set_max_age].)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="expires" transfer-ownership="none">
            <doc xml:space="preserve">the new expiration time, or %NULL</doc>
            <type name="GLib.DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_http_only" c:identifier="soup_cookie_set_http_only">
        <doc xml:space="preserve">Sets @cookie's HttpOnly attribute to @http_only.

If %TRUE, @cookie will be marked as "http only", meaning it should not be
exposed to web page scripts or other untrusted code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="http_only" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the HttpOnly attribute</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_age" c:identifier="soup_cookie_set_max_age">
        <doc xml:space="preserve">Sets @cookie's max age to @max_age.

If @max_age is -1, the cookie is a session cookie, and will expire at the end
of the client's session. Otherwise, it is the number of seconds until the
cookie expires. You can use the constants %SOUP_COOKIE_MAX_AGE_ONE_HOUR,
%SOUP_COOKIE_MAX_AGE_ONE_DAY, %SOUP_COOKIE_MAX_AGE_ONE_WEEK and
%SOUP_COOKIE_MAX_AGE_ONE_YEAR (or multiples thereof) to calculate this value.
(A value of 0 indicates that the cookie should be considered
already-expired.)

This sets the same property as [method@Cookie.set_expires].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="max_age" transfer-ownership="none">
            <doc xml:space="preserve">the new max age</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="soup_cookie_set_name">
        <doc xml:space="preserve">Sets @cookie's name to @name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the new name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path" c:identifier="soup_cookie_set_path">
        <doc xml:space="preserve">Sets @cookie's path to @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the new path</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_same_site_policy" c:identifier="soup_cookie_set_same_site_policy">
        <doc xml:space="preserve">When used in conjunction with
[method@CookieJar.get_cookie_list_with_same_site_info] this sets the policy
of when this cookie should be exposed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSameSitePolicy</doc>
            <type name="SameSitePolicy" c:type="SoupSameSitePolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_secure" c:identifier="soup_cookie_set_secure">
        <doc xml:space="preserve">Sets @cookie's secure attribute to @secure.

If %TRUE, @cookie will only be transmitted from the client to the server over
secure (https) connections.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="secure" transfer-ownership="none">
            <doc xml:space="preserve">the new value for the secure attribute</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="soup_cookie_set_value">
        <doc xml:space="preserve">Sets @cookie's value to @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_cookie_header" c:identifier="soup_cookie_to_cookie_header">
        <doc xml:space="preserve">Serializes @cookie in the format used by the Cookie header (ie, for
returning a cookie from a [class@Session] to a server).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the header</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_set_cookie_header" c:identifier="soup_cookie_to_set_cookie_header">
        <doc xml:space="preserve">Serializes @cookie in the format used by the Set-Cookie header.

i.e. for sending a cookie from a [class@Server] to a client.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the header</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="parse" c:identifier="soup_cookie_parse">
        <doc xml:space="preserve">Parses @header and returns a #SoupCookie.

If @header contains multiple cookies, only the first one will be parsed.

If @header does not have "path" or "domain" attributes, they will
be defaulted from @origin. If @origin is %NULL, path will default
to "/", but domain will be left as %NULL. Note that this is not a
valid state for a #SoupCookie, and you will need to fill in some
appropriate string for the domain if you want to actually make use
of the cookie.

As of version 3.4.0 the default value of a cookie's same-site-policy
is %SOUP_SAME_SITE_POLICY_LAX.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupCookie, or %NULL if it could
  not be parsed, or contained an illegal "domain" attribute for a
  cookie originating from @origin.</doc>
          <type name="Cookie" c:type="SoupCookie*"/>
        </return-value>
        <parameters>
          <parameter name="header" transfer-ownership="none">
            <doc xml:space="preserve">a cookie string (eg, the value of a Set-Cookie header)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">origin of the cookie</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="CookieJar" c:symbol-prefix="cookie_jar" c:type="SoupCookieJar" parent="GObject.Object" glib:type-name="SoupCookieJar" glib:get-type="soup_cookie_jar_get_type" glib:type-struct="CookieJarClass">
      <doc xml:space="preserve">Automatic cookie handling for SoupSession.

A #SoupCookieJar stores [struct@Cookie]s and arrange for them to be sent with
the appropriate [class@Message]s. #SoupCookieJar implements
[iface@SessionFeature], so you can add a cookie jar to a session with
[method@Session.add_feature] or [method@Session.add_feature_by_type].

Note that the base #SoupCookieJar class does not support any form
of long-term cookie persistence.</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_cookie_jar_new">
        <doc xml:space="preserve">Creates a new #SoupCookieJar.

The base #SoupCookieJar class does not support persistent storage of cookies;
use a subclass for that.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupCookieJar</doc>
          <type name="CookieJar" c:type="SoupCookieJar*"/>
        </return-value>
      </constructor>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="old_cookie" transfer-ownership="none">
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
          <parameter name="new_cookie" transfer-ownership="none">
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_persistent" invoker="is_persistent">
        <doc xml:space="preserve">Gets whether @jar stores cookies persistenly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @jar storage is persistent or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_cookie" c:identifier="soup_cookie_jar_add_cookie">
        <doc xml:space="preserve">Adds @cookie to @jar.

Emits the [signal@CookieJar::changed] signal if we are modifying
an existing cookie or adding a valid new cookie ('valid' means
that the cookie's expire date is not in the past).

@cookie will be 'stolen' by the jar, so don't free it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="cookie" transfer-ownership="full">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_cookie_full" c:identifier="soup_cookie_jar_add_cookie_full">
        <doc xml:space="preserve">Adds @cookie to @jar.

Emits the [signal@CookieJar::changed] signal if we are modifying an existing
cookie or adding a valid new cookie ('valid' means that the cookie's expire
date is not in the past).

@first_party will be used to reject cookies coming from third party
resources in case such a security policy is set in the @jar.

@uri will be used to reject setting or overwriting secure cookies
from insecure origins. %NULL is treated as secure.

@cookie will be 'stolen' by the jar, so don't free it afterwards.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="cookie" transfer-ownership="full">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the URI setting the cookie</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="first_party" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the URI for the main document</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_cookie_with_first_party" c:identifier="soup_cookie_jar_add_cookie_with_first_party">
        <doc xml:space="preserve">Adds @cookie to @jar.

Emits the [signal@CookieJar::changed] signal if we are modifying
an existing cookie or adding a valid new cookie ('valid' means
that the cookie's expire date is not in the past).

@first_party will be used to reject cookies coming from third party
resources in case such a security policy is set in the @jar.

@cookie will be 'stolen' by the jar, so don't free it afterwards.

For secure cookies to work properly you may want to use
[method@CookieJar.add_cookie_full].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="first_party" transfer-ownership="none">
            <doc xml:space="preserve">the URI for the main document</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="cookie" transfer-ownership="full">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="all_cookies" c:identifier="soup_cookie_jar_all_cookies">
        <doc xml:space="preserve">Constructs a [struct@GLib.List] with every cookie inside the @jar.

The cookies in the list are a copy of the original, so
you have to free them when you are done with them.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList
  with all the cookies in the @jar.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete_cookie" c:identifier="soup_cookie_jar_delete_cookie">
        <doc xml:space="preserve">Deletes @cookie from @jar.

Emits the [signal@CookieJar::changed] signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookie</doc>
            <type name="Cookie" c:type="SoupCookie*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_accept_policy" c:identifier="soup_cookie_jar_get_accept_policy" glib:get-property="accept-policy">
        <attribute name="org.gtk.Method.get_property" value="accept-policy"/>
        <doc xml:space="preserve">Gets @jar's [enum@CookieJarAcceptPolicy].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #SoupCookieJarAcceptPolicy set in the @jar</doc>
          <type name="CookieJarAcceptPolicy" c:type="SoupCookieJarAcceptPolicy"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cookie_list" c:identifier="soup_cookie_jar_get_cookie_list">
        <doc xml:space="preserve">Retrieves the list of cookies that would be sent with a request to @uri
as a [struct@GLib.List] of #SoupCookie objects.

If @for_http is %TRUE, the return value will include cookies marked
"HttpOnly" (that is, cookies that the server wishes to keep hidden
from client-side scripting operations such as the JavaScript
document.cookies property). Since #SoupCookieJar sets the Cookie
header itself when making the actual HTTP request, you should
almost certainly be setting @for_http to %FALSE if you are calling
this.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList
  with the cookies in the @jar that would be sent with a request to @uri.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="for_http" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the return value is being passed directly
  to an HTTP operation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cookie_list_with_same_site_info" c:identifier="soup_cookie_jar_get_cookie_list_with_same_site_info">
        <doc xml:space="preserve">This is an extended version of [method@CookieJar.get_cookie_list] that
provides more information required to use SameSite cookies.

See the [SameSite cookies
spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for
more detailed information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList
  with the cookies in the @jar that would be sent with a request to @uri.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="top_level" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GUri for the top level document</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="site_for_cookies" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GUri indicating the origin to get cookies for</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="for_http" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the return value is being passed directly
  to an HTTP operation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="is_safe_method" transfer-ownership="none">
            <doc xml:space="preserve">if the HTTP method is safe, as defined by RFC 7231, ignored when @for_http is %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="is_top_level_navigation" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the HTTP request is part of
  top level navigation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cookies" c:identifier="soup_cookie_jar_get_cookies">
        <doc xml:space="preserve">Retrieves (in Cookie-header form) the list of cookies that would
be sent with a request to @uri.

If @for_http is %TRUE, the return value will include cookies marked
"HttpOnly" (that is, cookies that the server wishes to keep hidden
from client-side scripting operations such as the JavaScript
document.cookies property). Since #SoupCookieJar sets the Cookie
header itself when making the actual HTTP request, you should
almost certainly be setting @for_http to %FALSE if you are calling
this.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the cookies, in string form, or %NULL if
  there are no cookies for @uri.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">a #GUri</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="for_http" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the return value is being passed directly
  to an HTTP operation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_persistent" c:identifier="soup_cookie_jar_is_persistent">
        <doc xml:space="preserve">Gets whether @jar stores cookies persistenly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @jar storage is persistent or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_accept_policy" c:identifier="soup_cookie_jar_set_accept_policy" glib:set-property="accept-policy">
        <attribute name="org.gtk.Method.set_property" value="accept-policy"/>
        <doc xml:space="preserve">Sets @policy as the cookie acceptance policy for @jar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJarAcceptPolicy</doc>
            <type name="CookieJarAcceptPolicy" c:type="SoupCookieJarAcceptPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cookie" c:identifier="soup_cookie_jar_set_cookie">
        <doc xml:space="preserve">Adds @cookie to @jar, exactly as though it had appeared in a
Set-Cookie header returned from a request to @uri.

Keep in mind that if the [enum@CookieJarAcceptPolicy] set is either
%SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY or
%SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY you'll need to use
[method@CookieJar.set_cookie_with_first_party], otherwise the jar
will have no way of knowing if the cookie is being set by a third
party or not.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI setting the cookie</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">the stringified cookie to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cookie_with_first_party" c:identifier="soup_cookie_jar_set_cookie_with_first_party">
        <doc xml:space="preserve">Adds @cookie to @jar, exactly as though it had appeared in a
Set-Cookie header returned from a request to @uri.

@first_party will be used to reject cookies coming from third party resources
in case such a security policy is set in the @jar.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="jar" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupCookieJar</doc>
            <type name="CookieJar" c:type="SoupCookieJar*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI setting the cookie</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="first_party" transfer-ownership="none">
            <doc xml:space="preserve">the URI for the main document</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">the stringified cookie to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="accept-policy" writable="1" transfer-ownership="none" setter="set_accept_policy" getter="get_accept_policy">
        <attribute name="org.gtk.Property.get" value="soup_cookie_jar_get_accept_policy"/>
        <attribute name="org.gtk.Property.set" value="soup_cookie_jar_set_accept_policy"/>
        <doc xml:space="preserve">The policy the jar should follow to accept or reject cookies.</doc>
        <type name="CookieJarAcceptPolicy"/>
      </property>
      <property name="read-only" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the cookie jar is read-only.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="first">
        <doc xml:space="preserve">Emitted when @jar changes.

If a cookie has been added,
@new_cookie will contain the newly-added cookie and
@old_cookie will be %NULL. If a cookie has been deleted,
@old_cookie will contain the to-be-deleted cookie and
@new_cookie will be %NULL. If a cookie has been changed,
@old_cookie will contain its old value, and @new_cookie its
new value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_cookie" transfer-ownership="none">
            <doc xml:space="preserve">the old #SoupCookie value</doc>
            <type name="Cookie"/>
          </parameter>
          <parameter name="new_cookie" transfer-ownership="none">
            <doc xml:space="preserve">the new #SoupCookie value</doc>
            <type name="Cookie"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="CookieJarAcceptPolicy" glib:type-name="SoupCookieJarAcceptPolicy" glib:get-type="soup_cookie_jar_accept_policy_get_type" c:type="SoupCookieJarAcceptPolicy">
      <doc xml:space="preserve">The policy for accepting or rejecting cookies returned in
responses.</doc>
      <member name="always" value="0" c:identifier="SOUP_COOKIE_JAR_ACCEPT_ALWAYS" glib:nick="always" glib:name="SOUP_COOKIE_JAR_ACCEPT_ALWAYS">
        <doc xml:space="preserve">accept all cookies unconditionally.</doc>
      </member>
      <member name="never" value="1" c:identifier="SOUP_COOKIE_JAR_ACCEPT_NEVER" glib:nick="never" glib:name="SOUP_COOKIE_JAR_ACCEPT_NEVER">
        <doc xml:space="preserve">reject all cookies unconditionally.</doc>
      </member>
      <member name="no_third_party" value="2" c:identifier="SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY" glib:nick="no-third-party" glib:name="SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY">
        <doc xml:space="preserve">accept all cookies set by the main
  document loaded in the application using libsoup. An example of the most
  common case, web browsers, would be: If http://www.example.com is the page
  loaded, accept all cookies set by example.com, but if a resource from
  http://www.third-party.com is loaded from that page reject any cookie that
  it could try to set. For libsoup to be able to tell apart first party
  cookies from the rest, the application must call
  [method@Message.set_first_party] on each outgoing [class@Message], setting
  the [struct@GLib.Uri] of the main document. If no first party is set in a
  message when this policy is in effect, cookies will be assumed to be third
  party by default.</doc>
      </member>
      <member name="grandfathered_third_party" value="3" c:identifier="SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY" glib:nick="grandfathered-third-party" glib:name="SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY">
        <doc xml:space="preserve">accept all cookies set by
  the main document loaded in the application using libsoup, and from domains
  that have previously set at least one cookie when loaded as the main
  document. An example of the most common case, web browsers, would be: if
  http://www.example.com is the page loaded, accept all cookies set by
  example.com, but if a resource from http://www.third-party.com is loaded
  from that page, reject any cookie that it could try to set unless it
  already has a cookie in the cookie jar. For libsoup to be able to tell
  apart first party cookies from the rest, the application must call
  [method@Message.set_first_party] on each outgoing #SoupMessage, setting the
  [struct@GLib.Uri] of the main document. If no first party is set in a
  message when this policy is in effect, cookies will be assumed to be third
  party by default.</doc>
      </member>
    </enumeration>
    <record name="CookieJarClass" c:type="SoupCookieJarClass" glib:is-gtype-struct-for="CookieJar">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="save">
        <callback name="save">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="jar" transfer-ownership="none">
              <type name="CookieJar" c:type="SoupCookieJar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_persistent">
        <callback name="is_persistent">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @jar storage is persistent or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="jar" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupCookieJar</doc>
              <type name="CookieJar" c:type="SoupCookieJar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="jar" transfer-ownership="none">
              <type name="CookieJar" c:type="SoupCookieJar*"/>
            </parameter>
            <parameter name="old_cookie" transfer-ownership="none">
              <type name="Cookie" c:type="SoupCookie*"/>
            </parameter>
            <parameter name="new_cookie" transfer-ownership="none">
              <type name="Cookie" c:type="SoupCookie*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="CookieJarDB" c:symbol-prefix="cookie_jar_db" c:type="SoupCookieJarDB" parent="CookieJar" final="1" glib:type-name="SoupCookieJarDB" glib:get-type="soup_cookie_jar_db_get_type" glib:type-struct="CookieJarDBClass">
      <doc xml:space="preserve">Database-based Cookie Jar.

#SoupCookieJarDB is a [class@CookieJar] that reads cookies from and writes
them to a sqlite database in the new Mozilla format.

(This is identical to `SoupCookieJarSqlite` in
libsoup-gnome; it has just been moved into libsoup proper, and
renamed to avoid conflicting.)</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_cookie_jar_db_new">
        <doc xml:space="preserve">Creates a #SoupCookieJarDB.

@filename will be read in at startup to create an initial set of cookies. If
@read_only is %FALSE, then the non-session cookies will be written to
@filename when the [signal@CookieJar::changed] signal is emitted from the
jar. (If @read_only is %TRUE, then the cookie jar will only be used for this
session, and changes made to it will be lost when the jar is destroyed.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupCookieJar</doc>
          <type name="CookieJar" c:type="SoupCookieJar*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the filename to read to/write from, or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="read_only" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @filename is read-only</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="filename" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Cookie-storage filename.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </class>
    <record name="CookieJarDBClass" c:type="SoupCookieJarDBClass" glib:is-gtype-struct-for="CookieJarDB">
      <field name="parent_class">
        <type name="CookieJarClass" c:type="SoupCookieJarClass"/>
      </field>
    </record>
    <class name="CookieJarText" c:symbol-prefix="cookie_jar_text" c:type="SoupCookieJarText" parent="CookieJar" final="1" glib:type-name="SoupCookieJarText" glib:get-type="soup_cookie_jar_text_get_type" glib:type-struct="CookieJarTextClass">
      <doc xml:space="preserve">Text-file-based ("cookies.txt") Cookie Jar

#SoupCookieJarText is a [class@CookieJar] that reads cookies from and writes
them to a text file in format similar to Mozilla's "cookies.txt".</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_cookie_jar_text_new">
        <doc xml:space="preserve">Creates a #SoupCookieJarText.

@filename will be read in at startup to create an initial set of cookies. If
@read_only is %FALSE, then the non-session cookies will be written to
@filename when the [signal@CookieJar::changed] signal is emitted from the
jar. (If @read_only is %TRUE, then the cookie jar will only be used for this
session, and changes made to it will be lost when the jar is destroyed.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupCookieJar</doc>
          <type name="CookieJar" c:type="SoupCookieJar*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the filename to read to/write from</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="read_only" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @filename is read-only</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="filename" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Cookie-storage filename.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </class>
    <record name="CookieJarTextClass" c:type="SoupCookieJarTextClass" glib:is-gtype-struct-for="CookieJarText">
      <field name="parent_class">
        <type name="CookieJarClass" c:type="SoupCookieJarClass"/>
      </field>
    </record>
    <function-macro name="DEPRECATED_FOR" c:identifier="SOUP_DEPRECATED_FOR" introspectable="0">
      <doc xml:space="preserve">Marks a symbol as deprecated in favor of another symbol.

You should use `SOUP_DEPRECATED_FOR_IN_*` in order to handle versioning.</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">the symbol that replaces the deprecated one</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_0_FOR" c:identifier="SOUP_DEPRECATED_IN_3_0_FOR" introspectable="0">
      <doc xml:space="preserve">A macro used to indicate a symbol was deprecated in this version with a replacement.</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">The recommended replacement function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_2_FOR" c:identifier="SOUP_DEPRECATED_IN_3_2_FOR" introspectable="0">
      <doc xml:space="preserve">A macro used to indicate a symbol was deprecated in this version with a replacement.</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">The recommended replacement function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_4_FOR" c:identifier="SOUP_DEPRECATED_IN_3_4_FOR" introspectable="0">
      <doc xml:space="preserve">A macro used to indicate a symbol was deprecated in this version with a replacement.</doc>
      <parameters>
        <parameter name="f">
          <doc xml:space="preserve">The recommended replacement function.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="DateFormat" glib:type-name="SoupDateFormat" glib:get-type="soup_date_format_get_type" c:type="SoupDateFormat">
      <doc xml:space="preserve">Date formats that [func@date_time_to_string] can use.

@SOUP_DATE_HTTP and @SOUP_DATE_COOKIE always coerce the time to
UTC.

This enum may be extended with more values in future releases.</doc>
      <member name="http" value="1" c:identifier="SOUP_DATE_HTTP" glib:nick="http" glib:name="SOUP_DATE_HTTP">
        <doc xml:space="preserve">RFC 1123 format, used by the HTTP "Date" header. Eg
  "Sun, 06 Nov 1994 08:49:37 GMT".</doc>
      </member>
      <member name="cookie" value="2" c:identifier="SOUP_DATE_COOKIE" glib:nick="cookie" glib:name="SOUP_DATE_COOKIE">
        <doc xml:space="preserve">The format for the "Expires" timestamp in the
  Netscape cookie specification. Eg, "Sun, 06-Nov-1994 08:49:37 GMT".</doc>
      </member>
    </enumeration>
    <enumeration name="Encoding" glib:type-name="SoupEncoding" glib:get-type="soup_encoding_get_type" c:type="SoupEncoding">
      <doc xml:space="preserve">How a message body is encoded for transport</doc>
      <member name="unrecognized" value="0" c:identifier="SOUP_ENCODING_UNRECOGNIZED" glib:nick="unrecognized" glib:name="SOUP_ENCODING_UNRECOGNIZED">
        <doc xml:space="preserve">unknown / error</doc>
      </member>
      <member name="none" value="1" c:identifier="SOUP_ENCODING_NONE" glib:nick="none" glib:name="SOUP_ENCODING_NONE">
        <doc xml:space="preserve">no body is present (which is not the same as a
  0-length body, and only occurs in certain places)</doc>
      </member>
      <member name="content_length" value="2" c:identifier="SOUP_ENCODING_CONTENT_LENGTH" glib:nick="content-length" glib:name="SOUP_ENCODING_CONTENT_LENGTH">
        <doc xml:space="preserve">Content-Length encoding</doc>
      </member>
      <member name="eof" value="3" c:identifier="SOUP_ENCODING_EOF" glib:nick="eof" glib:name="SOUP_ENCODING_EOF">
        <doc xml:space="preserve">Response body ends when the connection is closed</doc>
      </member>
      <member name="chunked" value="4" c:identifier="SOUP_ENCODING_CHUNKED" glib:nick="chunked" glib:name="SOUP_ENCODING_CHUNKED">
        <doc xml:space="preserve">chunked encoding (currently only supported
  for response)</doc>
      </member>
      <member name="byteranges" value="5" c:identifier="SOUP_ENCODING_BYTERANGES" glib:nick="byteranges" glib:name="SOUP_ENCODING_BYTERANGES">
        <doc xml:space="preserve">multipart/byteranges (Reserved for future
  use: NOT CURRENTLY IMPLEMENTED)</doc>
      </member>
    </enumeration>
    <bitfield name="Expectation" glib:type-name="SoupExpectation" glib:get-type="soup_expectation_get_type" c:type="SoupExpectation">
      <doc xml:space="preserve">Represents the parsed value of the "Expect" header.</doc>
      <member name="unrecognized" value="1" c:identifier="SOUP_EXPECTATION_UNRECOGNIZED" glib:nick="unrecognized" glib:name="SOUP_EXPECTATION_UNRECOGNIZED">
        <doc xml:space="preserve">any unrecognized expectation</doc>
      </member>
      <member name="continue" value="2" c:identifier="SOUP_EXPECTATION_CONTINUE" glib:nick="continue" glib:name="SOUP_EXPECTATION_CONTINUE">
        <doc xml:space="preserve">"100-continue"</doc>
      </member>
    </bitfield>
    <constant name="FORM_MIME_TYPE_MULTIPART" value="multipart/form-data" c:type="SOUP_FORM_MIME_TYPE_MULTIPART">
      <doc xml:space="preserve">A macro containing the value
`multipart/form-data`; the MIME type used for
posting form data that contains files to be uploaded.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="FORM_MIME_TYPE_URLENCODED" value="application/x-www-form-urlencoded" c:type="SOUP_FORM_MIME_TYPE_URLENCODED">
      <doc xml:space="preserve">A macro containing the value
`application/x-www-form-urlencoded`; the default
MIME type for POSTing HTML form data.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="HSTSEnforcer" c:symbol-prefix="hsts_enforcer" c:type="SoupHSTSEnforcer" parent="GObject.Object" glib:type-name="SoupHSTSEnforcer" glib:get-type="soup_hsts_enforcer_get_type" glib:type-struct="HSTSEnforcerClass">
      <doc xml:space="preserve">Automatic HTTP Strict Transport Security enforcing for [class@Session].

A #SoupHSTSEnforcer stores HSTS policies and enforces them when
required. #SoupHSTSEnforcer implements [iface@SessionFeature], so you
can add an HSTS enforcer to a session with
[method@Session.add_feature] or [method@Session.add_feature_by_type].

#SoupHSTSEnforcer keeps track of all the HTTPS destinations that,
when connected to, return the Strict-Transport-Security header with
valid values. #SoupHSTSEnforcer will forget those destinations
upon expiry or when the server requests it.

When the [class@Session] the #SoupHSTSEnforcer is attached to queues or
restarts a message, the #SoupHSTSEnforcer will rewrite the URI to HTTPS if
the destination is a known HSTS host and is contacted over an insecure
transport protocol (HTTP). Users of #SoupHSTSEnforcer are advised to listen
to changes in the [property@Message:uri] property in order to be aware of
changes in the message URI.

Note that #SoupHSTSEnforcer does not support any form of long-term
HSTS policy persistence. See [class@HSTSEnforcerDB] for a persistent
enforcer.</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_hsts_enforcer_new">
        <doc xml:space="preserve">Creates a new #SoupHSTSEnforcer.

The base #SoupHSTSEnforcer class does not support persistent storage of HSTS
policies, see [class@HSTSEnforcerDB] for that.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupHSTSEnforcer</doc>
          <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
        </return-value>
      </constructor>
      <virtual-method name="changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enforcer" transfer-ownership="none">
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
          <parameter name="old_policy" transfer-ownership="none">
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </parameter>
          <parameter name="new_policy" transfer-ownership="none">
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_valid_policy" invoker="has_valid_policy">
        <doc xml:space="preserve">Gets whether @hsts_enforcer has a currently valid policy for @domain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if access to @domain should happen over HTTPS, false
  otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a domain.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_persistent" invoker="is_persistent">
        <doc xml:space="preserve">Gets whether @hsts_enforcer stores policies persistenly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hsts_enforcer storage is persistent or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_domains" c:identifier="soup_hsts_enforcer_get_domains">
        <doc xml:space="preserve">Gets a list of domains for which there are policies in @enforcer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
  list of domains. Use [func@GLib.List.free_full] and [func@GLib.free] to free the
  list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
          <parameter name="session_policies" transfer-ownership="none">
            <doc xml:space="preserve">whether to include session policies</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_policies" c:identifier="soup_hsts_enforcer_get_policies">
        <doc xml:space="preserve">Gets a list with the policies in @enforcer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly
  allocated list of policies. Use [func@GLib.List.free_full] and
  [method@HSTSPolicy.free] to free the list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="HSTSPolicy"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
          <parameter name="session_policies" transfer-ownership="none">
            <doc xml:space="preserve">whether to include session policies</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_valid_policy" c:identifier="soup_hsts_enforcer_has_valid_policy">
        <doc xml:space="preserve">Gets whether @hsts_enforcer has a currently valid policy for @domain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if access to @domain should happen over HTTPS, false
  otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a domain.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_persistent" c:identifier="soup_hsts_enforcer_is_persistent">
        <doc xml:space="preserve">Gets whether @hsts_enforcer stores policies persistenly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hsts_enforcer storage is persistent or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_policy" c:identifier="soup_hsts_enforcer_set_policy">
        <doc xml:space="preserve">Sets @policy to @hsts_enforcer.

If @policy is expired, any existing HSTS policy for its host will be removed
instead. If a policy existed for this host, it will be replaced. Otherwise,
the new policy will be inserted. If the policy is a session policy, that is,
one created with [ctor@HSTSPolicy.new_session_policy], the policy will not
expire and will be enforced during the lifetime of @hsts_enforcer's
[class@Session].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">the policy of the HSTS host</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_session_policy" c:identifier="soup_hsts_enforcer_set_session_policy">
        <doc xml:space="preserve">Sets a session policy for @domain.

A session policy is a policy that is permanent to the lifetime of
@hsts_enforcer's [class@Session] and doesn't expire.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hsts_enforcer" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
            <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">policy domain or hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="include_subdomains" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the policy applies on sub domains</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="first">
        <doc xml:space="preserve">Emitted when @hsts_enforcer changes.

If a policy has been added,
@new_policy will contain the newly-added policy and
@old_policy will be %NULL. If a policy has been deleted,
@old_policy will contain the to-be-deleted policy and
@new_policy will be %NULL. If a policy has been changed,
@old_policy will contain its old value, and @new_policy its
new value.

Note that you shouldn't modify the policies from a callback to
this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_policy" transfer-ownership="none">
            <doc xml:space="preserve">the old #SoupHSTSPolicy value</doc>
            <type name="HSTSPolicy"/>
          </parameter>
          <parameter name="new_policy" transfer-ownership="none">
            <doc xml:space="preserve">the new #SoupHSTSPolicy value</doc>
            <type name="HSTSPolicy"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="HSTSEnforcerClass" c:type="SoupHSTSEnforcerClass" glib:is-gtype-struct-for="HSTSEnforcer">
      <doc xml:space="preserve">Class structure for #SoupHSTSEnforcer.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="is_persistent">
        <callback name="is_persistent">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @hsts_enforcer storage is persistent or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="hsts_enforcer" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
              <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_valid_policy">
        <callback name="has_valid_policy">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if access to @domain should happen over HTTPS, false
  otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="hsts_enforcer" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupHSTSEnforcer</doc>
              <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
            </parameter>
            <parameter name="domain" transfer-ownership="none">
              <doc xml:space="preserve">a domain.</doc>
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enforcer" transfer-ownership="none">
              <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
            </parameter>
            <parameter name="old_policy" transfer-ownership="none">
              <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
            </parameter>
            <parameter name="new_policy" transfer-ownership="none">
              <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="HSTSEnforcerDB" c:symbol-prefix="hsts_enforcer_db" c:type="SoupHSTSEnforcerDB" parent="HSTSEnforcer" final="1" glib:type-name="SoupHSTSEnforcerDB" glib:get-type="soup_hsts_enforcer_db_get_type" glib:type-struct="HSTSEnforcerDBClass">
      <doc xml:space="preserve">Persistent HTTP Strict Transport Security enforcer.

#SoupHSTSEnforcerDB is a [class@HSTSEnforcer] that uses a SQLite
database as a backend for persistency.</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_hsts_enforcer_db_new">
        <doc xml:space="preserve">Creates a #SoupHSTSEnforcerDB.

@filename will be read in during the initialization of a
#SoupHSTSEnforcerDB, in order to create an initial set of HSTS
policies. If the file doesn't exist, a new database will be created
and initialized. Changes to the policies during the lifetime of a
#SoupHSTSEnforcerDB will be written to @filename when
[signal@HSTSEnforcer::changed] is emitted.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupHSTSEnforcer</doc>
          <type name="HSTSEnforcer" c:type="SoupHSTSEnforcer*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the filename of the database to read/write from.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="filename" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The filename of the SQLite database where HSTS policies are stored.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </class>
    <record name="HSTSEnforcerDBClass" c:type="SoupHSTSEnforcerDBClass" glib:is-gtype-struct-for="HSTSEnforcerDB">
      <field name="parent_class">
        <type name="HSTSEnforcerClass" c:type="SoupHSTSEnforcerClass"/>
      </field>
    </record>
    <record name="HSTSPolicy" c:type="SoupHSTSPolicy" glib:type-name="SoupHSTSPolicy" glib:get-type="soup_hsts_policy_get_type" c:symbol-prefix="hsts_policy">
      <doc xml:space="preserve">#SoupHSTSPolicy implements HTTP policies, as described by
[RFC 6797](http://tools.ietf.org/html/rfc6797).

@domain represents the host that this policy applies to. The domain
must be IDNA-canonicalized. [ctor@HSTSPolicy.new] and related methods
will do this for you.

@max_age contains the 'max-age' value from the Strict Transport
Security header and indicates the time to live of this policy,
in seconds.

@expires will be non-%NULL if the policy has been set by the host and
hence has an expiry time. If @expires is %NULL, it indicates that the
policy is a permanent session policy set by the user agent.

If @include_subdomains is %TRUE, the Strict Transport Security policy
must also be enforced on subdomains of @domain.</doc>
      <constructor name="new" c:identifier="soup_hsts_policy_new">
        <doc xml:space="preserve">Creates a new #SoupHSTSPolicy with the given attributes.

@domain is a domain on which the strict transport security policy
represented by this object must be enforced.

@max_age is used to set the "expires" attribute on the policy; pass
%SOUP_HSTS_POLICY_MAX_AGE_PAST for an already-expired policy, or a
lifetime in seconds.

If @include_subdomains is %TRUE, the strict transport security policy
must also be enforced on all subdomains of @domain.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupHSTSPolicy.</doc>
          <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">policy domain or hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="max_age" transfer-ownership="none">
            <doc xml:space="preserve">max age of the policy</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="include_subdomains" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the policy applies on subdomains</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_response" c:identifier="soup_hsts_policy_new_from_response">
        <doc xml:space="preserve">Parses @msg's first "Strict-Transport-Security" response header and
returns a #SoupHSTSPolicy.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupHSTSPolicy, or %NULL if no valid
  "Strict-Transport-Security" response header was found.</doc>
          <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full" c:identifier="soup_hsts_policy_new_full">
        <doc xml:space="preserve">Full version of [ctor@HSTSPolicy.new], to use with an existing
expiration date.

See [ctor@HSTSPolicy.new] for details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupHSTSPolicy.</doc>
          <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">policy domain or hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="max_age" transfer-ownership="none">
            <doc xml:space="preserve">max age of the policy</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="expires" transfer-ownership="none">
            <doc xml:space="preserve">the date of expiration of the policy or %NULL for a permanent policy</doc>
            <type name="GLib.DateTime" c:type="GDateTime*"/>
          </parameter>
          <parameter name="include_subdomains" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the policy applies on subdomains</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_session_policy" c:identifier="soup_hsts_policy_new_session_policy">
        <doc xml:space="preserve">Creates a new session #SoupHSTSPolicy with the given attributes.

A session policy is a policy that is valid during the lifetime of
the [class@HSTSEnforcer] it is added to. Contrary to regular policies,
it has no expiration date and is not stored in persistent
enforcers. These policies are useful for user-agent to load their
own or user-defined rules.

@domain is a domain on which the strict transport security policy
represented by this object must be enforced.

If @include_subdomains is %TRUE, the strict transport security policy
must also be enforced on all subdomains of @domain.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupHSTSPolicy.</doc>
          <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">policy domain or hostname</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="include_subdomains" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the policy applies on sub domains</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="soup_hsts_policy_copy">
        <doc xml:space="preserve">Copies @policy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @policy</doc>
          <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="soup_hsts_policy_equal">
        <doc xml:space="preserve">Tests if @policy1 and @policy2 are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the policies are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy1" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
          <parameter name="policy2" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_hsts_policy_free">
        <doc xml:space="preserve">Frees @policy.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="full">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_domain" c:identifier="soup_hsts_policy_get_domain">
        <doc xml:space="preserve">Gets @policy's domain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@policy's domain.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_expires" c:identifier="soup_hsts_policy_get_expires">
        <doc xml:space="preserve">Returns the expiration date for @policy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GDateTime or %NULL if unset</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_age" c:identifier="soup_hsts_policy_get_max_age">
        <doc xml:space="preserve">Returns the max age for @policy.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Max age in seconds</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="includes_subdomains" c:identifier="soup_hsts_policy_includes_subdomains">
        <doc xml:space="preserve">Gets whether @policy include its subdomains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @policy includes subdomains, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_expired" c:identifier="soup_hsts_policy_is_expired">
        <doc xml:space="preserve">Gets whether @policy is expired.

Permanent policies never expire.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @policy is expired, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_session_policy" c:identifier="soup_hsts_policy_is_session_policy">
        <doc xml:space="preserve">Gets whether @policy is a non-permanent, non-expirable session policy.

See [ctor@HSTSPolicy.new_session_policy] for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @policy is permanent, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHSTSPolicy</doc>
            <type name="HSTSPolicy" c:type="SoupHSTSPolicy*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <constant name="HSTS_POLICY_MAX_AGE_PAST" value="0" c:type="SOUP_HSTS_POLICY_MAX_AGE_PAST">
      <doc xml:space="preserve">An expiration date that is always in the past.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="HTTPVersion" glib:type-name="SoupHTTPVersion" glib:get-type="soup_http_version_get_type" c:type="SoupHTTPVersion">
      <doc xml:space="preserve">Indicates the HTTP protocol version being used.</doc>
      <member name="http_1_0" value="0" c:identifier="SOUP_HTTP_1_0" glib:nick="http-1-0" glib:name="SOUP_HTTP_1_0">
        <doc xml:space="preserve">HTTP 1.0 (RFC 1945)</doc>
      </member>
      <member name="http_1_1" value="1" c:identifier="SOUP_HTTP_1_1" glib:nick="http-1-1" glib:name="SOUP_HTTP_1_1">
        <doc xml:space="preserve">HTTP 1.1 (RFC 2616)</doc>
      </member>
      <member name="http_2_0" value="2" c:identifier="SOUP_HTTP_2_0" glib:nick="http-2-0" glib:name="SOUP_HTTP_2_0">
        <doc xml:space="preserve">HTTP 2.0 (RFC 7540)</doc>
      </member>
    </enumeration>
    <constant name="HTTP_URI_FLAGS" value="482" c:type="SOUP_HTTP_URI_FLAGS">
      <doc xml:space="preserve">The set of #GUriFlags libsoup expects all #GUri to use.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Logger" c:symbol-prefix="logger" c:type="SoupLogger" parent="GObject.Object" final="1" glib:type-name="SoupLogger" glib:get-type="soup_logger_get_type" glib:type-struct="LoggerClass">
      <doc xml:space="preserve">Debug logging support

#SoupLogger watches a [class@Session] and logs the HTTP traffic that
it generates, for debugging purposes. Many applications use an
environment variable to determine whether or not to use
#SoupLogger, and to determine the amount of debugging output.

To use #SoupLogger, first create a logger with [ctor@Logger.new], optionally
configure it with [method@Logger.set_request_filter],
[method@Logger.set_response_filter], and [method@Logger.set_printer], and
then attach it to a session (or multiple sessions) with
[method@Session.add_feature].

By default, the debugging output is sent to `stdout`, and looks something
like:

```
&gt; POST /unauth HTTP/1.1
&gt; Soup-Debug-Timestamp: 1200171744
&gt; Soup-Debug: SoupSession 1 (0x612190), SoupMessage 1 (0x617000), GSocket 1 (0x612220)
&gt; Host: localhost
&gt; Content-Type: text/plain
&gt; Connection: close

&amp;lt; HTTP/1.1 201 Created
&amp;lt; Soup-Debug-Timestamp: 1200171744
&amp;lt; Soup-Debug: SoupMessage 1 (0x617000)
&amp;lt; Date: Sun, 12 Jan 2008 21:02:24 GMT
&amp;lt; Content-Length: 0
```

The `Soup-Debug-Timestamp` line gives the time (as a `time_t`) when the
request was sent, or the response fully received.

The `Soup-Debug` line gives further debugging information about the
[class@Session], [class@Message], and [class@Gio.Socket] involved; the hex
numbers are the addresses of the objects in question (which may be useful if
you are running in a debugger). The decimal IDs are simply counters that
uniquely identify objects across the lifetime of the #SoupLogger. In
particular, this can be used to identify when multiple messages are sent
across the same connection.

Currently, the request half of the message is logged just before
the first byte of the request gets written to the network (from the
[signal@Message::starting] signal).

The response is logged just after the last byte of the response body is read
from the network (from the [signal@Message::got-body] or
[signal@Message::got-informational] signal), which means that the
[signal@Message::got-headers] signal, and anything triggered off it (such as
#SoupMessage::authenticate) will be emitted *before* the response headers are
actually logged.

If the response doesn't happen to trigger the [signal@Message::got-body] nor
[signal@Message::got-informational] signals due to, for example, a
cancellation before receiving the last byte of the response body, the
response will still be logged on the event of the [signal@Message::finished]
signal.</doc>
      <implements name="SessionFeature"/>
      <constructor name="new" c:identifier="soup_logger_new">
        <doc xml:space="preserve">Creates a new #SoupLogger with the given debug level.

If you need finer control over what message parts are and aren't
logged, use [method@Logger.set_request_filter] and
[method@Logger.set_response_filter].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupLogger</doc>
          <type name="Logger" c:type="SoupLogger*"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the debug level</doc>
            <type name="LoggerLogLevel" c:type="SoupLoggerLogLevel"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_max_body_size" c:identifier="soup_logger_get_max_body_size" glib:get-property="max-body-size">
        <attribute name="org.gtk.Method.get_property" value="max-body-size"/>
        <doc xml:space="preserve">Get the maximum body size for @logger.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum body size, or -1 if unlimited</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_max_body_size" c:identifier="soup_logger_set_max_body_size" glib:set-property="max-body-size">
        <attribute name="org.gtk.Method.set_property" value="max-body-size"/>
        <doc xml:space="preserve">Sets the maximum body size for @logger (-1 means no limit).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="max_body_size" transfer-ownership="none">
            <doc xml:space="preserve">the maximum body size to log</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_printer" c:identifier="soup_logger_set_printer">
        <doc xml:space="preserve">Sets up an alternate log printing routine, if you don't want
the log to go to `stdout`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="printer" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the callback for printing logging output</doc>
            <type name="LoggerPrinter" c:type="SoupLoggerPrinter"/>
          </parameter>
          <parameter name="printer_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify to free @printer_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_request_filter" c:identifier="soup_logger_set_request_filter">
        <doc xml:space="preserve">Sets up a filter to determine the log level for a given request.

For each HTTP request @logger will invoke @request_filter to
determine how much (if any) of that request to log. (If you do not
set a request filter, @logger will just always log requests at the
level passed to [ctor@Logger.new].)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="request_filter" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the callback for request debugging</doc>
            <type name="LoggerFilter" c:type="SoupLoggerFilter"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify to free @filter_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_response_filter" c:identifier="soup_logger_set_response_filter">
        <doc xml:space="preserve">Sets up a filter to determine the log level for a given response.

For each HTTP response @logger will invoke @response_filter to
determine how much (if any) of that response to log. (If you do not
set a response filter, @logger will just always log responses at
the level passed to [ctor@Logger.new].)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="logger" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupLogger</doc>
            <type name="Logger" c:type="SoupLogger*"/>
          </instance-parameter>
          <parameter name="response_filter" transfer-ownership="none" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">the callback for response debugging</doc>
            <type name="LoggerFilter" c:type="SoupLoggerFilter"/>
          </parameter>
          <parameter name="filter_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify to free @filter_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <property name="level" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The level of logging output.</doc>
        <type name="LoggerLogLevel"/>
      </property>
      <property name="max-body-size" writable="1" construct="1" transfer-ownership="none" setter="set_max_body_size" getter="get_max_body_size">
        <attribute name="org.gtk.Property.get" value="soup_logger_get_max_body_size"/>
        <attribute name="org.gtk.Property.set" value="soup_logger_set_max_body_size"/>
        <doc xml:space="preserve">If [property@Logger:level] is %SOUP_LOGGER_LOG_BODY, this gives
the maximum number of bytes of the body that will be logged.
(-1 means "no limit".)</doc>
        <type name="gint" c:type="gint"/>
      </property>
    </class>
    <record name="LoggerClass" c:type="SoupLoggerClass" glib:is-gtype-struct-for="Logger">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <callback name="LoggerFilter" c:type="SoupLoggerFilter">
      <doc xml:space="preserve">The prototype for a logging filter.

The filter callback will be invoked for each request or response, and should
analyze it and return a [enum@LoggerLogLevel] value indicating how much of
the message to log.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a [enum@LoggerLogLevel] value indicating how much of the message to
  log</doc>
        <type name="LoggerLogLevel" c:type="SoupLoggerLogLevel"/>
      </return-value>
      <parameters>
        <parameter name="logger" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupLogger</doc>
          <type name="Logger" c:type="SoupLogger*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being logged</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">the data passed to [method@Logger.set_request_filter]
  or [method@Logger.set_response_filter]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="LoggerLogLevel" glib:type-name="SoupLoggerLogLevel" glib:get-type="soup_logger_log_level_get_type" c:type="SoupLoggerLogLevel">
      <doc xml:space="preserve">Describes the level of logging output to provide.</doc>
      <member name="none" value="0" c:identifier="SOUP_LOGGER_LOG_NONE" glib:nick="none" glib:name="SOUP_LOGGER_LOG_NONE">
        <doc xml:space="preserve">No logging</doc>
      </member>
      <member name="minimal" value="1" c:identifier="SOUP_LOGGER_LOG_MINIMAL" glib:nick="minimal" glib:name="SOUP_LOGGER_LOG_MINIMAL">
        <doc xml:space="preserve">Log the Request-Line or Status-Line and
  the Soup-Debug pseudo-headers</doc>
      </member>
      <member name="headers" value="2" c:identifier="SOUP_LOGGER_LOG_HEADERS" glib:nick="headers" glib:name="SOUP_LOGGER_LOG_HEADERS">
        <doc xml:space="preserve">Log the full request/response headers</doc>
      </member>
      <member name="body" value="3" c:identifier="SOUP_LOGGER_LOG_BODY" glib:nick="body" glib:name="SOUP_LOGGER_LOG_BODY">
        <doc xml:space="preserve">Log the full headers and request/response bodies</doc>
      </member>
    </enumeration>
    <callback name="LoggerPrinter" c:type="SoupLoggerPrinter">
      <doc xml:space="preserve">The prototype for a custom printing callback.

@level indicates what kind of information is being printed. Eg, it
will be %SOUP_LOGGER_LOG_HEADERS if @data is header data.

@direction is either '&lt;', '&gt;', or ' ', and @data is the single line
to print; the printer is expected to add a terminating newline.

To get the effect of the default printer, you would do:

```c
printf ("%c %s\n", direction, data);
```</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="logger" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupLogger</doc>
          <type name="Logger" c:type="SoupLogger*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:space="preserve">the level of the information being printed.</doc>
          <type name="LoggerLogLevel" c:type="SoupLoggerLogLevel"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">a single-character prefix to @data</doc>
          <type name="gchar" c:type="char"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">data to print</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
          <doc xml:space="preserve">the data passed to [method@Logger.set_printer]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="MAJOR_VERSION" value="3" c:type="SOUP_MAJOR_VERSION">
      <doc xml:space="preserve">Like [func@get_major_version], but from the headers used at application
compile time, rather than from the library linked against at application run
time.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="0" c:type="SOUP_MICRO_VERSION">
      <doc xml:space="preserve">Like [func@get_micro_version], but from the headers used at
application compile time, rather than from the library linked
against at application run time.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="3" c:type="SOUP_MINOR_VERSION">
      <doc xml:space="preserve">Like [func@get_minor_version], but from the headers used at
application compile time, rather than from the library linked
against at application run time.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="MemoryUse" glib:type-name="SoupMemoryUse" glib:get-type="soup_memory_use_get_type" c:type="SoupMemoryUse">
      <doc xml:space="preserve">The lifetime of the memory being passed.</doc>
      <member name="static" value="0" c:identifier="SOUP_MEMORY_STATIC" glib:nick="static" glib:name="SOUP_MEMORY_STATIC">
        <doc xml:space="preserve">The memory is statically allocated and
  constant; libsoup can use the passed-in buffer directly and not
  need to worry about it being modified or freed.</doc>
      </member>
      <member name="take" value="1" c:identifier="SOUP_MEMORY_TAKE" glib:nick="take" glib:name="SOUP_MEMORY_TAKE">
        <doc xml:space="preserve">The caller has allocated the memory and libsoup
  will assume ownership of it and free it with [func@GLib.free].</doc>
      </member>
      <member name="copy" value="2" c:identifier="SOUP_MEMORY_COPY" glib:nick="copy" glib:name="SOUP_MEMORY_COPY">
        <doc xml:space="preserve">The passed-in data belongs to the caller and
  libsoup will copy it into new memory leaving the caller free
  to reuse the original memory.</doc>
      </member>
    </enumeration>
    <class name="Message" c:symbol-prefix="message" c:type="SoupMessage" parent="GObject.Object" final="1" glib:type-name="SoupMessage" glib:get-type="soup_message_get_type" glib:type-struct="MessageClass">
      <doc xml:space="preserve">Represents an HTTP message being sent or received.

A #SoupMessage represents an HTTP message that is being sent or
received.

You would create a #SoupMessage with [ctor@Message.new] or
[ctor@Message.new_from_uri], set up its fields appropriately, and send it.

[property@Message:status-code] will normally be a [enum@Status] value, eg,
%SOUP_STATUS_OK, though of course it might actually be an unknown status
code. [property@Message:reason-phrase] is the actual text returned from the
server, which may or may not correspond to the "standard" description of
@status_code. At any rate, it is almost certainly not localized, and not very
descriptive even if it is in the user's language; you should not use
[property@Message:reason-phrase] in user-visible messages. Rather, you should
look at [property@Message:status-code], and determine an end-user-appropriate
message based on that and on what you were trying to do.

Note that libsoup's terminology here does not quite match the HTTP
specification: in RFC 2616, an "HTTP-message" is *either* a Request, *or* a
Response. In libsoup, a #SoupMessage combines both the request and the
response.</doc>
      <constructor name="new" c:identifier="soup_message_new">
        <doc xml:space="preserve">Creates a new empty #SoupMessage, which will connect to @uri.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupMessage (or %NULL if @uri
  could not be parsed).</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the HTTP method for the created request</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">the destination endpoint (as a string)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_encoded_form" c:identifier="soup_message_new_from_encoded_form">
        <doc xml:space="preserve">Creates a new #SoupMessage and sets it up to send the given @encoded_form
to @uri via @method. If @method is "GET", it will include the form data
into @uri's query field, and if @method is "POST" or "PUT", it will be set as
request body.

This function takes the ownership of @encoded_form, that will be released
with [func@GLib.free] when no longer in use. See also [func@form_encode],
[func@form_encode_hash] and [func@form_encode_datalist].</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupMessage, or %NULL if
  @uri_string could not be parsed or @method is not "GET, "POST" or "PUT"</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the HTTP method for the created request (GET, POST or PUT)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">the destination endpoint (as a string)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="encoded_form" transfer-ownership="full">
            <doc xml:space="preserve">a encoded form</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_multipart" c:identifier="soup_message_new_from_multipart">
        <doc xml:space="preserve">Creates a new #SoupMessage and sets it up to send @multipart to
@uri_string via POST.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the new #SoupMessage, or %NULL if @uri_string
  could not be parsed</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <parameter name="uri_string" transfer-ownership="none">
            <doc xml:space="preserve">the destination endpoint</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_uri" c:identifier="soup_message_new_from_uri">
        <doc xml:space="preserve">Creates a new empty #SoupMessage, which will connect to @uri.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the HTTP method for the created request</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the destination endpoint</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_options_ping" c:identifier="soup_message_new_options_ping">
        <doc xml:space="preserve">Creates a new #SoupMessage to send `OPTIONS *` to a server. The path of
@base_uri will be ignored.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <parameter name="base_uri" transfer-ownership="none">
            <doc xml:space="preserve">the destination endpoint</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_flags" c:identifier="soup_message_add_flags">
        <doc xml:space="preserve">Adds @flags to the set of @msg's flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #SoupMessageFlags values</doc>
            <type name="MessageFlags" c:type="SoupMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_header_handler" c:identifier="soup_message_add_header_handler" introspectable="0">
        <doc xml:space="preserve">Adds a signal handler to @msg for @signal.

Similar to [func@GObject.signal_connect], but the @callback will only be run
if @msg's incoming messages headers (that is, the `request_headers`) contain
a header named @header.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the handler ID from [func@GObject.signal_connect]</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="signal" transfer-ownership="none">
            <doc xml:space="preserve">signal to connect the handler to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="header" transfer-ownership="none">
            <doc xml:space="preserve">HTTP response header to match against</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">the header handler</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @handler_cb</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_status_code_handler" c:identifier="soup_message_add_status_code_handler" introspectable="0">
        <doc xml:space="preserve">Adds a signal handler to @msg for @signal.

Similar to [func@GObject.signal_connect], but the @callback will only be run
if @msg has the status @status_code.

@signal must be a signal that will be emitted after @msg's status
is set (this means it can't be a "wrote" signal).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the handler ID from [func@GObject.signal_connect]</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="signal" transfer-ownership="none">
            <doc xml:space="preserve">signal to connect the handler to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">status code to match against</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">the header handler</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @handler_cb</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="disable_feature" c:identifier="soup_message_disable_feature">
        <doc xml:space="preserve">Disables the actions of [iface@SessionFeature]s with the
given @feature_type (or a subclass of that type) on @msg.

@msg is processed as though the feature(s) hadn't been added to the
session. Eg, passing #SOUP_TYPE_CONTENT_SNIFFER for @feature_type
will disable Content-Type sniffing on the message.

You must call this before queueing @msg on a session; calling it on
a message that has already been queued is undefined. In particular,
you cannot call this on a message that is being requeued after a
redirect or authentication.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a #SoupSessionFeature</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_id" c:identifier="soup_message_get_connection_id">
        <doc xml:space="preserve">Returns the unique idenfier for the last connection used.

This may be 0 if it was a cached resource or it has not gotten
a connection yet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An id or 0 if no connection.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_first_party" c:identifier="soup_message_get_first_party" glib:get-property="first-party">
        <attribute name="org.gtk.Method.get_property" value="first-party"/>
        <doc xml:space="preserve">Gets @msg's first-party [struct@GLib.Uri].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @msg's first party #GUri</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="soup_message_get_flags" glib:get-property="flags">
        <attribute name="org.gtk.Method.get_property" value="flags"/>
        <doc xml:space="preserve">Gets the flags on @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags</doc>
          <type name="MessageFlags" c:type="SoupMessageFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_http_version" c:identifier="soup_message_get_http_version" glib:get-property="http-version">
        <attribute name="org.gtk.Method.get_property" value="http-version"/>
        <doc xml:space="preserve">Gets the HTTP version of @msg.

This is the minimum of the version from the request and the version from the
response.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the HTTP version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_options_ping" c:identifier="soup_message_get_is_options_ping" glib:get-property="is-options-ping">
        <doc xml:space="preserve">Gets whether @msg is intended to be used to send `OPTIONS *` to a server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message is options ping, or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_top_level_navigation" c:identifier="soup_message_get_is_top_level_navigation" glib:get-property="is-top-level-navigation">
        <attribute name="org.gtk.Method.get_property" value="is-top-level-navigation"/>
        <doc xml:space="preserve">Returns if this message is set as a top level navigation.

Used for same-site policy checks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the current request is a top-level navitation</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method" c:identifier="soup_message_get_method" glib:get-property="method">
        <attribute name="org.gtk.Method.get_property" value="method"/>
        <doc xml:space="preserve">Returns the method of this message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A method such as %SOUP_METHOD_GET</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_metrics" c:identifier="soup_message_get_metrics">
        <doc xml:space="preserve">Get the [struct@MessageMetrics] of @msg.

If the flag %SOUP_MESSAGE_COLLECT_METRICS is not enabled for @msg this will
return %NULL.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupMessageMetrics</doc>
          <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority" c:identifier="soup_message_get_priority" glib:get-property="priority">
        <doc xml:space="preserve">Retrieves the [enum@MessagePriority].

If not set this value defaults to #SOUP_MESSAGE_PRIORITY_NORMAL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the priority of the message.</doc>
          <type name="MessagePriority" c:type="SoupMessagePriority"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_reason_phrase" c:identifier="soup_message_get_reason_phrase" glib:get-property="reason-phrase">
        <attribute name="org.gtk.Method.get_property" value="reason-phrase"/>
        <doc xml:space="preserve">Returns the reason phrase for the status of this message.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the phrase</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_address" c:identifier="soup_message_get_remote_address" glib:get-property="remote-address">
        <doc xml:space="preserve">Get the remote [class@Gio.SocketAddress] of the connection associated with
the message.

The returned address can be %NULL if the connection hasn't been established
yet, or the resource was loaded from the disk cache. In case of proxy
connections, the remote address returned is a [class@Gio.ProxyAddress]. If
[property@Session:remote-connectable] is set the returned address id for the
connection to the session's remote connectable.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GSocketAddress or %NULL if the connection
    hasn't been established</doc>
          <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_headers" c:identifier="soup_message_get_request_headers" glib:get-property="request-headers">
        <attribute name="org.gtk.Method.get_property" value="request-headers"/>
        <doc xml:space="preserve">Returns the headers sent with the request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #SoupMessageHeaders</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_headers" c:identifier="soup_message_get_response_headers" glib:get-property="response-headers">
        <attribute name="org.gtk.Method.get_property" value="response-headers"/>
        <doc xml:space="preserve">Returns the headers recieved with the response.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #SoupMessageHeaders</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_site_for_cookies" c:identifier="soup_message_get_site_for_cookies" glib:get-property="site-for-cookies">
        <attribute name="org.gtk.Method.get_property" value="site-for-cookies"/>
        <doc xml:space="preserve">Gets @msg's site for cookies #GUri.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @msg's site for cookies #GUri</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status" c:identifier="soup_message_get_status">
        <doc xml:space="preserve">Returns the set status of this message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #SoupStatus</doc>
          <type name="Status" c:type="SoupStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">The #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_ciphersuite_name" c:identifier="soup_message_get_tls_ciphersuite_name" glib:get-property="tls-ciphersuite-name">
        <doc xml:space="preserve">Gets the name of the TLS ciphersuite negotiated for @msg's connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the TLS ciphersuite,
  or %NULL if @msg's connection is not SSL.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_peer_certificate" c:identifier="soup_message_get_tls_peer_certificate" glib:get-property="tls-peer-certificate">
        <doc xml:space="preserve">Gets the peer's [class@Gio.TlsCertificate] associated with @msg's connection.

Note that this is not set yet during the emission of
[signal@Message::accept-certificate] signal.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@msg's TLS peer certificate,
  or %NULL if @msg's connection is not SSL.</doc>
          <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_peer_certificate_errors" c:identifier="soup_message_get_tls_peer_certificate_errors" glib:get-property="tls-peer-certificate-errors">
        <doc xml:space="preserve">Gets the errors associated with validating @msg's TLS peer certificate.
Note that this is not set yet during the emission of
[signal@Message::accept-certificate] signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GTlsCertificateFlags with @msg's TLS peer certificate errors.</doc>
          <type name="Gio.TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_protocol_version" c:identifier="soup_message_get_tls_protocol_version" glib:get-property="tls-protocol-version">
        <doc xml:space="preserve">Gets the TLS protocol version negotiated for @msg's connection.

If the message connection is not SSL, %G_TLS_PROTOCOL_VERSION_UNKNOWN is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GTlsProtocolVersion</doc>
          <type name="Gio.TlsProtocolVersion" c:type="GTlsProtocolVersion"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri" c:identifier="soup_message_get_uri" glib:get-property="uri">
        <attribute name="org.gtk.Method.get_property" value="method"/>
        <doc xml:space="preserve">Gets @msg's URI.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI @msg is targeted for.</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_feature_disabled" c:identifier="soup_message_is_feature_disabled">
        <doc xml:space="preserve">Get whether [iface@SessionFeature]s of the given @feature_type
(or a subclass of that type) are disabled on @msg.

See [method@Message.disable_feature].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if feature is disabled, or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of a #SoupSessionFeature</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_keepalive" c:identifier="soup_message_is_keepalive">
        <doc xml:space="preserve">Determines whether or not @msg's connection can be kept alive for
further requests after processing @msg.

The result is based on the HTTP version, Connection header, etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_flags" c:identifier="soup_message_query_flags">
        <doc xml:space="preserve">Queries if @flags are present in the set of @msg's flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @flags are enabled in @msg</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #SoupMessageFlags values</doc>
            <type name="MessageFlags" c:type="SoupMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_flags" c:identifier="soup_message_remove_flags">
        <doc xml:space="preserve">Removes @flags from the set of @msg's flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #SoupMessageFlags values</doc>
            <type name="MessageFlags" c:type="SoupMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_first_party" c:identifier="soup_message_set_first_party" glib:set-property="first-party">
        <attribute name="org.gtk.Method.set_property" value="first-party"/>
        <doc xml:space="preserve">Sets @first_party as the main document #GUri for @msg.

For details of when and how this is used refer to the documentation for
[enum@CookieJarAcceptPolicy].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="first_party" transfer-ownership="none">
            <doc xml:space="preserve">the #GUri for the @msg's first party</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="soup_message_set_flags" glib:set-property="flags">
        <attribute name="org.gtk.Method.set_property" value="flags"/>
        <doc xml:space="preserve">Sets the specified flags on @msg.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #SoupMessageFlags values</doc>
            <type name="MessageFlags" c:type="SoupMessageFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_options_ping" c:identifier="soup_message_set_is_options_ping" glib:set-property="is-options-ping">
        <doc xml:space="preserve">Set whether @msg is intended to be used to send `OPTIONS *` to a server.

When set to %TRUE, the path of [property@Message:uri] will be ignored and
[property@Message:method] set to %SOUP_METHOD_OPTIONS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="is_options_ping" transfer-ownership="none">
            <doc xml:space="preserve">the value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_is_top_level_navigation" c:identifier="soup_message_set_is_top_level_navigation" glib:set-property="is-top-level-navigation">
        <attribute name="org.gtk.Method.set_property" value="is-top-level-navigation"/>
        <doc xml:space="preserve">Sets whether the current request is a top-level navitation.

See the [same-site spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00)
for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="is_top_level_navigation" transfer-ownership="none">
            <doc xml:space="preserve">if %TRUE indicate the current request is a top-level navigation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_method" c:identifier="soup_message_set_method" glib:set-property="method">
        <attribute name="org.gtk.Method.set_property" value="method"/>
        <doc xml:space="preserve">Set @msg's HTTP method to @method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the value to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority" c:identifier="soup_message_set_priority" glib:set-property="priority">
        <doc xml:space="preserve">Sets the priority of a message.

Note that this won't have any effect unless used before the message is added
to the session's message processing queue.

The message will be placed just before any other previously added
message with lower priority (messages with the same priority are
processed on a FIFO basis).

Setting priorities does not currently work with synchronous messages
because in the synchronous/blocking case, priority ends up being determined
semi-randomly by thread scheduling.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessagePriority</doc>
            <type name="MessagePriority" c:type="SoupMessagePriority"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_request_body" c:identifier="soup_message_set_request_body">
        <doc xml:space="preserve">Set the request body of a #SoupMessage.

If @content_type is %NULL and @stream is not %NULL the Content-Type header will
not be changed if present.
The request body needs to be set again in case @msg is restarted
(in case of redirection or authentication).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">MIME Content-Type of the body, or %NULL if unknown</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="stream" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GInputStream to read the request body from</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="content_length" transfer-ownership="none">
            <doc xml:space="preserve">the byte length of @stream or -1 if unknown</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_request_body_from_bytes" c:identifier="soup_message_set_request_body_from_bytes">
        <doc xml:space="preserve">Set the request body of a #SoupMessage from [struct@GLib.Bytes].

If @content_type is %NULL and @bytes is not %NULL the Content-Type header will
not be changed if present.
The request body needs to be set again in case @msg is restarted
(in case of redirection or authentication).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">MIME Content-Type of the body, or %NULL if unknown</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GBytes with the request body data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_site_for_cookies" c:identifier="soup_message_set_site_for_cookies" glib:set-property="site-for-cookies">
        <attribute name="org.gtk.Method.set_property" value="site-for-cookies"/>
        <doc xml:space="preserve">Sets @site_for_cookies as the policy URL for same-site cookies for @msg.

It is either the URL of the top-level document or %NULL depending on whether
the registrable domain of this document's URL matches the registrable domain
of its parent's/opener's URL. For the top-level document it is set to the
document's URL.

See the [same-site spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00)
for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="site_for_cookies" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GUri for the @msg's site for cookies</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls_client_certificate" c:identifier="soup_message_set_tls_client_certificate">
        <doc xml:space="preserve">Sets the @certificate to be used by @msg's connection when a
client certificate is requested during the TLS handshake.

You can call this as a response to [signal@Message::request-certificate]
signal, or before the connection is started. If @certificate is %NULL
the handshake will continue without providing a GTlsCertificate.
Note that the [class@Gio.TlsCertificate] set by this function will be ignored if
[property@Session:tls-interaction] is not %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the #GTlsCertificate to set, or %NULL</doc>
            <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri" c:identifier="soup_message_set_uri" glib:set-property="uri">
        <attribute name="org.gtk.Method.set_property" value="method"/>
        <doc xml:space="preserve">Sets @msg's URI to @uri.

If @msg has already been sent and you want to re-send it with the new URI,
you need to send it again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the new #GUri</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
        </parameters>
      </method>
      <method name="tls_client_certificate_password_request_complete" c:identifier="soup_message_tls_client_certificate_password_request_complete">
        <doc xml:space="preserve">Completes a certificate password request.

You must call this as a response to
[signal@Message::request-certificate-password] signal, to notify @msg that
the [class@Gio.TlsPassword] has already been updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="first-party" writable="1" transfer-ownership="none" setter="set_first_party" getter="get_first_party">
        <attribute name="org.gtk.Property.get" value="soup_message_get_first_party"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_first_party"/>
        <doc xml:space="preserve">The [struct@GLib.Uri] loaded in the application when the message was
queued.</doc>
        <type name="GLib.Uri"/>
      </property>
      <property name="flags" writable="1" transfer-ownership="none" setter="set_flags" getter="get_flags">
        <attribute name="org.gtk.Property.get" value="soup_message_get_flags"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_flags"/>
        <doc xml:space="preserve">Various message options.</doc>
        <type name="MessageFlags"/>
      </property>
      <property name="http-version" transfer-ownership="none" getter="get_http_version">
        <attribute name="org.gtk.Property.get" value="soup_message_get_http_version"/>
        <doc xml:space="preserve">The HTTP protocol version to use.</doc>
        <type name="HTTPVersion"/>
      </property>
      <property name="is-options-ping" writable="1" transfer-ownership="none" setter="set_is_options_ping" getter="get_is_options_ping">
        <attribute name="org.gtk.Property.get" value="soup_message_get_is_options_ping"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_is_options_ping"/>
        <doc xml:space="preserve">Whether the message is an OPTIONS ping.

The #SoupMessage is intended to be used to send
`OPTIONS *` to a server. When set to %TRUE, the
path of [property@Message:uri] will be ignored and
[property@Message:method] set to %SOUP_METHOD_OPTIONS.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="is-top-level-navigation" writable="1" transfer-ownership="none" setter="set_is_top_level_navigation" getter="get_is_top_level_navigation">
        <attribute name="org.gtk.Property.get" value="soup_message_get_is_top_level_navigation"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_is_top_level_navigation"/>
        <doc xml:space="preserve">Set when the message is navigating between top level domains.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="method" writable="1" transfer-ownership="none" setter="set_method" getter="get_method">
        <attribute name="org.gtk.Property.get" value="soup_message_get_method"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_method"/>
        <doc xml:space="preserve">The message's HTTP method.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="priority" writable="1" transfer-ownership="none" setter="set_priority" getter="get_priority">
        <attribute name="org.gtk.Property.get" value="soup_message_get_priority"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_priority"/>
        <doc xml:space="preserve">Sets the priority of the #SoupMessage. See
[method@Message.set_priority] for further details.</doc>
        <type name="MessagePriority"/>
      </property>
      <property name="reason-phrase" transfer-ownership="none" getter="get_reason_phrase">
        <attribute name="org.gtk.Property.get" value="soup_message_get_reason_phrase"/>
        <doc xml:space="preserve">The HTTP response reason phrase.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="remote-address" transfer-ownership="none" getter="get_remote_address">
        <attribute name="org.gtk.Property.get" value="soup_message_get_remote_address"/>
        <doc xml:space="preserve">The remote [class@Gio.SocketAddress] of the connection associated
with the message.</doc>
        <type name="Gio.SocketAddress"/>
      </property>
      <property name="request-headers" transfer-ownership="none" getter="get_request_headers">
        <attribute name="org.gtk.Property.get" value="soup_message_get_request_headers"/>
        <doc xml:space="preserve">The HTTP request headers.</doc>
        <type name="MessageHeaders"/>
      </property>
      <property name="response-headers" transfer-ownership="none" getter="get_response_headers">
        <attribute name="org.gtk.Property.get" value="soup_message_get_response_headers"/>
        <doc xml:space="preserve">The HTTP response headers.</doc>
        <type name="MessageHeaders"/>
      </property>
      <property name="site-for-cookies" writable="1" transfer-ownership="none" setter="set_site_for_cookies" getter="get_site_for_cookies">
        <attribute name="org.gtk.Property.get" value="soup_message_get_site_for_cookies"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_site_for_cookies"/>
        <doc xml:space="preserve">Site used to compare cookies against. Used for SameSite cookie support.</doc>
        <type name="GLib.Uri"/>
      </property>
      <property name="status-code" transfer-ownership="none">
        <doc xml:space="preserve">The HTTP response status code.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tls-ciphersuite-name" transfer-ownership="none" getter="get_tls_ciphersuite_name">
        <attribute name="org.gtk.Property.get" value="soup_message_get_tls_ciphersuite_name"/>
        <doc xml:space="preserve">The Name of TLS ciphersuite negotiated for this message connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="tls-peer-certificate" transfer-ownership="none" getter="get_tls_peer_certificate">
        <attribute name="org.gtk.Property.get" value="soup_message_get_tls_peer_certificate"/>
        <doc xml:space="preserve">The peer's [class@Gio.TlsCertificate] associated with the message.</doc>
        <type name="Gio.TlsCertificate"/>
      </property>
      <property name="tls-peer-certificate-errors" transfer-ownership="none" getter="get_tls_peer_certificate_errors">
        <attribute name="org.gtk.Property.get" value="soup_message_get_tls_peer_certificate_errors"/>
        <doc xml:space="preserve">The verification errors on [property@Message:tls-peer-certificate].</doc>
        <type name="Gio.TlsCertificateFlags"/>
      </property>
      <property name="tls-protocol-version" transfer-ownership="none" getter="get_tls_protocol_version">
        <attribute name="org.gtk.Property.get" value="soup_message_get_tls_protocol_version"/>
        <doc xml:space="preserve">The TLS protocol version negotiated for the message connection.</doc>
        <type name="Gio.TlsProtocolVersion"/>
      </property>
      <property name="uri" writable="1" transfer-ownership="none" setter="set_uri" getter="get_uri">
        <attribute name="org.gtk.Property.get" value="soup_message_get_uri"/>
        <attribute name="org.gtk.Property.set" value="soup_message_set_uri"/>
        <doc xml:space="preserve">The message's Request-URI.</doc>
        <type name="GLib.Uri"/>
      </property>
      <glib:signal name="accept-certificate" when="last">
        <doc xml:space="preserve">Emitted during the @msg's connection TLS handshake
after an unacceptable TLS certificate has been received.

You can return %TRUE to accept @tls_certificate despite
@tls_errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to accept the TLS certificate and stop other
  handlers from being invoked, or %FALSE to propagate the
  event further.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tls_peer_certificate" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="Gio.TlsCertificate"/>
          </parameter>
          <parameter name="tls_peer_errors" transfer-ownership="none">
            <doc xml:space="preserve">the tls errors of @tls_certificate</doc>
            <type name="Gio.TlsCertificateFlags"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="authenticate" when="last">
        <doc xml:space="preserve">Emitted when the message requires authentication.

If credentials are available call [method@Auth.authenticate] on
@auth. If these credentials fail, the signal will be emitted again,
with @retrying set to %TRUE, which will continue until you return
without calling [method@Auth.authenticate] on @auth.

Note that this may be emitted before @msg's body has been
fully read.

You can authenticate @auth asynchronously by calling
[method@GObject.Object.ref] on @auth and returning %TRUE. The operation will
complete once either [method@Auth.authenticate] or
[method@Auth.cancel] are called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to stop other handlers from being invoked
  or %FALSE to propagate the event further.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="auth" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupAuth to authenticate</doc>
            <type name="Auth"/>
          </parameter>
          <parameter name="retrying" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if this is the second (or later) attempt</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="content-sniffed" when="first">
        <doc xml:space="preserve">This signal is emitted after [signal@Message::got-headers].

If content sniffing is disabled, or no content sniffing will be
performed, due to the sniffer deciding to trust the
Content-Type sent by the server, this signal is emitted
immediately after [signal@Message::got-headers], and @type is
%NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the content type that we got from sniffing</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable with the parameters</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="finished" when="first">
        <doc xml:space="preserve">Emitted when all HTTP processing is finished for a message.

(After [signal@Message::got_body]).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-body" when="first">
        <doc xml:space="preserve">Emitted after receiving the complete message response body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-headers" when="first">
        <doc xml:space="preserve">Emitted after receiving the Status-Line and response headers.

See also [method@Message.add_header_handler] and
[method@Message.add_status_code_handler], which can be used to
connect to a subset of emissions of this signal.

If you cancel or requeue @msg while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and @msg's connection will be closed.
(If you need to requeue a message--eg, after handling
authentication or redirection--it is usually better to
requeue it from a [signal@Message::got-body] handler rather
than a [signal@Message::got_headers] handler, so that the
existing HTTP connection can be reused.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-informational" when="first">
        <doc xml:space="preserve">Emitted after receiving a 1xx (Informational) response for
a (client-side) message.

The response_headers will be filled in with the headers associated
with the informational response; however, those header values will be
erased after this signal is done.

If you cancel or requeue @msg while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and @msg's connection will be closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="hsts-enforced" when="last">
        <doc xml:space="preserve">Emitted when [class@HSTSEnforcer] has upgraded the protocol
for @msg to HTTPS as a result of matching its domain with
a HSTS policy.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="network-event" when="first">
        <doc xml:space="preserve">Emitted to indicate that some network-related event
related to @msg has occurred.

This essentially proxies the [signal@Gio.SocketClient::event] signal,
but only for events that occur while @msg "owns" the connection; if
@msg is sent on an existing persistent connection, then this signal
will not be emitted. (If you want to force the message to be sent on
a new connection, set the %SOUP_MESSAGE_NEW_CONNECTION flag on it.)

See [signal@Gio.SocketClient::event] for more information on what
the different values of @event correspond to, and what
@connection will be in each case.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">the network event</doc>
            <type name="Gio.SocketClientEvent"/>
          </parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the current state of the network connection</doc>
            <type name="Gio.IOStream"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-certificate" when="last">
        <doc xml:space="preserve">Emitted during the @msg's connection TLS handshake when
@tls_connection requests a certificate from the client.

You can set the client certificate by calling
[method@Message.set_tls_client_certificate] and returning %TRUE. It's
possible to handle the request asynchornously by returning %TRUE and
call [method@Message.set_tls_client_certificate] later once the
certificate is available. Note that this signal is not emitted if
[property@Session:tls-interaction] was set, or if
[method@Message.set_tls_client_certificate] was called before the
connection TLS handshake started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to handle the request, or %FALSE to make the connection
  fail with %G_TLS_ERROR_CERTIFICATE_REQUIRED.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tls_connection" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsClientConnection</doc>
            <type name="Gio.TlsClientConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-certificate-password" when="last">
        <doc xml:space="preserve">Emitted during the @msg's connection TLS handshake when
@tls_connection requests a certificate password from the client.

You can set the certificate password on @password, then call
[method@Message.tls_client_certificate_password_request_complete] and
return %TRUE to handle the signal synchronously. It's possible to
handle the request asynchornously by calling
[method@GObject.Object.ref] on @password, then returning %TRUE and
call
[method@Message.tls_client_certificate_password_request_complete]
later after setting the password on @password. Note that this signal
is not emitted if [property@Session:tls-interaction] was set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to handle the request, or %FALSE to make the connection
  fail with %G_TLS_ERROR_CERTIFICATE_REQUIRED.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tls_password" transfer-ownership="none">
            <doc xml:space="preserve">the #GTlsPassword</doc>
            <type name="Gio.TlsPassword"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="restarted" when="first">
        <doc xml:space="preserve">Emitted when a request that was already sent once is now
being sent again.

e.g. because the first attempt received a
redirection response, or because we needed to use
authentication.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="starting" when="first">
        <doc xml:space="preserve">Emitted just before a message is sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-body" when="first">
        <doc xml:space="preserve">Emitted immediately after writing the complete body for a
message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-body-data" when="first">
        <doc xml:space="preserve">Emitted immediately after writing a portion of the message
body to the network.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chunk_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="wrote-headers" when="first">
        <doc xml:space="preserve">Emitted immediately after writing the request headers for a
message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="MessageBody" c:type="SoupMessageBody" glib:type-name="SoupMessageBody" glib:get-type="soup_message_body_get_type" c:symbol-prefix="message_body">
      <doc xml:space="preserve">#SoupMessageBody represents the request or response body of a
[class@Message].

Note that while @length always reflects the full length of the
message body, @data is normally %NULL, and will only be filled in
after [method@MessageBody.flatten] is called. For client-side
messages, this automatically happens for the response body after it
has been fully read. Likewise, for server-side
messages, the request body is automatically filled in after being
read.

As an added bonus, when @data is filled in, it is always terminated
with a `\0` byte (which is not reflected in @length).</doc>
      <field name="data" writable="1">
        <doc xml:space="preserve">the data</doc>
        <array length="1" zero-terminated="0" c:type="const char*">
          <type name="guint8"/>
        </array>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">length of @data</doc>
        <type name="gint64" c:type="goffset"/>
      </field>
      <constructor name="new" c:identifier="soup_message_body_new">
        <doc xml:space="preserve">Creates a new #SoupMessageBody.

[class@Message] uses this internally; you
will not normally need to call it yourself.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupMessageBody.</doc>
          <type name="MessageBody" c:type="SoupMessageBody*"/>
        </return-value>
      </constructor>
      <method name="append" c:identifier="soup_message_body_append" shadowed-by="append_take">
        <doc xml:space="preserve">Appends @length bytes from @data to @body according to @use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="use" transfer-ownership="none">
            <doc xml:space="preserve">how to use @data</doc>
            <type name="MemoryUse" c:type="SoupMemoryUse"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data to append</doc>
            <array length="2" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_bytes" c:identifier="soup_message_body_append_bytes">
        <doc xml:space="preserve">Appends the data from @buffer to @body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_take" c:identifier="soup_message_body_append_take" shadows="append">
        <doc xml:space="preserve">Appends @length bytes from @data to @body.

This function is exactly equivalent to [method@MessageBody.append]
with %SOUP_MEMORY_TAKE as second argument; it exists mainly for
convenience and simplifying language bindings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve">data to append</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete" c:identifier="soup_message_body_complete">
        <doc xml:space="preserve">Tags @body as being complete.

Call this when using chunked encoding after you have appended the last chunk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flatten" c:identifier="soup_message_body_flatten">
        <doc xml:space="preserve">Fills in @body's data field with a buffer containing all of the
data in @body.

Adds an additional `\0` byte not counted by @body's
length field.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes containing the same data as @body.
  (You must [method@GLib.Bytes.unref] this if you do not want it.)</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_accumulate" c:identifier="soup_message_body_get_accumulate">
        <doc xml:space="preserve">Gets the accumulate flag on @body.

See [method@MessageBody.set_accumulate. for details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the accumulate flag for @body.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_chunk" c:identifier="soup_message_body_get_chunk">
        <doc xml:space="preserve">Gets a [struct@GLib.Bytes] containing data from @body starting at @offset.

The size of the returned chunk is unspecified. You can iterate
through the entire body by first calling
[method@MessageBody.get_chunk] with an offset of 0, and then on each
successive call, increment the offset by the length of the
previously-returned chunk.

If @offset is greater than or equal to the total length of @body,
then the return value depends on whether or not
[method@MessageBody.complete] has been called or not; if it has,
then [method@MessageBody.get_chunk] will return a 0-length chunk
(indicating the end of @body). If it has not, then
[method@MessageBody.get_chunk] will return %NULL (indicating that
@body may still potentially have more data, but that data is not
currently available).</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GBytes</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">an offset</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="got_chunk" c:identifier="soup_message_body_got_chunk">
        <doc xml:space="preserve">Handles the #SoupMessageBody part of receiving a chunk of data from
the network.

Normally this means appending @chunk to @body, exactly as with
[method@MessageBody.append_bytes], but if you have set @body's accumulate
flag to %FALSE, then that will not happen.

This is a low-level method which you should not normally need to
use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes received from the network</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="soup_message_body_ref">
        <doc xml:space="preserve">Atomically increments the reference count of @body by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #SoupMessageBody</doc>
          <type name="MessageBody" c:type="SoupMessageBody*"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_accumulate" c:identifier="soup_message_body_set_accumulate">
        <doc xml:space="preserve">Sets or clears the accumulate flag on @body.

(The default value is %TRUE.) If set to %FALSE, @body's data field will not
be filled in after the body is fully sent/received, and the chunks that make
up @body may be discarded when they are no longer needed.

If you set the flag to %FALSE on the [class@Message] request_body of a
client-side message, it will block the accumulation of chunks into
@body's data field, but it will not normally cause the chunks to
be discarded after being written like in the server-side
[class@Message] response_body case, because the request body needs to
be kept around in case the request needs to be sent a second time
due to redirection or authentication.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="accumulate" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to accumulate body chunks in @body</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="truncate" c:identifier="soup_message_body_truncate">
        <doc xml:space="preserve">Deletes all of the data in @body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="soup_message_body_unref">
        <doc xml:space="preserve">Atomically decrements the reference count of @body by one.

When the reference count reaches zero, the resources allocated by
@body are freed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wrote_chunk" c:identifier="soup_message_body_wrote_chunk">
        <doc xml:space="preserve">Handles the #SoupMessageBody part of writing a chunk of data to the
network.

Normally this is a no-op, but if you have set @body's accumulate flag to
%FALSE, then this will cause @chunk to be discarded to free up memory.

This is a low-level method which you should not need to use, and
there are further restrictions on its proper use which are not
documented here.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageBody</doc>
            <type name="MessageBody" c:type="SoupMessageBody*"/>
          </instance-parameter>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes returned from [method@MessageBody.get_chunk]</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="MessageClass" c:type="SoupMessageClass" glib:is-gtype-struct-for="Message">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <bitfield name="MessageFlags" glib:type-name="SoupMessageFlags" glib:get-type="soup_message_flags_get_type" c:type="SoupMessageFlags">
      <doc xml:space="preserve">Various flags that can be set on a #SoupMessage to alter its
behavior.</doc>
      <member name="no_redirect" value="2" c:identifier="SOUP_MESSAGE_NO_REDIRECT" glib:nick="no-redirect" glib:name="SOUP_MESSAGE_NO_REDIRECT">
        <doc xml:space="preserve">The session should not follow redirect
  (3xx) responses received by this message.</doc>
      </member>
      <member name="new_connection" value="4" c:identifier="SOUP_MESSAGE_NEW_CONNECTION" glib:nick="new-connection" glib:name="SOUP_MESSAGE_NEW_CONNECTION">
        <doc xml:space="preserve">Requests that the message should be
  sent on a newly-created connection, not reusing an existing
  persistent connection. Note that messages with non-idempotent
  [property@Message:method]s behave this way by default, unless
  #SOUP_MESSAGE_IDEMPOTENT is set.</doc>
      </member>
      <member name="idempotent" value="8" c:identifier="SOUP_MESSAGE_IDEMPOTENT" glib:nick="idempotent" glib:name="SOUP_MESSAGE_IDEMPOTENT">
        <doc xml:space="preserve">The message is considered idempotent,
  regardless its [property@Message:method], and allows reuse of existing
  idle connections, instead of always requiring a new one, unless
  #SOUP_MESSAGE_NEW_CONNECTION is set.</doc>
      </member>
      <member name="do_not_use_auth_cache" value="16" c:identifier="SOUP_MESSAGE_DO_NOT_USE_AUTH_CACHE" glib:nick="do-not-use-auth-cache" glib:name="SOUP_MESSAGE_DO_NOT_USE_AUTH_CACHE">
        <doc xml:space="preserve">The [class@AuthManager] should not use
  the credentials cache for this message, neither to use cached credentials
  to automatically authenticate this message nor to cache the credentials
  after the message is successfully authenticated. This applies to both server
  and proxy authentication. Note that [signal@Message::authenticate] signal will
  be emitted, if you want to disable authentication for a message use
  [method@Message.disable_feature] passing #SOUP_TYPE_AUTH_MANAGER instead.</doc>
      </member>
      <member name="collect_metrics" value="32" c:identifier="SOUP_MESSAGE_COLLECT_METRICS" glib:nick="collect-metrics" glib:name="SOUP_MESSAGE_COLLECT_METRICS">
        <doc xml:space="preserve">Metrics will be collected for this message.</doc>
      </member>
    </bitfield>
    <record name="MessageHeaders" c:type="SoupMessageHeaders" glib:type-name="SoupMessageHeaders" glib:get-type="soup_message_headers_get_type" c:symbol-prefix="message_headers">
      <doc xml:space="preserve">The HTTP message headers associated with a request or response.</doc>
      <constructor name="new" c:identifier="soup_message_headers_new">
        <doc xml:space="preserve">Creates a #SoupMessageHeaders.

([class@Message] does this automatically for its own headers. You would only
need to use this method if you are manually parsing or generating message
headers.)</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupMessageHeaders</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of headers</doc>
            <type name="MessageHeadersType" c:type="SoupMessageHeadersType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="soup_message_headers_append">
        <doc xml:space="preserve">Appends a new header with name @name and value @value to @hdrs.

(If there is an existing header with name @name, then this creates a second
one, which is only allowed for list-valued headers; see also
[method@MessageHeaders.replace].)

The caller is expected to make sure that @name and @value are
syntactically correct.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the header name to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value of @name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clean_connection_headers" c:identifier="soup_message_headers_clean_connection_headers">
        <doc xml:space="preserve">Removes all the headers listed in the Connection header.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="soup_message_headers_clear">
        <doc xml:space="preserve">Clears @hdrs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="soup_message_headers_foreach">
        <doc xml:space="preserve">Calls @func once for each header value in @hdrs.

Beware that unlike [method@MessageHeaders.get_list], this processes the
headers in exactly the way they were added, rather than
concatenating multiple same-named headers into a single value.
(This is intentional; it ensures that if you call
[method@MessageHeaders.append] multiple times with the same name,
then the I/O code will output multiple copies of the header when
sending the message to the remote implementation, which may be
required for interoperability in some cases.)

You may not modify the headers from @func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="func" transfer-ownership="none" scope="call" closure="1">
            <doc xml:space="preserve">callback function to run for each header</doc>
            <type name="MessageHeadersForeachFunc" c:type="SoupMessageHeadersForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_ranges" c:identifier="soup_message_headers_free_ranges">
        <doc xml:space="preserve">Frees the array of ranges returned from [method@MessageHeaders.get_ranges].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="ranges" transfer-ownership="none">
            <doc xml:space="preserve">an array of #SoupRange</doc>
            <type name="Range" c:type="SoupRange*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_disposition" c:identifier="soup_message_headers_get_content_disposition">
        <doc xml:space="preserve">Looks up the "Content-Disposition" header in @hdrs, parses it, and
returns its value in *@disposition and *@params.

@params can be %NULL if you are only interested in the disposition-type.

In HTTP, the most common use of this header is to set a
disposition-type of "attachment", to suggest to the browser that a
response should be saved to disk rather than displayed in the
browser. If @params contains a "filename" parameter, this is a
suggestion of a filename to use. (If the parameter value in the
header contains an absolute or relative path, libsoup will truncate
it down to just the final path component, so you do not need to
test this yourself.)

Content-Disposition is also used in "multipart/form-data", however
this is handled automatically by [struct@Multipart] and the associated
form methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hdrs contains a "Content-Disposition"
  header, %FALSE if not (in which case *@disposition and *@params
  will be unchanged).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="disposition" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for the
  disposition-type, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="params" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return
  location for the Content-Disposition parameters, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_length" c:identifier="soup_message_headers_get_content_length">
        <doc xml:space="preserve">Gets the message body length that @hdrs declare.

This will only be non-0 if [method@MessageHeaders.get_encoding] returns
%SOUP_ENCODING_CONTENT_LENGTH.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the message body length declared by @hdrs.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_range" c:identifier="soup_message_headers_get_content_range">
        <doc xml:space="preserve">Parses @hdrs's Content-Range header and returns it in @start,
@end, and @total_length. If the total length field in the header
was specified as "*", then @total_length will be set to -1.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hdrs contained a "Content-Range" header
  containing a byte range which could be parsed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="start" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return value for the start of the range</doc>
            <type name="gint64" c:type="goffset*"/>
          </parameter>
          <parameter name="end" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return value for the end of the range</doc>
            <type name="gint64" c:type="goffset*"/>
          </parameter>
          <parameter name="total_length" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">return value for the total length of the
  resource, or %NULL if you don't care.</doc>
            <type name="gint64" c:type="goffset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_type" c:identifier="soup_message_headers_get_content_type">
        <doc xml:space="preserve">Looks up the "Content-Type" header in @hdrs, parses it, and returns
its value in *@content_type and *@params.

@params can be %NULL if you are only interested in the content type itself.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a string with the value of the
  "Content-Type" header or %NULL if @hdrs does not contain that
  header or it cannot be parsed (in which case *@params will be
  unchanged).</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="params" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">
  return location for the Content-Type parameters (eg, "charset"), or
  %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_encoding" c:identifier="soup_message_headers_get_encoding">
        <doc xml:space="preserve">Gets the message body encoding that @hdrs declare.

This may not always correspond to the encoding used on the wire; eg, a HEAD
response may declare a Content-Length or Transfer-Encoding, but it will never
actually include a body.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the encoding declared by @hdrs.</doc>
          <type name="Encoding" c:type="SoupEncoding"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_expectations" c:identifier="soup_message_headers_get_expectations">
        <doc xml:space="preserve">Gets the expectations declared by @hdrs's "Expect" header.

Currently this will either be %SOUP_EXPECTATION_CONTINUE or
%SOUP_EXPECTATION_UNRECOGNIZED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the contents of @hdrs's "Expect" header</doc>
          <type name="Expectation" c:type="SoupExpectation"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_headers_type" c:identifier="soup_message_headers_get_headers_type">
        <doc xml:space="preserve">Gets the type of headers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the header's type.</doc>
          <type name="MessageHeadersType" c:type="SoupMessageHeadersType"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_list" c:identifier="soup_message_headers_get_list">
        <doc xml:space="preserve">Gets the value of header @name in @hdrs.

Use this for headers whose values are comma-delimited lists, and which are
therefore allowed to appear multiple times in the headers. For
non-list-valued headers, use [method@MessageHeaders.get_one].

If @name appears multiple times in @hdrs,
[method@MessageHeaders.get_list] will concatenate all of the values
together, separated by commas. This is sometimes awkward to parse
(eg, WWW-Authenticate, Set-Cookie), but you have to be able to deal
with it anyway, because the HTTP spec explicitly states that this
transformation is allowed, and so an upstream proxy could do the
same thing.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the header's value or %NULL if not found.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_one" c:identifier="soup_message_headers_get_one">
        <doc xml:space="preserve">Gets the value of header @name in @hdrs.

Use this for headers whose values are *not* comma-delimited lists, and which
therefore can only appear at most once in the headers. For list-valued
headers, use [method@MessageHeaders.get_list].

If @hdrs does erroneously contain multiple copies of the header, it
is not defined which one will be returned. (Ideally, it will return
whichever one makes libsoup most compatible with other HTTP
implementations.)</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the header's value or %NULL if not found.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ranges" c:identifier="soup_message_headers_get_ranges">
        <doc xml:space="preserve">Parses @hdrs's Range header and returns an array of the requested
byte ranges.

The returned array must be freed with [method@MessageHeaders.free_ranges].

If @total_length is non-0, its value will be used to adjust the
returned ranges to have explicit start and end values, and the
returned ranges will be sorted and non-overlapping. If
@total_length is 0, then some ranges may have an end value of -1,
as described under [struct@Range], and some of the ranges may be
redundant.

Beware that even if given a @total_length, this function does not
check that the ranges are satisfiable.

#SoupServer has built-in handling for range requests. If your
server handler returns a %SOUP_STATUS_OK response containing the
complete response body (rather than pausing the message and
returning some of the response body later), and there is a Range
header in the request, then libsoup will automatically convert the
response to a %SOUP_STATUS_PARTIAL_CONTENT response containing only
the range(s) requested by the client.

The only time you need to process the Range header yourself is if
either you need to stream the response body rather than returning
it all at once, or you do not already have the complete response
body available, and only want to generate the parts that were
actually requested by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @hdrs contained a syntactically-valid
  "Range" header, %FALSE otherwise (in which case @range and @length
  will not be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="total_length" transfer-ownership="none">
            <doc xml:space="preserve">the total_length of the response body</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="ranges" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">return location for an array
  of #SoupRange</doc>
            <array length="2" zero-terminated="0" c:type="SoupRange**">
              <type name="Range" c:type="SoupRange*"/>
            </array>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the length of the returned array</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="header_contains" c:identifier="soup_message_headers_header_contains">
        <doc xml:space="preserve">Checks whether the list-valued header @name is present in @hdrs,
and contains a case-insensitive match for @token.

(If @name is present in @hdrs, then this is equivalent to calling
[func@header_contains] on its value.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the header is present and contains @token,
  %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">token to look for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="header_equals" c:identifier="soup_message_headers_header_equals">
        <doc xml:space="preserve">Checks whether the header @name is present in @hdrs and is
(case-insensitively) equal to @value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the header is present and its value is
  @value, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">header name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">expected value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="soup_message_headers_ref">
        <doc xml:space="preserve">Atomically increments the reference count of @hdrs by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the passed in #SoupMessageHeaders</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="soup_message_headers_remove">
        <doc xml:space="preserve">Removes @name from @hdrs.

If there are multiple values for @name, they are all removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the header name to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace" c:identifier="soup_message_headers_replace">
        <doc xml:space="preserve">Replaces the value of the header @name in @hdrs with @value.

See also [method@MessageHeaders.append].

The caller is expected to make sure that @name and @value are
syntactically correct.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the header name to replace</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the new value of @name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_disposition" c:identifier="soup_message_headers_set_content_disposition">
        <doc xml:space="preserve">Sets the "Content-Disposition" header in @hdrs to @disposition,
optionally with additional parameters specified in @params.

See [method@MessageHeaders.get_content_disposition] for a discussion
of how Content-Disposition is used in HTTP.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="disposition" transfer-ownership="none">
            <doc xml:space="preserve">the disposition-type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional parameters</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_length" c:identifier="soup_message_headers_set_content_length">
        <doc xml:space="preserve">Sets the message body length that @hdrs will declare, and sets
@hdrs's encoding to %SOUP_ENCODING_CONTENT_LENGTH.

You do not normally need to call this; if @hdrs is set to use
Content-Length encoding, libsoup will automatically set its
Content-Length header for you immediately before sending the
headers. One situation in which this method is useful is when
generating the response to a HEAD request; Calling
[method@MessageHeaders.set_content_length] allows you to put the
correct content length into the response without needing to waste
memory by filling in a response body which won't actually be sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="content_length" transfer-ownership="none">
            <doc xml:space="preserve">the message body length</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_range" c:identifier="soup_message_headers_set_content_range">
        <doc xml:space="preserve">Sets @hdrs's Content-Range header according to the given values.

(Note that @total_length is the total length of the entire resource
that this is a range of, not simply @end - @start + 1.)

[class@Server] has built-in handling for range requests, and you do
not normally need to call this function youself. See
[method@MessageHeaders.get_ranges] for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the start of the range</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the end of the range</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="total_length" transfer-ownership="none">
            <doc xml:space="preserve">the total length of the resource, or -1 if unknown</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_type" c:identifier="soup_message_headers_set_content_type">
        <doc xml:space="preserve">Sets the "Content-Type" header in @hdrs to @content_type.

Accepts additional parameters specified in @params.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">the MIME type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">additional parameters</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_encoding" c:identifier="soup_message_headers_set_encoding">
        <doc xml:space="preserve">Sets the message body encoding that @hdrs will declare.

In particular, you should use this if you are going to send a request or
response in chunked encoding.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="encoding" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupEncoding</doc>
            <type name="Encoding" c:type="SoupEncoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expectations" c:identifier="soup_message_headers_set_expectations">
        <doc xml:space="preserve">Sets @hdrs's "Expect" header according to @expectations.

Currently %SOUP_EXPECTATION_CONTINUE is the only known expectation
value. You should set this value on a request if you are sending a
large message body (eg, via POST or PUT), and want to give the
server a chance to reject the request after seeing just the headers
(eg, because it will require authentication before allowing you to
post, or because you're POSTing to a URL that doesn't exist). This
saves you from having to transmit the large request body when the
server is just going to ignore it anyway.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="expectations" transfer-ownership="none">
            <doc xml:space="preserve">the expectations to set</doc>
            <type name="Expectation" c:type="SoupExpectation"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_range" c:identifier="soup_message_headers_set_range">
        <doc xml:space="preserve">Sets @hdrs's Range header to request the indicated range.

@start and @end are interpreted as in a [struct@Range].

If you need to request multiple ranges, use
[method@MessageHeaders.set_ranges].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">the start of the range to request</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">the end of the range to request</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ranges" c:identifier="soup_message_headers_set_ranges">
        <doc xml:space="preserve">Sets @hdrs's Range header to request the indicated ranges.

If you only want to request a single range, you can use
[method@MessageHeaders.set_range].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
          <parameter name="ranges" transfer-ownership="none">
            <doc xml:space="preserve">an array of #SoupRange</doc>
            <type name="Range" c:type="SoupRange*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @range</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="soup_message_headers_unref">
        <doc xml:space="preserve">Atomically decrements the reference count of @hdrs by one.

When the reference count reaches zero, the resources allocated by
@hdrs are freed</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="MessageHeadersForeachFunc" c:type="SoupMessageHeadersForeachFunc">
      <doc xml:space="preserve">The callback passed to [method@MessageHeaders.foreach].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the header name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">the data passed to [method@MessageHeaders.foreach]</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="MessageHeadersIter" c:type="SoupMessageHeadersIter">
      <doc xml:space="preserve">An opaque type used to iterate over a %SoupMessageHeaders
structure.

After intializing the iterator with [func@MessageHeadersIter.init], call
[method@MessageHeadersIter.next] to fetch data from it.

You may not modify the headers while iterating over them.</doc>
      <field name="dummy" readable="0" private="1">
        <array zero-terminated="0" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="next" c:identifier="soup_message_headers_iter_next">
        <doc xml:space="preserve">Yields the next name/value pair in the [struct@MessageHeaders] being
iterated by @iter.

If @iter has already yielded the last header, then
[method@MessageHeadersIter.next] will return %FALSE and @name and @value
will be unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if another name and value were returned, %FALSE
  if the end of the headers has been reached.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iter" direction="inout" caller-allocates="0" transfer-ownership="none">
            <doc xml:space="preserve">a %SoupMessageHeadersIter</doc>
            <type name="MessageHeadersIter" c:type="SoupMessageHeadersIter*"/>
          </instance-parameter>
          <parameter name="name" direction="out" caller-allocates="0" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a variable to return
  the header name in</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="value" direction="out" caller-allocates="0" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a variable to return
  the header value in</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <function name="init" c:identifier="soup_message_headers_iter_init">
        <doc xml:space="preserve">Initializes @iter for iterating @hdrs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" direction="out" caller-allocates="1" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a %SoupMessageHeadersIter
  structure</doc>
            <type name="MessageHeadersIter" c:type="SoupMessageHeadersIter*"/>
          </parameter>
          <parameter name="hdrs" transfer-ownership="none">
            <doc xml:space="preserve">a %SoupMessageHeaders</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="MessageHeadersType" glib:type-name="SoupMessageHeadersType" glib:get-type="soup_message_headers_type_get_type" c:type="SoupMessageHeadersType">
      <doc xml:space="preserve">Value passed to [ctor@MessageHeaders.new] to set certain default
behaviors.</doc>
      <member name="request" value="0" c:identifier="SOUP_MESSAGE_HEADERS_REQUEST" glib:nick="request" glib:name="SOUP_MESSAGE_HEADERS_REQUEST">
        <doc xml:space="preserve">request headers</doc>
      </member>
      <member name="response" value="1" c:identifier="SOUP_MESSAGE_HEADERS_RESPONSE" glib:nick="response" glib:name="SOUP_MESSAGE_HEADERS_RESPONSE">
        <doc xml:space="preserve">response headers</doc>
      </member>
      <member name="multipart" value="2" c:identifier="SOUP_MESSAGE_HEADERS_MULTIPART" glib:nick="multipart" glib:name="SOUP_MESSAGE_HEADERS_MULTIPART">
        <doc xml:space="preserve">multipart body part headers</doc>
      </member>
    </enumeration>
    <record name="MessageMetrics" c:type="SoupMessageMetrics" glib:type-name="SoupMessageMetrics" glib:get-type="soup_message_metrics_get_type" c:symbol-prefix="message_metrics">
      <doc xml:space="preserve">Contains metrics collected while loading a [class@Message] either from the
network or the disk cache.

Metrics are not collected by default for a [class@Message], you need to add the
flag %SOUP_MESSAGE_COLLECT_METRICS to enable the feature.

Temporal metrics are expressed as a monotonic time and always start with a
fetch start event and finish with response end. All other events are optional.
An event can be 0 because it hasn't happened yet, because it's optional or
because the load failed before the event reached.

Size metrics are expressed in bytes and are updated while the [class@Message] is
being loaded. You can connect to different [class@Message] signals to get the
final result of every value.</doc>
      <method name="copy" c:identifier="soup_message_metrics_copy">
        <doc xml:space="preserve">Copies @metrics.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @metrics</doc>
          <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_message_metrics_free">
        <doc xml:space="preserve">Frees @metrics.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connect_end" c:identifier="soup_message_metrics_get_connect_end">
        <doc xml:space="preserve">Get the time immediately after the [class@Message] completed the
connection to the server. This includes the time for the proxy
negotiation and TLS handshake.

It will be 0 if no network connection was required to fetch the resource (a
persistent connection was used or resource was loaded from the local disk
cache).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection end time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connect_start" c:identifier="soup_message_metrics_get_connect_start">
        <doc xml:space="preserve">Get the time immediately before the [class@Message] started to
establish the connection to the server.

It will be 0 if no network connection was required to fetch the resource (a
persistent connection was used or resource was loaded from the local disk
cache).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection start time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns_end" c:identifier="soup_message_metrics_get_dns_end">
        <doc xml:space="preserve">Get the time immediately after the [class@Message] completed the
domain lookup name for the resource.

It will be 0 if no domain lookup was required to fetch the resource (a
persistent connection was used or resource was loaded from the local disk
cache).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the domain lookup end time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns_start" c:identifier="soup_message_metrics_get_dns_start">
        <doc xml:space="preserve">Get the time immediately before the [class@Message] started the
domain lookup name for the resource.

It will be 0 if no domain lookup was required to fetch the resource (a
persistent connection was used or resource was loaded from the local disk
cache).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the domain lookup start time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fetch_start" c:identifier="soup_message_metrics_get_fetch_start">
        <doc xml:space="preserve">Get the time immediately before the [class@Message] started to
fetch a resource either from a remote server or local disk cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the fetch start time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_body_bytes_sent" c:identifier="soup_message_metrics_get_request_body_bytes_sent">
        <doc xml:space="preserve">Get the number of bytes sent to the network for the request body.

This is the size of the body sent, after encodings are applied, so it might
be greater than the value returned by
[method@MessageMetrics.get_request_body_size]. This value is available right
before [signal@Message::wrote-body] signal is emitted, but you might get an
intermediate value if called before.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the request body bytes sent</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_body_size" c:identifier="soup_message_metrics_get_request_body_size">
        <doc xml:space="preserve">Get the request body size in bytes. This is the size of the original body
given to the request before any encoding is applied.

This value is available right before [signal@Message::wrote-body] signal is
emitted, but you might get an intermediate value if called before.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the request body size</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_header_bytes_sent" c:identifier="soup_message_metrics_get_request_header_bytes_sent">
        <doc xml:space="preserve">Get the number of bytes sent to the network for the request headers.

This value is available right before [signal@Message::wrote-headers] signal
is emitted, but you might get an intermediate value if called before.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the request headers bytes sent</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_start" c:identifier="soup_message_metrics_get_request_start">
        <doc xml:space="preserve">Get the time immediately before the [class@Message] started the
request of the resource from the server or the local disk cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the request start time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_body_bytes_received" c:identifier="soup_message_metrics_get_response_body_bytes_received">
        <doc xml:space="preserve">Get the number of bytes received from the network for the response body.

This value is available right before [signal@Message::got-body] signal is
emitted, but you might get an intermediate value if called before. For
resources loaded from the disk cache this value is always 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the response body bytes received</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_body_size" c:identifier="soup_message_metrics_get_response_body_size">
        <doc xml:space="preserve">Get the response body size in bytes.

This is the size of the body as given to the user after all encodings are
applied, so it might be greater than the value returned by
[method@MessageMetrics.get_response_body_bytes_received]. This value is
available right before [signal@Message::got-body] signal is emitted, but you
might get an intermediate value if called before.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the response body size</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_end" c:identifier="soup_message_metrics_get_response_end">
        <doc xml:space="preserve">Get the time immediately after the [class@Message] received the last
bytes of the response from the server or the local disk cache.

In case of load failure, this returns the time immediately before the
fetch is aborted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the response end time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_header_bytes_received" c:identifier="soup_message_metrics_get_response_header_bytes_received">
        <doc xml:space="preserve">Get the number of bytes received from the network for the response headers.

This value is available right before [signal@Message::got-headers] signal
is emitted, but you might get an intermediate value if called before.
For resources loaded from the disk cache this value is always 0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the response headers bytes received</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_start" c:identifier="soup_message_metrics_get_response_start">
        <doc xml:space="preserve">Get the time immediately after the [class@Message] received the first
bytes of the response from the server or the local disk cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the response start time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_start" c:identifier="soup_message_metrics_get_tls_start">
        <doc xml:space="preserve">Get the time immediately before the [class@Message] started the
TLS handshake.

It will be 0 if no TLS handshake was required to fetch the resource
(connection was not secure, a persistent connection was used or resource was
loaded from the local disk cache).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the tls start time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="metrics" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessageMetrics</doc>
            <type name="MessageMetrics" c:type="SoupMessageMetrics*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="MessagePriority" glib:type-name="SoupMessagePriority" glib:get-type="soup_message_priority_get_type" c:type="SoupMessagePriority">
      <doc xml:space="preserve">Priorities that can be set on a [class@Message] to instruct the message queue
to process it before any other message with lower priority.</doc>
      <member name="very_low" value="0" c:identifier="SOUP_MESSAGE_PRIORITY_VERY_LOW" glib:nick="very-low" glib:name="SOUP_MESSAGE_PRIORITY_VERY_LOW">
        <doc xml:space="preserve">The lowest priority, the messages
  with this priority will be the last ones to be attended.</doc>
      </member>
      <member name="low" value="1" c:identifier="SOUP_MESSAGE_PRIORITY_LOW" glib:nick="low" glib:name="SOUP_MESSAGE_PRIORITY_LOW">
        <doc xml:space="preserve">Use this for low priority messages, a
  #SoupMessage with the default priority will be processed first.</doc>
      </member>
      <member name="normal" value="2" c:identifier="SOUP_MESSAGE_PRIORITY_NORMAL" glib:nick="normal" glib:name="SOUP_MESSAGE_PRIORITY_NORMAL">
        <doc xml:space="preserve">The default priotity, this is the
  priority assigned to the #SoupMessage by default.</doc>
      </member>
      <member name="high" value="3" c:identifier="SOUP_MESSAGE_PRIORITY_HIGH" glib:nick="high" glib:name="SOUP_MESSAGE_PRIORITY_HIGH">
        <doc xml:space="preserve">High priority, a #SoupMessage with
  this priority will be processed before the ones with the default
  priority.</doc>
      </member>
      <member name="very_high" value="4" c:identifier="SOUP_MESSAGE_PRIORITY_VERY_HIGH" glib:nick="very-high" glib:name="SOUP_MESSAGE_PRIORITY_VERY_HIGH">
        <doc xml:space="preserve">The highest priority, use this
  for very urgent #SoupMessage as they will be the first ones to be
  attended.</doc>
      </member>
    </enumeration>
    <record name="Multipart" c:type="SoupMultipart" glib:type-name="SoupMultipart" glib:get-type="soup_multipart_get_type" c:symbol-prefix="multipart">
      <doc xml:space="preserve">Represents a multipart HTTP message body, parsed according to the
syntax of RFC 2046.

Of particular interest to HTTP are `multipart/byte-ranges` and
`multipart/form-data`,

Although the headers of a #SoupMultipart body part will contain the
full headers from that body part, libsoup does not interpret them
according to MIME rules. For example, each body part is assumed to
have "binary" Content-Transfer-Encoding, even if its headers
explicitly state otherwise. In other words, don't try to use
#SoupMultipart for handling real MIME multiparts.</doc>
      <constructor name="new" c:identifier="soup_multipart_new">
        <doc xml:space="preserve">Creates a new empty #SoupMultipart with a randomly-generated
boundary string.

Note that @mime_type must be the full MIME type, including "multipart/".

See also: [ctor@Message.new_from_multipart].</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new empty #SoupMultipart of the given @mime_type</doc>
          <type name="Multipart" c:type="SoupMultipart*"/>
        </return-value>
        <parameters>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve">the MIME type of the multipart to create.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_message" c:identifier="soup_multipart_new_from_message">
        <doc xml:space="preserve">Parses @headers and @body to form a new #SoupMultipart</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupMultipart (or %NULL if the
  message couldn't be parsed or wasn't multipart).</doc>
          <type name="Multipart" c:type="SoupMultipart*"/>
        </return-value>
        <parameters>
          <parameter name="headers" transfer-ownership="none">
            <doc xml:space="preserve">the headers of the HTTP message to parse</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">the body of the HTTP message to parse</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_form_file" c:identifier="soup_multipart_append_form_file">
        <doc xml:space="preserve">Adds a new MIME part containing @body to @multipart

Uses "Content-Disposition: form-data", as per the HTML forms specification.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a multipart (presumably of type "multipart/form-data")</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="control_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the control associated with this file</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the name of the file, or %NULL if not known</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="content_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the MIME type of the file, or %NULL if not known</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">the file data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_form_string" c:identifier="soup_multipart_append_form_string">
        <doc xml:space="preserve">Adds a new MIME part containing @data to @multipart.

Uses "Content-Disposition: form-data", as per the HTML forms specification.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a multipart (presumably of type "multipart/form-data")</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="control_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the control associated with @data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the body data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_part" c:identifier="soup_multipart_append_part">
        <doc xml:space="preserve">Adds a new MIME part to @multipart with the given headers and body.

(The multipart will make its own copies of @headers and @body, so
you should free your copies if you are not using them for anything
else.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="headers" transfer-ownership="none">
            <doc xml:space="preserve">the MIME part headers</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">the MIME part body</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="soup_multipart_free">
        <doc xml:space="preserve">Frees @multipart.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="soup_multipart_get_length">
        <doc xml:space="preserve">Gets the number of body parts in @multipart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of body parts in @multipart</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_part" c:identifier="soup_multipart_get_part">
        <doc xml:space="preserve">Gets the indicated body part from @multipart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @part is out of range (in
  which case @headers and @body won't be set)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">the part number to get (counting from 0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="headers" direction="out" caller-allocates="0" transfer-ownership="none">
            <doc xml:space="preserve">return location for the MIME part
  headers</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders**"/>
          </parameter>
          <parameter name="body" direction="out" caller-allocates="0" transfer-ownership="none">
            <doc xml:space="preserve">return location for the MIME part
  body</doc>
            <type name="GLib.Bytes" c:type="GBytes**"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_message" c:identifier="soup_multipart_to_message">
        <doc xml:space="preserve">Serializes @multipart to @dest_headers and @dest_body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipart</doc>
            <type name="Multipart" c:type="SoupMultipart*"/>
          </instance-parameter>
          <parameter name="dest_headers" transfer-ownership="none">
            <doc xml:space="preserve">the headers of the HTTP message to serialize @multipart to</doc>
            <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
          </parameter>
          <parameter name="dest_body" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the body of the HTTP message to serialize @multipart to</doc>
            <type name="GLib.Bytes" c:type="GBytes**"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="MultipartInputStream" c:symbol-prefix="multipart_input_stream" c:type="SoupMultipartInputStream" parent="Gio.FilterInputStream" final="1" glib:type-name="SoupMultipartInputStream" glib:get-type="soup_multipart_input_stream_get_type" glib:type-struct="MultipartInputStreamClass">
      <doc xml:space="preserve">Handles streams of multipart messages.

This adds support for the multipart responses. For handling the
multiple parts the user needs to wrap the [class@Gio.InputStream] obtained by
sending the request with a [class@MultipartInputStream] and use
[method@MultipartInputStream.next_part] before reading. Responses
which are not wrapped will be treated like non-multipart responses.

Note that although #SoupMultipartInputStream is a [class@Gio.InputStream],
you should not read directly from it, and the results are undefined
if you do.</doc>
      <implements name="Gio.PollableInputStream"/>
      <constructor name="new" c:identifier="soup_multipart_input_stream_new">
        <doc xml:space="preserve">Creates a new #SoupMultipartInputStream that wraps the
[class@Gio.InputStream] obtained by sending the [class@Message].

Reads should not be done directly through this object, use the input streams
returned by [method@MultipartInputStream.next_part] or its async
counterpart instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupMultipartInputStream</doc>
          <type name="MultipartInputStream" c:type="SoupMultipartInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMessage the response is related to.</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">the #GInputStream returned by sending the request.</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_headers" c:identifier="soup_multipart_input_stream_get_headers">
        <doc xml:space="preserve">Obtains the headers for the part currently being processed.

Note that the [struct@MessageHeaders] that are returned are owned by the
#SoupMultipartInputStream and will be replaced when a call is made to
[method@MultipartInputStream.next_part] or its async counterpart, so if
keeping the headers is required, a copy must be made.

Note that if a part had no headers at all an empty [struct@MessageHeaders]
will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupMessageHeaders
  containing the headers for the part currently being processed or
  %NULL if the headers failed to parse.</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipartInputStream.</doc>
            <type name="MultipartInputStream" c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next_part" c:identifier="soup_multipart_input_stream_next_part" throws="1">
        <doc xml:space="preserve">Obtains an input stream for the next part.

When dealing with a multipart response the input stream needs to be wrapped
in a #SoupMultipartInputStream and this function or its async counterpart
need to be called to obtain the first part for reading.

After calling this function,
[method@MultipartInputStream.get_headers] can be used to obtain the
headers for the first part. A read of 0 bytes indicates the end of
the part; a new call to this function should be done at that point,
to obtain the next part.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GInputStream, or
  %NULL if there are no more parts</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMultipartInputStream</doc>
            <type name="MultipartInputStream" c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_part_async" c:identifier="soup_multipart_input_stream_next_part_async">
        <doc xml:space="preserve">Obtains a [class@Gio.InputStream] for the next request.

See [method@MultipartInputStream.next_part] for details on the workflow.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">the #SoupMultipartInputStream.</doc>
            <type name="MultipartInputStream" c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority for the request.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">callback to call when request is satisfied.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_part_finish" c:identifier="soup_multipart_input_stream_next_part_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous request for the next part.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly created
  [class@Gio.InputStream] for reading the next part or %NULL if there are no
  more parts.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMultipartInputStream.</doc>
            <type name="MultipartInputStream" c:type="SoupMultipartInputStream*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="message" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The [class@Message].</doc>
        <type name="Message"/>
      </property>
    </class>
    <record name="MultipartInputStreamClass" c:type="SoupMultipartInputStreamClass" glib:is-gtype-struct-for="MultipartInputStream">
      <field name="parent_class">
        <type name="Gio.FilterInputStreamClass" c:type="GFilterInputStreamClass"/>
      </field>
    </record>
    <record name="Range" c:type="SoupRange">
      <doc xml:space="preserve">Represents a byte range as used in the Range header.

If @end is non-negative, then @start and @end represent the bounds
of of the range, counting from 0. (Eg, the first 500 bytes would be
represented as @start = 0 and @end = 499.)

If @end is -1 and @start is non-negative, then this represents a
range starting at @start and ending with the last byte of the
requested resource body. (Eg, all but the first 500 bytes would be
@start = 500, and @end = -1.)

If @end is -1 and @start is negative, then it represents a "suffix
range", referring to the last -@start bytes of the resource body.
(Eg, the last 500 bytes would be @start = -500 and @end = -1.)</doc>
      <field name="start" writable="1">
        <doc xml:space="preserve">the start of the range</doc>
        <type name="gint64" c:type="goffset"/>
      </field>
      <field name="end" writable="1">
        <doc xml:space="preserve">the end of the range</doc>
        <type name="gint64" c:type="goffset"/>
      </field>
    </record>
    <function-macro name="STATUS_IS_CLIENT_ERROR" c:identifier="SOUP_STATUS_IS_CLIENT_ERROR" introspectable="0">
      <doc xml:space="preserve">Tests if @status is a Client Error (4xx) response.</doc>
      <parameters>
        <parameter name="status">
          <doc xml:space="preserve">an HTTP status code</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STATUS_IS_INFORMATIONAL" c:identifier="SOUP_STATUS_IS_INFORMATIONAL" introspectable="0">
      <doc xml:space="preserve">Tests if @status is an Informational (1xx) response.</doc>
      <parameters>
        <parameter name="status">
          <doc xml:space="preserve">an HTTP status code</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STATUS_IS_REDIRECTION" c:identifier="SOUP_STATUS_IS_REDIRECTION" introspectable="0">
      <doc xml:space="preserve">Tests if @status is a Redirection (3xx) response.</doc>
      <parameters>
        <parameter name="status">
          <doc xml:space="preserve">an HTTP status code</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STATUS_IS_SERVER_ERROR" c:identifier="SOUP_STATUS_IS_SERVER_ERROR" introspectable="0">
      <doc xml:space="preserve">Tests if @status is a Server Error (5xx) response.</doc>
      <parameters>
        <parameter name="status">
          <doc xml:space="preserve">an HTTP status code</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="STATUS_IS_SUCCESSFUL" c:identifier="SOUP_STATUS_IS_SUCCESSFUL" introspectable="0">
      <doc xml:space="preserve">Tests if @status is a Successful (2xx) response.</doc>
      <parameters>
        <parameter name="status">
          <doc xml:space="preserve">an HTTP status code</doc>
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="SameSitePolicy" glib:type-name="SoupSameSitePolicy" glib:get-type="soup_same_site_policy_get_type" c:type="SoupSameSitePolicy">
      <doc xml:space="preserve">Represents the same-site policies of a cookie.</doc>
      <member name="none" value="0" c:identifier="SOUP_SAME_SITE_POLICY_NONE" glib:nick="none" glib:name="SOUP_SAME_SITE_POLICY_NONE">
        <doc xml:space="preserve">The cookie is exposed with both cross-site and same-site requests</doc>
      </member>
      <member name="lax" value="1" c:identifier="SOUP_SAME_SITE_POLICY_LAX" glib:nick="lax" glib:name="SOUP_SAME_SITE_POLICY_LAX">
        <doc xml:space="preserve">The cookie is withheld on cross-site requests but exposed on cross-site navigations</doc>
      </member>
      <member name="strict" value="2" c:identifier="SOUP_SAME_SITE_POLICY_STRICT" glib:nick="strict" glib:name="SOUP_SAME_SITE_POLICY_STRICT">
        <doc xml:space="preserve">The cookie is only exposed for same-site requests</doc>
      </member>
    </enumeration>
    <class name="Server" c:symbol-prefix="server" c:type="SoupServer" parent="GObject.Object" glib:type-name="SoupServer" glib:get-type="soup_server_get_type" glib:type-struct="ServerClass">
      <doc xml:space="preserve">A HTTP server.

#SoupServer implements a simple HTTP server.

To begin, create a server using [ctor@Server.new]. Add at least one
handler by calling [method@Server.add_handler] or
[method@Server.add_early_handler]; the handler will be called to
process any requests underneath the path you pass. (If you want all
requests to go to the same handler, just pass "/" (or %NULL) for
the path.)

When a new connection is accepted (or a new request is started on
an existing persistent connection), the #SoupServer will emit
[signal@Server::request-started] and then begin processing the request
as described below, but note that once the message is assigned a
status-code, then callbacks after that point will be
skipped. Note also that it is not defined when the callbacks happen
relative to various [class@ServerMessage] signals.

Once the headers have been read, #SoupServer will check if there is
a [class@AuthDomain] `(qv)` covering the Request-URI; if so, and if the
message does not contain suitable authorization, then the
[class@AuthDomain] will set a status of %SOUP_STATUS_UNAUTHORIZED on
the message.

After checking for authorization, #SoupServer will look for "early"
handlers (added with [method@Server.add_early_handler]) matching the
Request-URI. If one is found, it will be run; in particular, this
can be used to connect to signals to do a streaming read of the
request body.

(At this point, if the request headers contain `Expect:
100-continue`, and a status code has been set, then
#SoupServer will skip the remaining steps and return the response.
If the request headers contain `Expect:
100-continue` and no status code has been set,
#SoupServer will return a %SOUP_STATUS_CONTINUE status before
continuing.)

The server will then read in the response body (if present). At
this point, if there are no handlers at all defined for the
Request-URI, then the server will return %SOUP_STATUS_NOT_FOUND to
the client.

Otherwise (assuming no previous step assigned a status to the
message) any "normal" handlers (added with
[method@Server.add_handler]) for the message's Request-URI will be
run.

Then, if the path has a WebSocket handler registered (and has
not yet been assigned a status), #SoupServer will attempt to
validate the WebSocket handshake, filling in the response and
setting a status of %SOUP_STATUS_SWITCHING_PROTOCOLS or
%SOUP_STATUS_BAD_REQUEST accordingly.

If the message still has no status code at this point (and has not
been paused with [method@ServerMessage.pause]), then it will be
given a status of %SOUP_STATUS_INTERNAL_SERVER_ERROR (because at
least one handler ran, but returned without assigning a status).

Finally, the server will emit [signal@Server::request-finished] (or
[signal@Server::request-aborted] if an I/O error occurred before
handling was completed).

If you want to handle the special "*" URI (eg, "OPTIONS *"), you
must explicitly register a handler for "*"; the default handler
will not be used for that case.

If you want to process https connections in addition to (or instead
of) http connections, you can set the [property@Server:tls-certificate]
property.

Once the server is set up, make one or more calls to
[method@Server.listen], [method@Server.listen_local], or
[method@Server.listen_all] to tell it where to listen for
connections. (All ports on a #SoupServer use the same handlers; if
you need to handle some ports differently, such as returning
different data for http and https, you'll need to create multiple
`SoupServer`s, or else check the passed-in URI in the handler
function.).

#SoupServer will begin processing connections as soon as you return
to (or start) the main loop for the current thread-default
[struct@GLib.MainContext].</doc>
      <constructor name="new" c:identifier="soup_server_new" introspectable="0">
        <doc xml:space="preserve">Creates a new #SoupServer.

This is exactly equivalent to calling [ctor@GObject.Object.new] and
specifying %SOUP_TYPE_SERVER as the type.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #SoupServer. If you are using
  certain legacy properties, this may also return %NULL if an error
  occurs.</doc>
          <type name="Server" c:type="SoupServer*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @optname1, followed by additional property/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="request_aborted">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_read">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="accept_iostream" c:identifier="soup_server_accept_iostream" throws="1">
        <doc xml:space="preserve">Adds a new client stream to the @server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if the stream could not be
  accepted or any other error occurred (in which case @error will be
  set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="local_addr" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the local #GSocketAddress associated with the
  @stream</doc>
            <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="remote_addr" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the remote #GSocketAddress associated with the
  @stream</doc>
            <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_auth_domain" c:identifier="soup_server_add_auth_domain">
        <doc xml:space="preserve">Adds an authentication domain to @server.

Each auth domain will have the chance to require authentication for each
request that comes in; normally auth domains will require authentication for
requests on certain paths that they have been set up to watch, or that meet
other criteria set by the caller. If an auth domain determines that a request
requires authentication (and the request doesn't contain authentication),
@server will automatically reject the request with an appropriate status (401
Unauthorized or 407 Proxy Authentication Required). If the request used the
SoupServer:100-continue Expectation, @server will reject it before the
request body is sent.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="auth_domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_early_handler" c:identifier="soup_server_add_early_handler">
        <doc xml:space="preserve">Adds an "early" handler to @server for requests prefixed by @path.

Note that "normal" and "early" handlers are matched up together, so if you
add a normal handler for "/foo" and an early handler for "/foo/bar", then a
request to "/foo/bar" (or any path below it) will run only the early handler.
(But if you add both handlers at the same path, then both will get run.)

For requests under @path (that have not already been assigned a
status code by a [class@AuthDomain] or a signal handler), @callback
will be invoked after receiving the request headers, but before
receiving the request body; the message's method and
request-headers properties will be set.

Early handlers are generally used for processing requests with request bodies
in a streaming fashion. If you determine that the request will contain a
message body, normally you would call [method@MessageBody.set_accumulate] on
the message's request-body to turn off request-body accumulation, and connect
to the message's [signal@ServerMessage::got-chunk] signal to process each
chunk as it comes in.

To complete the message processing after the full message body has
been read, you can either also connect to [signal@ServerMessage::got-body],
or else you can register a non-early handler for @path as well. As
long as you have not set the status-code by the time
[signal@ServerMessage::got-body] is emitted, the non-early handler will be
run as well.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3">
            <doc xml:space="preserve">callback to invoke for
  requests under @path</doc>
            <type name="ServerCallback" c:type="SoupServerCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler" c:identifier="soup_server_add_handler">
        <doc xml:space="preserve">Adds a handler to @server for requests prefixed by @path.

If @path is %NULL or "/", then this will be the default handler for all
requests that don't have a more specific handler. (Note though that if you
want to handle requests to the special "*" URI, you must explicitly register
a handler for "*"; the default handler will not be used for that case.)

For requests under @path (that have not already been assigned a
status code by a [class@AuthDomain], an early server handler, or a
signal handler), @callback will be invoked after receiving the
request body; the [class@ServerMessage]'s method, request-headers,
and request-body properties will be set.

After determining what to do with the request, the callback must at a minimum
call [method@ServerMessage.set_status] on the message to set the response
status code. Additionally, it may set response headers and/or fill in the
response body.

If the callback cannot fully fill in the response before returning
(eg, if it needs to wait for information from a database, or
another network server), it should call [method@ServerMessage.pause]
to tell @server to not send the response right away. When the
response is ready, call [method@ServerMessage.unpause] to cause it
to be sent.

To send the response body a bit at a time using "chunked" encoding, first
call [method@MessageHeaders.set_encoding] to set %SOUP_ENCODING_CHUNKED on
the response-headers. Then call [method@MessageBody.append] (or
[method@MessageBody.append_bytes])) to append each chunk as it becomes ready,
and [method@ServerMessage.unpause] to make sure it's running. (The server
will automatically pause the message if it is using chunked encoding but no
more chunks are available.) When you are done, call
[method@MessageBody.complete] to indicate that no more chunks are coming.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="2" destroy="3">
            <doc xml:space="preserve">callback to invoke for
  requests under @path</doc>
            <type name="ServerCallback" c:type="SoupServerCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_websocket_extension" c:identifier="soup_server_add_websocket_extension">
        <doc xml:space="preserve">Add support for a WebSocket extension of the given @extension_type.

When a WebSocket client requests an extension of @extension_type,
a new [class@WebsocketExtension] of type @extension_type will be created
to handle the request.

Note that [class@WebsocketExtensionDeflate] is supported by default, use
[method@Server.remove_websocket_extension] if you want to disable it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="extension_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_websocket_handler" c:identifier="soup_server_add_websocket_handler">
        <doc xml:space="preserve">Adds a WebSocket handler to @server for requests prefixed by @path.

If @path is %NULL or "/", then this will be the default handler for all
requests that don't have a more specific handler.

When a path has a WebSocket handler registered, @server will check
incoming requests for WebSocket handshakes after all other handlers
have run (unless some earlier handler has already set a status code
on the message), and update the request's status, response headers,
and response body accordingly.

If @origin is non-%NULL, then only requests containing a matching
"Origin" header will be accepted. If @protocols is non-%NULL, then
only requests containing a compatible "Sec-WebSocket-Protocols"
header will be accepted. More complicated requirements can be
handled by adding a normal handler to @path, and having it perform
whatever checks are needed and
setting a failure status code if the handshake should be rejected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the origin of the connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="protocols" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the protocols
  supported by this handler</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="callback" transfer-ownership="none" scope="notified" closure="4" destroy="5">
            <doc xml:space="preserve">callback to invoke for
  successful WebSocket requests under @path</doc>
            <type name="ServerWebsocketCallback" c:type="SoupServerWebsocketCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">destroy notifier to free @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="soup_server_disconnect">
        <doc xml:space="preserve">Closes and frees @server's listening sockets.

Note that if there are currently requests in progress on @server, that they
will continue to be processed if @server's [struct@GLib.MainContext] is still
running.

You can call [method@Server.listen], etc, after calling this function
if you want to start listening again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_listeners" c:identifier="soup_server_get_listeners">
        <doc xml:space="preserve">Gets @server's list of listening sockets.

You should treat these sockets as read-only; writing to or
modifiying any of these sockets may cause @server to malfunction.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a
  list of listening sockets.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Gio.Socket"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_auth_mode" c:identifier="soup_server_get_tls_auth_mode" glib:get-property="tls-auth-mode">
        <attribute name="org.gtk.Method.get_property" value="tls-auth-mode"/>
        <doc xml:space="preserve">Gets the @server SSL/TLS client authentication mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GTlsAuthenticationMode</doc>
          <type name="Gio.TlsAuthenticationMode" c:type="GTlsAuthenticationMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_certificate" c:identifier="soup_server_get_tls_certificate" glib:get-property="tls-certificate">
        <attribute name="org.gtk.Method.get_property" value="tls-certificate"/>
        <doc xml:space="preserve">Gets the @server SSL/TLS certificate.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GTlsCertificate or %NULL</doc>
          <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_database" c:identifier="soup_server_get_tls_database" glib:get-property="tls-database">
        <attribute name="org.gtk.Method.get_property" value="tls-database"/>
        <doc xml:space="preserve">Gets the @server SSL/TLS database.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GTlsDatabase</doc>
          <type name="Gio.TlsDatabase" c:type="GTlsDatabase*"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uris" c:identifier="soup_server_get_uris">
        <doc xml:space="preserve">Gets a list of URIs corresponding to the interfaces @server is
listening on.

These will contain IP addresses, not hostnames, and will also indicate
whether the given listener is http or https.

Note that if you used [method@Server.listen_all] the returned URIs will use
the addresses `0.0.0.0` and `::`, rather than actually returning separate
URIs for each interface on the system.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of #GUris, which you
  must free when you are done with it.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="GLib.Uri"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_https" c:identifier="soup_server_is_https">
        <doc xml:space="preserve">Checks whether @server is capable of https.

In order for a server to run https, you must call
[method@Server.set_tls_certificate], or set the
[property@Server:tls-certificate] property, to provide it with a
certificate to use.

If you are using the deprecated single-listener APIs, then a return value of
%TRUE indicates that the #SoupServer serves https exclusively. If you are
using [method@Server.listen], etc, then a %TRUE return value merely indicates
that the server is *able* to do https, regardless of whether it actually
currently is or not. Use [method@Server.get_uris] to see if it currently has
any https listeners.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @server is configured to serve https.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="listen" c:identifier="soup_server_listen" throws="1">
        <doc xml:space="preserve">Attempts to set up @server to listen for connections on @address.

If @options includes %SOUP_SERVER_LISTEN_HTTPS, and @server has
been configured for TLS, then @server will listen for https
connections on this port. Otherwise it will listen for plain http.

You may call this method (along with the other "listen" methods)
any number of times on a server, if you want to listen on multiple
ports, or set up both http and https service.

After calling this method, @server will begin accepting and processing
connections as soon as the appropriate [struct@GLib.MainContext] is run.

Note that this API does not make use of dual IPv4/IPv6 sockets; if
@address is an IPv6 address, it will only accept IPv6 connections.
You must configure IPv4 listening separately.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @address could not be
  bound or any other error occurred (in which case @error will be
  set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the address of the interface to listen on</doc>
            <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen_all" c:identifier="soup_server_listen_all" throws="1">
        <doc xml:space="preserve">Attempts to set up @server to listen for connections on all interfaces
on the system.

That is, it listens on the addresses `0.0.0.0` and/or `::`, depending on
whether @options includes %SOUP_SERVER_LISTEN_IPV4_ONLY,
%SOUP_SERVER_LISTEN_IPV6_ONLY, or neither.) If @port is specified, @server
will listen on that port. If it is 0, @server will find an unused port to
listen on. (In that case, you can use [method@Server.get_uris] to find out
what port it ended up choosing.

See [method@Server.listen] for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @port could not be bound
  or any other error occurred (in which case @error will be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port to listen on, or 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen_local" c:identifier="soup_server_listen_local" throws="1">
        <doc xml:space="preserve">Attempts to set up @server to listen for connections on "localhost".

That is, `127.0.0.1` and/or `::1`, depending on whether @options includes
%SOUP_SERVER_LISTEN_IPV4_ONLY, %SOUP_SERVER_LISTEN_IPV6_ONLY, or neither). If
@port is specified, @server will listen on that port. If it is 0, @server
will find an unused port to listen on. (In that case, you can use
[method@Server.get_uris] to find out what port it ended up choosing.

See [method@Server.listen] for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if @port could not be bound
  or any other error occurred (in which case @error will be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the port to listen on, or 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="listen_socket" c:identifier="soup_server_listen_socket" throws="1">
        <doc xml:space="preserve">Attempts to set up @server to listen for connections on @socket.

See [method@Server.listen] for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if an error occurred (in
  which case @error will be set).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="socket" transfer-ownership="none">
            <doc xml:space="preserve">a listening #GSocket</doc>
            <type name="Gio.Socket" c:type="GSocket*"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">listening options for this server</doc>
            <type name="ServerListenOptions" c:type="SoupServerListenOptions"/>
          </parameter>
        </parameters>
      </method>
      <method name="pause_message" c:identifier="soup_server_pause_message" deprecated="1" deprecated-version="3.2">
        <doc xml:space="preserve">Pauses I/O on @msg.

This can be used when you need to return from the server handler without
having the full response ready yet. Use [method@Server.unpause_message] to
resume I/O.

This must only be called on a [class@ServerMessage] which was created by the
#SoupServer and are currently doing I/O, such as those passed into a
[callback@ServerCallback] or emitted in a [signal@Server::request-read]
signal.</doc>
        <doc-deprecated xml:space="preserve">Use soup_server_message_pause() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage associated with @server.</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_auth_domain" c:identifier="soup_server_remove_auth_domain">
        <doc xml:space="preserve">Removes @auth_domain from @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="auth_domain" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupAuthDomain</doc>
            <type name="AuthDomain" c:type="SoupAuthDomain*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_handler" c:identifier="soup_server_remove_handler">
        <doc xml:space="preserve">Removes all handlers (early and normal) registered at @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the toplevel path for the handler</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_websocket_extension" c:identifier="soup_server_remove_websocket_extension">
        <doc xml:space="preserve">Removes support for WebSocket extension of type @extension_type (or any subclass of
@extension_type) from @server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="extension_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls_auth_mode" c:identifier="soup_server_set_tls_auth_mode" glib:set-property="tls-auth-mode">
        <attribute name="org.gtk.Method.set_property" value="tls-auth-mode"/>
        <doc xml:space="preserve">Sets @server's #GTlsAuthenticationMode to use for SSL/TLS client authentication.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsAuthenticationMode</doc>
            <type name="Gio.TlsAuthenticationMode" c:type="GTlsAuthenticationMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls_certificate" c:identifier="soup_server_set_tls_certificate" glib:set-property="tls-certificate">
        <attribute name="org.gtk.Method.set_property" value="tls-certificate"/>
        <doc xml:space="preserve">Sets @server up to do https, using the given SSL/TLS @certificate.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsCertificate</doc>
            <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls_database" c:identifier="soup_server_set_tls_database" glib:set-property="tls-database">
        <attribute name="org.gtk.Method.set_property" value="tls-database"/>
        <doc xml:space="preserve">Sets @server's #GTlsDatabase to use for validating SSL/TLS client certificates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="tls_database" transfer-ownership="none">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="Gio.TlsDatabase" c:type="GTlsDatabase*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpause_message" c:identifier="soup_server_unpause_message" deprecated="1" deprecated-version="3.2">
        <doc xml:space="preserve">Resumes I/O on @msg.

Use this to resume after calling [method@Server.pause_message], or after
adding a new chunk to a chunked response.

I/O won't actually resume until you return to the main loop.

This must only be called on a [class@ServerMessage] which was created by the
#SoupServer and are currently doing I/O, such as those passed into a
[callback@ServerCallback] or emitted in a [signal@Server::request-read]
signal.</doc>
        <doc-deprecated xml:space="preserve">Use soup_server_message_unpause() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="server" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServer</doc>
            <type name="Server" c:type="SoupServer*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage associated with @server.</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </parameter>
        </parameters>
      </method>
      <property name="raw-paths" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, percent-encoding in the Request-URI path will not be
automatically decoded.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="server-header" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">Server header.

If non-%NULL, the value to use for the "Server" header on
[class@ServerMessage]s processed by this server.

The Server header is the server equivalent of the
User-Agent header, and provides information about the
server and its components. It contains a list of one or
more product tokens, separated by whitespace, with the most
significant product token coming first. The tokens must be
brief, ASCII, and mostly alphanumeric (although "-", "_",
and "." are also allowed), and may optionally include a "/"
followed by a version string. You may also put comments,
enclosed in parentheses, between or after the tokens.

Some HTTP server implementations intentionally do not use
version numbers in their Server header, so that
installations running older versions of the server don't
end up advertising their vulnerability to specific security
holes.

As with [property@Session:user_agent], if you set a
[property@Server:server-header] property that has trailing
whitespace, #SoupServer will append its own product token (eg,
`libsoup/2.3.2`) to the end of the header for you.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="tls-auth-mode" writable="1" construct="1" transfer-ownership="none" setter="set_tls_auth_mode" getter="get_tls_auth_mode">
        <attribute name="org.gtk.Property.get" value="soup_server_get_tls_auth_mode"/>
        <attribute name="org.gtk.Property.set" value="soup_server_set_tls_auth_mode"/>
        <doc xml:space="preserve">A [enum@Gio.TlsAuthenticationMode] for SSL/TLS client authentication.</doc>
        <type name="Gio.TlsAuthenticationMode"/>
      </property>
      <property name="tls-certificate" writable="1" construct="1" transfer-ownership="none" setter="set_tls_certificate" getter="get_tls_certificate">
        <attribute name="org.gtk.Property.get" value="soup_server_get_tls_certificate"/>
        <attribute name="org.gtk.Property.set" value="soup_server_set_tls_certificate"/>
        <doc xml:space="preserve">A [class@Gio.TlsCertificate[] that has a
[property@Gio.TlsCertificate:private-key] set.

If this is set, then the server will be able to speak
https in addition to (or instead of) plain http.</doc>
        <type name="Gio.TlsCertificate"/>
      </property>
      <property name="tls-database" writable="1" construct="1" transfer-ownership="none" setter="set_tls_database" getter="get_tls_database">
        <attribute name="org.gtk.Property.get" value="soup_server_get_tls_database"/>
        <attribute name="org.gtk.Property.set" value="soup_server_set_tls_database"/>
        <doc xml:space="preserve">A [class@Gio.TlsDatabase] to use for validating SSL/TLS client
certificates.</doc>
        <type name="Gio.TlsDatabase"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="request-aborted" when="first">
        <doc xml:space="preserve">Emitted when processing has failed for a message.

This could mean either that it could not be read (if
[signal@Server::request-read] has not been emitted for it yet), or that
the response could not be written back (if [signal@Server::request-read]
has been emitted but [signal@Server::request-finished] has not been).

@message is in an undefined state when this signal is
emitted; the signal exists primarily to allow the server to
free any state that it may have allocated in
[signal@Server::request-started].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="ServerMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-finished" when="first">
        <doc xml:space="preserve">Emitted when the server has finished writing a response to
a request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="ServerMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-read" when="first">
        <doc xml:space="preserve">Emitted when the server has successfully read a request.

@message will have all of its request-side information
filled in, and if the message was authenticated, @client
will have information about that. This signal is emitted
before any (non-early) handlers are called for the message,
and if it sets the message's #status_code, then normal
handler processing will be skipped.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="ServerMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-started" when="first">
        <doc xml:space="preserve">Emitted when the server has started reading a new request.

@message will be completely blank; not even the
Request-Line will have been read yet. About the only thing
you can usefully do with it is connect to its signals.

If the request is read successfully, this will eventually
be followed by a [signal@Server::request_read signal]. If a
response is then sent, the request processing will end with
a [signal@Server::request-finished] signal. If a network error
occurs, the processing will instead end with
[signal@Server::request-aborted].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the new message</doc>
            <type name="ServerMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="ServerCallback" c:type="SoupServerCallback">
      <doc xml:space="preserve">A callback used to handle requests to a [class@Server].

@path and @query contain the likewise-named components of the
Request-URI, subject to certain assumptions. By default,
[class@Server] decodes all percent-encoding in the URI path, such that
`"/foo%2Fbar"` is treated the same as `"/foo/bar"`. If your
server is serving resources in some non-POSIX-filesystem namespace,
you may want to distinguish those as two distinct paths. In that
case, you can set the [property@Server:raw-paths] property when creating
the [class@Server], and it will leave those characters undecoded.

@query contains the query component of the Request-URI parsed according to
the rules for HTML form handling. Although this is the only commonly-used
query string format in HTTP, there is nothing that actually requires that
HTTP URIs use that format; if your server needs to use some other format, you
can just ignore @query, and call [method@Message.get_uri] and parse the URI's
query field yourself.

See [method@Server.add_handler] and [method@Server.add_early_handler]
for details of what handlers can/should do.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="server" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupServer</doc>
          <type name="Server" c:type="SoupServer*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the message being processed</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component of @msg's Request-URI</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the parsed query
  component of @msg's Request-URI</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
          <doc xml:space="preserve">the data passed to [method@Server.add_handler] or
  [method@Server.add_early_handler].</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ServerClass" c:type="SoupServerClass" glib:is-gtype-struct-for="Server">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="request_started">
        <callback name="request_started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="ServerMessage" c:type="SoupServerMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_read">
        <callback name="request_read">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="ServerMessage" c:type="SoupServerMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_finished">
        <callback name="request_finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="ServerMessage" c:type="SoupServerMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_aborted">
        <callback name="request_aborted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="server" transfer-ownership="none">
              <type name="Server" c:type="SoupServer*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="ServerMessage" c:type="SoupServerMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ServerListenOptions" glib:type-name="SoupServerListenOptions" glib:get-type="soup_server_listen_options_get_type" c:type="SoupServerListenOptions">
      <doc xml:space="preserve">Options to pass to [method@Server.listen], etc.

%SOUP_SERVER_LISTEN_IPV4_ONLY and %SOUP_SERVER_LISTEN_IPV6_ONLY
only make sense with [method@Server.listen_all] and
[method@Server.listen_local], not plain [method@Server.listen] (which
simply listens on whatever kind of socket you give it). And you
cannot specify both of them in a single call.</doc>
      <member name="https" value="1" c:identifier="SOUP_SERVER_LISTEN_HTTPS" glib:nick="https" glib:name="SOUP_SERVER_LISTEN_HTTPS">
        <doc xml:space="preserve">Listen for https connections rather
  than plain http.</doc>
      </member>
      <member name="ipv4_only" value="2" c:identifier="SOUP_SERVER_LISTEN_IPV4_ONLY" glib:nick="ipv4-only" glib:name="SOUP_SERVER_LISTEN_IPV4_ONLY">
        <doc xml:space="preserve">Only listen on IPv4 interfaces.</doc>
      </member>
      <member name="ipv6_only" value="4" c:identifier="SOUP_SERVER_LISTEN_IPV6_ONLY" glib:nick="ipv6-only" glib:name="SOUP_SERVER_LISTEN_IPV6_ONLY">
        <doc xml:space="preserve">Only listen on IPv6 interfaces.</doc>
      </member>
    </bitfield>
    <class name="ServerMessage" c:symbol-prefix="server_message" c:type="SoupServerMessage" parent="GObject.Object" final="1" glib:type-name="SoupServerMessage" glib:get-type="soup_server_message_get_type" glib:type-struct="ServerMessageClass">
      <doc xml:space="preserve">An HTTP server request and response pair.

A SoupServerMessage represents an HTTP message that is being sent or
received on a [class@Server].

[class@Server] will create `SoupServerMessage`s automatically for
incoming requests, which your application will receive via handlers.

Note that libsoup's terminology here does not quite match the HTTP
specification: in RFC 2616, an "HTTP-message" is *either* a Request, *or* a
Response. In libsoup, a #SoupServerMessage combines both the request and the
response.</doc>
      <method name="get_http_version" c:identifier="soup_server_message_get_http_version">
        <doc xml:space="preserve">Get the HTTP version of @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupHTTPVersion.</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_address" c:identifier="soup_server_message_get_local_address">
        <doc xml:space="preserve">Retrieves the [class@Gio.SocketAddress] associated with the local end
of a connection.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #GSocketAddress
  associated with the local end of a connection, it may be
  %NULL if you used [method@Server.accept_iostream].</doc>
          <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method" c:identifier="soup_server_message_get_method">
        <doc xml:space="preserve">Get the HTTP method of @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the HTTP method.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_reason_phrase" c:identifier="soup_server_message_get_reason_phrase">
        <doc xml:space="preserve">Get the HTTP reason phrase of @msg.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the reason phrase.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage:</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_address" c:identifier="soup_server_message_get_remote_address">
        <doc xml:space="preserve">Retrieves the [class@Gio.SocketAddress] associated with the remote end
of a connection.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #GSocketAddress
  associated with the remote end of a connection, it may be
  %NULL if you used [class@Server.accept_iostream].</doc>
          <type name="Gio.SocketAddress" c:type="GSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_host" c:identifier="soup_server_message_get_remote_host">
        <doc xml:space="preserve">Retrieves the IP address associated with the remote end of a
connection.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the IP address associated with the remote
  end of a connection, it may be %NULL if you used
  [method@Server.accept_iostream].</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_body" c:identifier="soup_server_message_get_request_body">
        <doc xml:space="preserve">Get the request body of @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessageBody.</doc>
          <type name="MessageBody" c:type="SoupMessageBody*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_request_headers" c:identifier="soup_server_message_get_request_headers">
        <doc xml:space="preserve">Get the request headers of @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessageHeaders with the request headers.</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_body" c:identifier="soup_server_message_get_response_body">
        <doc xml:space="preserve">Get the response body of @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessageBody.</doc>
          <type name="MessageBody" c:type="SoupMessageBody*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_headers" c:identifier="soup_server_message_get_response_headers">
        <doc xml:space="preserve">Get the response headers of @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessageHeaders with the response headers.</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_socket" c:identifier="soup_server_message_get_socket">
        <doc xml:space="preserve">Retrieves the [class@Gio.Socket] that @msg is associated with.

If you are using this method to observe when multiple requests are
made on the same persistent HTTP connection (eg, as the ntlm-test
test program does), you will need to pay attention to socket
destruction as well (eg, by using weak references), so that you do
not get fooled when the allocator reuses the memory address of a
previously-destroyed socket to represent a new socket.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #GSocket that @msg is
  associated with, %NULL if you used [method@Server.accept_iostream].</doc>
          <type name="Gio.Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status" c:identifier="soup_server_message_get_status">
        <doc xml:space="preserve">Get the HTTP status code of @msg.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the HTTP status code.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_peer_certificate" c:identifier="soup_server_message_get_tls_peer_certificate" glib:get-property="tls-peer-certificate" version="3.2">
        <doc xml:space="preserve">Gets the peer's #GTlsCertificate associated with @msg's connection.
Note that this is not set yet during the emission of
SoupServerMessage::accept-certificate signal.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">@msg's TLS peer certificate,
   or %NULL if @msg's connection is not SSL.</doc>
          <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_peer_certificate_errors" c:identifier="soup_server_message_get_tls_peer_certificate_errors" glib:get-property="tls-peer-certificate-errors" version="3.2">
        <doc xml:space="preserve">Gets the errors associated with validating @msg's TLS peer certificate.
Note that this is not set yet during the emission of
SoupServerMessage::accept-certificate signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GTlsCertificateFlags with @msg's TLS peer certificate errors.</doc>
          <type name="Gio.TlsCertificateFlags" c:type="GTlsCertificateFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri" c:identifier="soup_server_message_get_uri">
        <doc xml:space="preserve">Get @msg's URI.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GUri</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_options_ping" c:identifier="soup_server_message_is_options_ping">
        <doc xml:space="preserve">Gets if @msg represents an OPTIONS message with the path `*`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if is an OPTIONS ping</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pause" c:identifier="soup_server_message_pause" version="3.2">
        <doc xml:space="preserve">Pauses I/O on @msg.

This can be used when you need to return from the server handler without
having the full response ready yet. Use [method@ServerMessage.unpause] to
resume I/O.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_http_version" c:identifier="soup_server_message_set_http_version">
        <doc xml:space="preserve">Set the HTTP version of @msg.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupHTTPVersion</doc>
            <type name="HTTPVersion" c:type="SoupHTTPVersion"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_redirect" c:identifier="soup_server_message_set_redirect">
        <doc xml:space="preserve">Sets @msg's status_code to @status_code and adds a Location header
pointing to @redirect_uri. Use this from a [class@Server] when you
want to redirect the client to another URI.

@redirect_uri can be a relative URI, in which case it is
interpreted relative to @msg's current URI. In particular, if
@redirect_uri is just a path, it will replace the path
*and query* of @msg's URI.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">a 3xx status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="redirect_uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI to redirect @msg to</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_response" c:identifier="soup_server_message_set_response">
        <doc xml:space="preserve">Convenience function to set the response body of a #SoupServerMessage. If
@content_type is %NULL, the response body must be empty as well.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the message</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">MIME Content-Type of the body</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="resp_use" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMemoryUse describing how to handle @resp_body</doc>
            <type name="MemoryUse" c:type="SoupMemoryUse"/>
          </parameter>
          <parameter name="resp_body" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">
  a data buffer containing the body of the message response.</doc>
            <array length="3" zero-terminated="0" c:type="const char*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="resp_length" transfer-ownership="none">
            <doc xml:space="preserve">the byte length of @resp_body.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_status" c:identifier="soup_server_message_set_status">
        <doc xml:space="preserve">Sets @msg's status code to @status_code.

If @status_code is a known value and @reason_phrase is %NULL, the
reason_phrase will be set automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">an HTTP status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="reason_phrase" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a reason phrase</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_connection" c:identifier="soup_server_message_steal_connection">
        <doc xml:space="preserve">"Steals" the HTTP connection associated with @msg from its #SoupServer. This
happens immediately, regardless of the current state of the connection; if
the response to @msg has not yet finished being sent, then it will be
discarded; you can steal the connection from a
[signal@ServerMessage::wrote-informational] or
[signal@ServerMessage::wrote-body] signal handler if you need to wait for
part or all of the response to be sent.

Note that when calling this function from C, @msg will most
likely be freed as a side effect.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #GIOStream formerly associated
  with @msg (or %NULL if @msg was no longer associated with a
  connection). No guarantees are made about what kind of #GIOStream
  is returned.</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unpause" c:identifier="soup_server_message_unpause" version="3.2">
        <doc xml:space="preserve">Resumes I/O on @msg.

Use this to resume after calling [method@ServerMessage.pause], or after
adding a new chunk to a chunked response. I/O won't actually resume until you
return to the main loop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a SoupServerMessage</doc>
            <type name="ServerMessage" c:type="SoupServerMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="tls-peer-certificate" version="3.2" transfer-ownership="none" getter="get_tls_peer_certificate">
        <doc xml:space="preserve">The peer's #GTlsCertificate associated with the message</doc>
        <type name="Gio.TlsCertificate"/>
      </property>
      <property name="tls-peer-certificate-errors" version="3.2" transfer-ownership="none" getter="get_tls_peer_certificate_errors">
        <doc xml:space="preserve">The verification errors on #SoupServerMessage:tls-peer-certificate</doc>
        <type name="Gio.TlsCertificateFlags"/>
      </property>
      <glib:signal name="accept-certificate" when="last">
        <doc xml:space="preserve">Emitted during the @msg's connection TLS handshake
after client TLS certificate has been received.
You can return %TRUE to accept @tls_certificate despite
@tls_errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to accept the TLS certificate and stop other
  handlers from being invoked, or %FALSE to propagate the
  event further.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tls_peer_certificate" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="Gio.TlsCertificate"/>
          </parameter>
          <parameter name="tls_peer_errors" transfer-ownership="none">
            <doc xml:space="preserve">the tls errors of @tls_certificate</doc>
            <type name="Gio.TlsCertificateFlags"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="connected" when="last">
        <doc xml:space="preserve">Emitted when the @msg's socket is connected and the TLS handshake completed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="disconnected" when="last">
        <doc xml:space="preserve">Emitted when the @msg's socket is disconnected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="finished" when="last">
        <doc xml:space="preserve">Emitted when all HTTP processing is finished for a message.
(After [signal@ServerMessage::wrote-body]).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-body" when="last">
        <doc xml:space="preserve">Emitted after receiving the complete request body.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-chunk" when="first">
        <doc xml:space="preserve">Emitted after receiving a chunk of a message body.

Note that "chunk" in this context means any subpiece of the body, not
necessarily the specific HTTP 1.1 chunks sent by the other side.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chunk" transfer-ownership="none">
            <doc xml:space="preserve">the just-read chunk</doc>
            <type name="GLib.Bytes"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="got-headers" when="last">
        <doc xml:space="preserve">Emitted after receiving the Request-Line and request headers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-body" when="last">
        <doc xml:space="preserve">Emitted immediately after writing the complete response body for a
message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-body-data" when="last">
        <doc xml:space="preserve">Emitted immediately after writing a portion of the message
body to the network.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chunk_size" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="wrote-chunk" when="last">
        <doc xml:space="preserve">Emitted immediately after writing a body chunk for a message.

Note that this signal is not parallel to
[signal@ServerMessage::got-chunk]; it is emitted only when a complete
chunk (added with [method@MessageBody.append] or
[method@MessageBody.append_bytes] has been written. To get
more useful continuous progress information, use
[signal@ServerMessage::wrote-body-data].</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-headers" when="last">
        <doc xml:space="preserve">Emitted immediately after writing the response headers for a
message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="wrote-informational" when="last">
        <doc xml:space="preserve">Emitted immediately after writing a 1xx (Informational) response.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ServerMessageClass" c:type="SoupServerMessageClass" glib:is-gtype-struct-for="ServerMessage">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <callback name="ServerWebsocketCallback" c:type="SoupServerWebsocketCallback">
      <doc xml:space="preserve">A callback used to handle WebSocket requests to a #SoupServer.

The callback will be invoked after sending the handshake response back to the
client (and is only invoked if the handshake was successful).

@path contains the path of the Request-URI, subject to the same
rules as [callback@ServerCallback] `(qv)`.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="server" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupServer</doc>
          <type name="Server" c:type="SoupServer*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">the #SoupServerMessage</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path component of @msg's Request-URI</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:space="preserve">the newly created WebSocket connection</doc>
          <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="4">
          <doc xml:space="preserve">the data passed to @soup_server_add_handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Session" c:symbol-prefix="session" c:type="SoupSession" parent="GObject.Object" glib:type-name="SoupSession" glib:get-type="soup_session_get_type" glib:type-struct="SessionClass">
      <doc xml:space="preserve">Soup session state object.

#SoupSession is the object that controls client-side HTTP. A
#SoupSession encapsulates all of the state that libsoup is keeping
on behalf of your program; cached HTTP connections, authentication
information, etc. It also keeps track of various global options
and features that you are using.

Most applications will only need a single #SoupSession; the primary
reason you might need multiple sessions is if you need to have
multiple independent authentication contexts. (Eg, you are
connecting to a server and authenticating as two different users at
different times; the easiest way to ensure that each [class@Message]
is sent with the authentication information you intended is to use
one session for the first user, and a second session for the other
user.)

Additional #SoupSession functionality is provided by
[iface@SessionFeature] objects, which can be added to a session with
[method@Session.add_feature] or [method@Session.add_feature_by_type]
For example, [class@Logger] provides support for
logging HTTP traffic, [class@ContentDecoder] provides support for
compressed response handling, and [class@ContentSniffer] provides
support for HTML5-style response body content sniffing.
Additionally, subtypes of [class@Auth] can be added
as features, to add support for additional authentication types.

All `SoupSession`s are created with a [class@AuthManager], and support
for %SOUP_TYPE_AUTH_BASIC and %SOUP_TYPE_AUTH_DIGEST. Additionally,
sessions using the plain #SoupSession class (rather than one of its deprecated
subtypes) have a [class@ContentDecoder] by default.

Note that all async methods will invoke their callbacks on the thread-default
context at the time of the function call.</doc>
      <constructor name="new" c:identifier="soup_session_new">
        <doc xml:space="preserve">Creates a #SoupSession with the default options.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_options" c:identifier="soup_session_new_with_options" introspectable="0">
        <doc xml:space="preserve">Creates a #SoupSession with the specified options.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new session.</doc>
          <type name="Session" c:type="SoupSession*"/>
        </return-value>
        <parameters>
          <parameter name="optname1" transfer-ownership="none">
            <doc xml:space="preserve">name of first property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value of @optname1, followed by additional property/value pairs</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="request_queued">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_unqueued">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="abort" c:identifier="soup_session_abort">
        <doc xml:space="preserve">Cancels all pending requests in @session and closes all idle
persistent connections.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">the session</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_feature" c:identifier="soup_session_add_feature">
        <doc xml:space="preserve">Adds @feature's functionality to @session. You cannot add multiple
features of the same [alias@GLib.Type] to a session.

See the main #SoupSession documentation for information on what
features are present in sessions by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">an object that implements #SoupSessionFeature</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_feature_by_type" c:identifier="soup_session_add_feature_by_type">
        <doc xml:space="preserve">If @feature_type is the type of a class that implements
[iface@SessionFeature], this creates a new feature of that type and
adds it to @session as with [method@Session.add_feature]. You can use
this when you don't need to customize the new feature in any way.
Adding multiple features of the same @feature_type is not allowed.

If @feature_type is not a [iface@SessionFeature] type, this gives each
existing feature on @session the chance to accept @feature_type as
a "subfeature". This can be used to add new [class@Auth] types, for instance.

See the main #SoupSession documentation for information on what
features are present in sessions by default.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_accept_language" c:identifier="soup_session_get_accept_language" glib:get-property="accept-language">
        <attribute name="org.gtk.Method.get_property" value="accept-language"/>
        <doc xml:space="preserve">Get the value used by @session for the "Accept-Language" header on new
requests.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the accept language string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_accept_language_auto" c:identifier="soup_session_get_accept_language_auto" glib:get-property="accept-language-auto">
        <attribute name="org.gtk.Method.get_property" value="accept-language-auto"/>
        <doc xml:space="preserve">Gets whether @session automatically sets the "Accept-Language" header on new
requests.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @session sets "Accept-Language" header automatically, or
  %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_async_result_message" c:identifier="soup_session_get_async_result_message">
        <doc xml:space="preserve">Gets the [class@Message] of the @result asynchronous operation This is useful
to get the [class@Message] of an asynchronous operation started by @session
from its [callback@Gio.AsyncReadyCallback].</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupMessage or
  %NULL if @result is not a valid @session async operation result.</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature" c:identifier="soup_session_get_feature">
        <doc xml:space="preserve">Gets the feature in @session of type @feature_type.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupSessionFeature, or %NULL. The
  feature is owned by @session.</doc>
          <type name="SessionFeature" c:type="SoupSessionFeature*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the feature to get</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_for_message" c:identifier="soup_session_get_feature_for_message">
        <doc xml:space="preserve">Gets the feature in @session of type @feature_type, provided
that it is not disabled for @msg.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #SoupSessionFeature. The feature is
  owned by @session.</doc>
          <type name="SessionFeature" c:type="SoupSessionFeature*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the feature to get</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_idle_timeout" c:identifier="soup_session_get_idle_timeout" glib:get-property="idle-timeout">
        <attribute name="org.gtk.Method.get_property" value="idle-timeout"/>
        <doc xml:space="preserve">Get the timeout in seconds for idle connection lifetime currently used by
@session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the timeout in seconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_local_address" c:identifier="soup_session_get_local_address" glib:get-property="local-address">
        <attribute name="org.gtk.Method.get_property" value="local-address"/>
        <doc xml:space="preserve">Get the [class@Gio.InetSocketAddress] to use for the client side of
connections in @session.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GInetSocketAddress</doc>
          <type name="Gio.InetSocketAddress" c:type="GInetSocketAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_conns" c:identifier="soup_session_get_max_conns" glib:get-property="max-conns">
        <attribute name="org.gtk.Method.set_property" value="max-conns"/>
        <doc xml:space="preserve">Get the maximum number of connections that @session can open at once.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of connections</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_conns_per_host" c:identifier="soup_session_get_max_conns_per_host" glib:get-property="max-conns-per-host">
        <attribute name="org.gtk.Method.get_property" value="max-conns-per-host"/>
        <doc xml:space="preserve">Get the maximum number of connections that @session can open at once to a
given host.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum number of connections per host</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_proxy_resolver" c:identifier="soup_session_get_proxy_resolver" glib:get-property="proxy-resolver">
        <attribute name="org.gtk.Method.get_property" value="proxy-resolver"/>
        <doc xml:space="preserve">Get the [iface@Gio.ProxyResolver] currently used by @session.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GProxyResolver or %NULL if proxies
  are disabled in @session</doc>
          <type name="Gio.ProxyResolver" c:type="GProxyResolver*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remote_connectable" c:identifier="soup_session_get_remote_connectable" glib:get-property="remote-connectable">
        <attribute name="org.gtk.Method.get_property" value="remote-connectable"/>
        <doc xml:space="preserve">Gets the remote connectable if one set.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the #GSocketConnectable</doc>
          <type name="Gio.SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timeout" c:identifier="soup_session_get_timeout" glib:get-property="timeout">
        <attribute name="org.gtk.Method.get_property" value="timeout"/>
        <doc xml:space="preserve">Get the timeout in seconds for socket I/O operations currently used by
@session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the timeout in seconds</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_database" c:identifier="soup_session_get_tls_database" glib:get-property="tls-database">
        <attribute name="org.gtk.Method.get_property" value="tls-database"/>
        <doc xml:space="preserve">Get the [class@Gio.TlsDatabase] currently used by @session.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GTlsDatabase</doc>
          <type name="Gio.TlsDatabase" c:type="GTlsDatabase*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tls_interaction" c:identifier="soup_session_get_tls_interaction" glib:get-property="tls-interaction">
        <attribute name="org.gtk.Method.get_property" value="tls-interaction"/>
        <doc xml:space="preserve">Get the [class@Gio.TlsInteraction] currently used by @session.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GTlsInteraction</doc>
          <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_agent" c:identifier="soup_session_get_user_agent" glib:get-property="user-agent">
        <attribute name="org.gtk.Method.get_property" value="user-agent"/>
        <doc xml:space="preserve">Get the value used by @session for the "User-Agent" header on new requests.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the user agent string</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_feature" c:identifier="soup_session_has_feature">
        <doc xml:space="preserve">Tests if @session has at a feature of type @feature_type (which can
be the type of either a [iface@SessionFeature], or else a subtype of
some class managed by another feature, such as [class@Auth]).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the class of features to check for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="preconnect_async" c:identifier="soup_session_preconnect_async">
        <doc xml:space="preserve">Start a preconnection to @msg.

Once the connection is done, it will remain in idle state so that it can be
reused by future requests. If there's already an idle connection for the
given @msg host, the operation finishes successfully without creating a new
connection. If a new request for the given @msg host is made while the
preconnect is still ongoing, the request will take the ownership of the
connection and the preconnect operation will finish successfully (if there's
a connection error it will be handled by the request).

The operation finishes when the connection is done or an error occurred.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">the callback to invoke when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @progress_callback and @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="preconnect_finish" c:identifier="soup_session_preconnect_finish" throws="1">
        <doc xml:space="preserve">Complete a preconnect async operation started with [method@Session.preconnect_async].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the preconnect succeeded, or %FALSE in case of error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feature" c:identifier="soup_session_remove_feature">
        <doc xml:space="preserve">Removes @feature's functionality from @session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve">a feature that has previously been added to @session</doc>
            <type name="SessionFeature" c:type="SoupSessionFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feature_by_type" c:identifier="soup_session_remove_feature_by_type">
        <doc xml:space="preserve">Removes all features of type @feature_type (or any subclass of
@feature_type) from @session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="feature_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GType</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="soup_session_send" throws="1">
        <doc xml:space="preserve">Synchronously sends @msg and waits for the beginning of a response.

On success, a [class@Gio.InputStream] will be returned which you can use to
read the response body. ("Success" here means only that an HTTP
response was received and understood; it does not necessarily mean
that a 2xx class status code was received.)

If non-%NULL, @cancellable can be used to cancel the request;
[method@Session.send] will return a %G_IO_ERROR_CANCELLED error. Note that
with requests that have side effects (eg, `POST`, `PUT`, `DELETE`) it is
possible that you might cancel the request after the server acts on it, but
before it returns a response, leaving the remote resource in an unknown
state.

If @msg is requeued due to a redirect or authentication, the
initial (`3xx/401/407`) response body will be suppressed, and
[method@Session.send] will only return once a final response has been
received.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream for reading the
  response body, or %NULL on error.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_and_read" c:identifier="soup_session_send_and_read" throws="1">
        <doc xml:space="preserve">Synchronously sends @msg and reads the response body.

On success, a [struct@GLib.Bytes] will be returned with the response body.
This function should only be used when the resource to be retrieved
is not too long and can be stored in memory.

See [method@Session.send] for more details on the general semantics.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes, or %NULL on error.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_and_read_async" c:identifier="soup_session_send_and_read_async">
        <doc xml:space="preserve">Asynchronously sends @msg and reads the response body.

When @callback is called, then either @msg has been sent, and its response
body read, or else an error has occurred. This function should only be used
when the resource to be retrieved is not too long and can be stored in
memory. Call [method@Session.send_and_read_finish] to get a
[struct@GLib.Bytes] with the response body.

See [method@Session.send] for more details on the general semantics.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">the callback to invoke</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_and_read_finish" c:identifier="soup_session_send_and_read_finish" throws="1">
        <doc xml:space="preserve">Gets the response to a [method@Session.send_and_read_async].

If successful, returns a [struct@GLib.Bytes] with the response body.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes, or %NULL on error.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_and_splice" c:identifier="soup_session_send_and_splice" version="3.4" throws="1">
        <doc xml:space="preserve">Synchronously sends @msg and splices the response body stream into @out_stream.

See [method@Session.send] for more details on the general semantics.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize containing the size of the data spliced, or -1 if an error occurred.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="out_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags</doc>
            <type name="Gio.OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_and_splice_async" c:identifier="soup_session_send_and_splice_async" version="3.4">
        <doc xml:space="preserve">Asynchronously sends @msg and splices the response body stream into @out_stream.
When @callback is called, then either @msg has been sent and its response body
spliced, or else an error has occurred.

See [method@Session.send] for more details on the general semantics.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="out_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #GOutputStreamSpliceFlags</doc>
            <type name="Gio.OutputStreamSpliceFlags" c:type="GOutputStreamSpliceFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">the callback to invoke</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_and_splice_finish" c:identifier="soup_session_send_and_splice_finish" version="3.4" throws="1">
        <doc xml:space="preserve">Gets the response to a [method@Session.send_and_splice_async].</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #gssize containing the size of the data spliced, or -1 if an error occurred.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_async" c:identifier="soup_session_send_async">
        <doc xml:space="preserve">Asynchronously sends @msg and waits for the beginning of a response.

When @callback is called, then either @msg has been sent, and its response
headers received, or else an error has occurred. Call
[method@Session.send_finish] to get a [class@Gio.InputStream] for reading the
response body.

See [method@Session.send] for more details on the general semantics.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupMessage</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">the callback to invoke</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_finish" c:identifier="soup_session_send_finish" throws="1">
        <doc xml:space="preserve">Gets the response to a [method@Session.send_async] call.

If successful returns a [class@Gio.InputStream] that can be used to read the
response body.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GInputStream for reading the
  response body, or %NULL on error.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_accept_language" c:identifier="soup_session_set_accept_language" glib:set-property="accept-language">
        <attribute name="org.gtk.Method.set_property" value="accept-language"/>
        <doc xml:space="preserve">Set the value to use for the "Accept-Language" header on [class@Message]s
sent from @session.

If @accept_language is %NULL then no "Accept-Language" will be included in
requests. See [property@Session:accept-language] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="accept_language" transfer-ownership="none">
            <doc xml:space="preserve">the languages string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_accept_language_auto" c:identifier="soup_session_set_accept_language_auto" glib:set-property="accept-language-auto">
        <attribute name="org.gtk.Method.set_property" value="accept-language-auto"/>
        <doc xml:space="preserve">Set whether @session will automatically set the "Accept-Language" header on
requests using a value generated from system languages based on
[func@GLib.get_language_names].

See [property@Session:accept-language-auto] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="accept_language_auto" transfer-ownership="none">
            <doc xml:space="preserve">the value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_idle_timeout" c:identifier="soup_session_set_idle_timeout" glib:set-property="idle-timeout">
        <attribute name="org.gtk.Method.set_property" value="idle-timeout"/>
        <doc xml:space="preserve">Set a timeout in seconds for idle connection lifetime to be used by @session
on new connections.

See [property@Session:idle-timeout] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">a timeout in seconds</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_proxy_resolver" c:identifier="soup_session_set_proxy_resolver" glib:set-property="proxy-resolver">
        <attribute name="org.gtk.Method.set_property" value="proxy-resolver"/>
        <doc xml:space="preserve">Set a [iface@Gio.ProxyResolver] to be used by @session on new connections.

If @proxy_resolver is %NULL then no proxies will be used. See
[property@Session:proxy-resolver] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="proxy_resolver" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GProxyResolver or %NULL</doc>
            <type name="Gio.ProxyResolver" c:type="GProxyResolver*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timeout" c:identifier="soup_session_set_timeout" glib:set-property="timeout">
        <attribute name="org.gtk.Method.set_property" value="timeout"/>
        <doc xml:space="preserve">Set a timeout in seconds for socket I/O operations to be used by @session
on new connections.

See [property@Session:timeout] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">a timeout in seconds</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls_database" c:identifier="soup_session_set_tls_database" glib:set-property="tls-database">
        <attribute name="org.gtk.Method.set_property" value="tls-database"/>
        <doc xml:space="preserve">Set a [class@GIo.TlsDatabase] to be used by @session on new connections.

If @tls_database is %NULL then certificate validation will always fail. See
[property@Session:tls-database] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="tls_database" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GTlsDatabase</doc>
            <type name="Gio.TlsDatabase" c:type="GTlsDatabase*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tls_interaction" c:identifier="soup_session_set_tls_interaction" glib:set-property="tls-interaction">
        <attribute name="org.gtk.Method.set_property" value="tls-interaction"/>
        <doc xml:space="preserve">Set a [class@Gio.TlsInteraction] to be used by @session on new connections.

If @tls_interaction is %NULL then client certificate validation will always
fail.

See [property@Session:tls-interaction] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="tls_interaction" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GTlsInteraction</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_agent" c:identifier="soup_session_set_user_agent" glib:set-property="user-agent">
        <attribute name="org.gtk.Method.set_property" value="user-agent"/>
        <doc xml:space="preserve">Set the value to use for the "User-Agent" header on [class@Message]s sent
from @session.

If @user_agent has trailing whitespace, @session will append its own product
token (eg, `libsoup/3.0.0`) to the end of the header for you. If @user_agent
is %NULL then no "User-Agent" will be included in requests. See
[property@Session:user-agent] for more information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="user_agent" transfer-ownership="none">
            <doc xml:space="preserve">the user agent string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="websocket_connect_async" c:identifier="soup_session_websocket_connect_async">
        <doc xml:space="preserve">Asynchronously creates a [class@WebsocketConnection] to communicate with a
remote server.

All necessary WebSocket-related headers will be added to @msg, and
it will then be sent and asynchronously processed normally
(including handling of redirection and HTTP authentication).

If the server returns "101 Switching Protocols", then @msg's status
code and response headers will be updated, and then the WebSocket
handshake will be completed. On success,
[method@Session.websocket_connect_finish] will return a new
[class@WebsocketConnection]. On failure it will return a #GError.

If the server returns a status other than "101 Switching Protocols", then
@msg will contain the complete response headers and body from the server's
response, and [method@Session.websocket_connect_finish] will return
%SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">#SoupMessage indicating the WebSocket server to connect to</doc>
            <type name="Message" c:type="SoupMessage*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">origin of the connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="protocols" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a
  %NULL-terminated array of protocols supported</doc>
            <array c:type="char**">
              <type name="utf8" c:type="char*"/>
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="6">
            <doc xml:space="preserve">the callback to invoke</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="websocket_connect_finish" c:identifier="soup_session_websocket_connect_finish" throws="1">
        <doc xml:space="preserve">Gets the [class@WebsocketConnection] response to a
[method@Session.websocket_connect_async] call.

If successful, returns a [class@WebsocketConnection] that can be used to
communicate with the server.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupWebsocketConnection, or
  %NULL on error.</doc>
          <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupSession</doc>
            <type name="Session" c:type="SoupSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to your callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="accept-language" writable="1" transfer-ownership="none" setter="set_accept_language" getter="get_accept_language">
        <attribute name="org.gtk.Property.get" value="soup_session_get_accept_language"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_accept_language"/>
        <doc xml:space="preserve">If non-%NULL, the value to use for the "Accept-Language" header
on [class@Message]s sent from this session.

Setting this will disable [property@Session:accept-language-auto].</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="accept-language-auto" writable="1" transfer-ownership="none" setter="set_accept_language_auto" getter="get_accept_language_auto">
        <attribute name="org.gtk.Property.get" value="soup_session_get_accept_language_auto"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_accept_language_auto"/>
        <doc xml:space="preserve">If %TRUE, #SoupSession will automatically set the string
for the "Accept-Language" header on every [class@Message]
sent, based on the return value of [func@GLib.get_language_names].

Setting this will override any previous value of
[property@Session:accept-language].</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="idle-timeout" writable="1" transfer-ownership="none" setter="set_idle_timeout" getter="get_idle_timeout">
        <attribute name="org.gtk.Property.get" value="soup_session_get_idle_timeout"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_idle_timeout"/>
        <doc xml:space="preserve">Connection lifetime (in seconds) when idle. Any connection
left idle longer than this will be closed.

Although you can change this property at any time, it will
only affect newly-created connections, not currently-open
ones. You can call [method@Session.abort] after setting this
if you want to ensure that all future connections will have
this timeout value.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="local-address" writable="1" construct-only="1" transfer-ownership="none" getter="get_local_address">
        <attribute name="org.gtk.Property.get" value="soup_session_get_local_address"/>
        <doc xml:space="preserve">Sets the [class@Gio.InetSocketAddress] to use for the client side of
the connection.

Use this property if you want for instance to bind the
local socket to a specific IP address.</doc>
        <type name="Gio.InetSocketAddress"/>
      </property>
      <property name="max-conns" writable="1" construct-only="1" transfer-ownership="none" getter="get_max_conns">
        <attribute name="org.gtk.Property.get" value="soup_session_get_max_conns"/>
        <doc xml:space="preserve">The maximum number of connections that the session can open at once.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="max-conns-per-host" writable="1" construct-only="1" transfer-ownership="none" getter="get_max_conns_per_host">
        <attribute name="org.gtk.Property.get" value="soup_session_get_max_conns_per_host"/>
        <doc xml:space="preserve">The maximum number of connections that the session can open at once
to a given host.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="proxy-resolver" writable="1" transfer-ownership="none" setter="set_proxy_resolver" getter="get_proxy_resolver">
        <attribute name="org.gtk.Property.get" value="soup_session_get_proxy_resolver"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_proxy_resolver"/>
        <doc xml:space="preserve">A [iface@Gio.ProxyResolver] to use with this session.

If no proxy resolver is set, then the default proxy resolver
will be used. See [func@Gio.ProxyResolver.get_default].
You can set it to %NULL if you don't want to use proxies, or
set it to your own [iface@Gio.ProxyResolver] if you want to control
what proxies get used.</doc>
        <type name="Gio.ProxyResolver"/>
      </property>
      <property name="remote-connectable" writable="1" construct-only="1" transfer-ownership="none" getter="get_remote_connectable">
        <attribute name="org.gtk.Property.get" value="soup_session_get_remote_connectable"/>
        <doc xml:space="preserve">Sets a socket to make outgoing connections on. This will override the default
behaviour of opening TCP/IP sockets to the hosts specified in the URIs.

This function is not required for common HTTP usage, but only when connecting
to a HTTP service that is not using standard TCP/IP sockets. An example of
this is a local service that uses HTTP over UNIX-domain sockets, in that case
a [class@Gio.UnixSocketAddress] can be passed to this function.</doc>
        <type name="Gio.SocketConnectable"/>
      </property>
      <property name="timeout" writable="1" transfer-ownership="none" setter="set_timeout" getter="get_timeout">
        <attribute name="org.gtk.Property.get" value="soup_session_get_timeout"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_timeout"/>
        <doc xml:space="preserve">The timeout (in seconds) for socket I/O operations
(including connecting to a server, and waiting for a reply
to an HTTP request).

Although you can change this property at any time, it will
only affect newly-created connections, not currently-open
ones. You can call [method@Session.abort] after setting this
if you want to ensure that all future connections will have
this timeout value.

Not to be confused with [property@Session:idle-timeout] (which is
the length of time that idle persistent connections will be
kept open).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="tls-database" writable="1" transfer-ownership="none" setter="set_tls_database" getter="get_tls_database">
        <attribute name="org.gtk.Property.get" value="soup_session_get_tls_database"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_tls_database"/>
        <doc xml:space="preserve">Sets the [class@Gio.TlsDatabase] to use for validating SSL/TLS
certificates.

If no certificate database is set, then the default database will be
used. See [method@Gio.TlsBackend.get_default_database].</doc>
        <type name="Gio.TlsDatabase"/>
      </property>
      <property name="tls-interaction" writable="1" transfer-ownership="none" setter="set_tls_interaction" getter="get_tls_interaction">
        <attribute name="org.gtk.Property.get" value="soup_session_get_tls_interaction"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_tls_interaction"/>
        <doc xml:space="preserve">A [class@Gio.TlsInteraction] object that will be passed on to any
[class@Gio.TlsConnection]s created by the session.

This can be used to provide client-side certificates, for example.</doc>
        <type name="Gio.TlsInteraction"/>
      </property>
      <property name="user-agent" writable="1" transfer-ownership="none" setter="set_user_agent" getter="get_user_agent">
        <attribute name="org.gtk.Property.get" value="soup_session_get_user_agent"/>
        <attribute name="org.gtk.Property.set" value="soup_session_set_user_agent"/>
        <doc xml:space="preserve">User-Agent string.

If non-%NULL, the value to use for the "User-Agent" header
on [class@Message]s sent from this session.

RFC 2616 says: "The User-Agent request-header field
contains information about the user agent originating the
request. This is for statistical purposes, the tracing of
protocol violations, and automated recognition of user
agents for the sake of tailoring responses to avoid
particular user agent limitations. User agents SHOULD
include this field with requests."

The User-Agent header contains a list of one or more
product tokens, separated by whitespace, with the most
significant product token coming first. The tokens must be
brief, ASCII, and mostly alphanumeric (although "-", "_",
and "." are also allowed), and may optionally include a "/"
followed by a version string. You may also put comments,
enclosed in parentheses, between or after the tokens.

If you set a [property@Session:user-agent] property that has trailing
whitespace, #SoupSession will append its own product token
(eg, `libsoup/2.3.2`) to the end of the
header for you.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="request-queued" when="last">
        <doc xml:space="preserve">Emitted when a request is queued on @session.

When sending a request, first [signal@Session::request-queued]
is emitted, indicating that the session has become aware of
the request.

After a connection is available to send the request various
[class@Message] signals are emitted as the message is
processed. If the message is requeued, it will emit
[signal@Message::restarted], which will then be followed by other
[class@Message] signals when the message is re-sent.

Eventually, the message will emit [signal@Message::finished].
Normally, this signals the completion of message
processing. However, it is possible that the application
will requeue the message from the "finished" handler.
In that case the process will loop back.

Eventually, a message will reach "finished" and not be
requeued. At that point, the session will emit
[signal@Session::request-unqueued] to indicate that it is done
with the message.

To sum up: [signal@Session::request-queued] and
[signal@Session::request-unqueued] are guaranteed to be emitted
exactly once, but [signal@Message::finished] (and all of the other
[class@Message] signals) may be invoked multiple times for a given
message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the request that was queued</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-unqueued" when="last">
        <doc xml:space="preserve">Emitted when a request is removed from @session's queue,
indicating that @session is done with it.

See [signal@Session::request-queued] for a detailed description of
the message lifecycle within a session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">the request that was unqueued</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SessionClass" c:type="SoupSessionClass" glib:is-gtype-struct-for="Session">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="request_queued">
        <callback name="request_queued">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_unqueued">
        <callback name="request_unqueued">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="SoupSession*"/>
            </parameter>
            <parameter name="msg" transfer-ownership="none">
              <type name="Message" c:type="SoupMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_soup_reserved1" introspectable="0">
        <callback name="_soup_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_soup_reserved2" introspectable="0">
        <callback name="_soup_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_soup_reserved3" introspectable="0">
        <callback name="_soup_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_soup_reserved4" introspectable="0">
        <callback name="_soup_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_soup_reserved5" introspectable="0">
        <callback name="_soup_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_soup_reserved6" introspectable="0">
        <callback name="_soup_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_soup_reserved7" introspectable="0">
        <callback name="_soup_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_soup_reserved8" introspectable="0">
        <callback name="_soup_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SessionError" glib:type-name="SoupSessionError" glib:get-type="soup_session_error_get_type" c:type="SoupSessionError" glib:error-domain="soup-session-error-quark">
      <doc xml:space="preserve">A #SoupSession error.</doc>
      <member name="parsing" value="0" c:identifier="SOUP_SESSION_ERROR_PARSING" glib:nick="parsing" glib:name="SOUP_SESSION_ERROR_PARSING">
        <doc xml:space="preserve">the server's response could not
  be parsed</doc>
      </member>
      <member name="encoding" value="1" c:identifier="SOUP_SESSION_ERROR_ENCODING" glib:nick="encoding" glib:name="SOUP_SESSION_ERROR_ENCODING">
        <doc xml:space="preserve">the server's response was in an
  unsupported format</doc>
      </member>
      <member name="too_many_redirects" value="2" c:identifier="SOUP_SESSION_ERROR_TOO_MANY_REDIRECTS" glib:nick="too-many-redirects" glib:name="SOUP_SESSION_ERROR_TOO_MANY_REDIRECTS">
        <doc xml:space="preserve">the message has been redirected
  too many times</doc>
      </member>
      <member name="too_many_restarts" value="3" c:identifier="SOUP_SESSION_ERROR_TOO_MANY_RESTARTS" glib:nick="too-many-restarts" glib:name="SOUP_SESSION_ERROR_TOO_MANY_RESTARTS">
        <doc xml:space="preserve">the message has been restarted
  too many times</doc>
      </member>
      <member name="redirect_no_location" value="4" c:identifier="SOUP_SESSION_ERROR_REDIRECT_NO_LOCATION" glib:nick="redirect-no-location" glib:name="SOUP_SESSION_ERROR_REDIRECT_NO_LOCATION">
        <doc xml:space="preserve">failed to redirect message because
  Location header was missing or empty in response</doc>
      </member>
      <member name="redirect_bad_uri" value="5" c:identifier="SOUP_SESSION_ERROR_REDIRECT_BAD_URI" glib:nick="redirect-bad-uri" glib:name="SOUP_SESSION_ERROR_REDIRECT_BAD_URI">
        <doc xml:space="preserve">failed to redirect message because
  Location header contains an invalid URI</doc>
      </member>
      <member name="message_already_in_queue" value="6" c:identifier="SOUP_SESSION_ERROR_MESSAGE_ALREADY_IN_QUEUE" glib:nick="message-already-in-queue" glib:name="SOUP_SESSION_ERROR_MESSAGE_ALREADY_IN_QUEUE">
        <doc xml:space="preserve">the message is already in the
  session queue. Messages can only be reused after unqueued.</doc>
      </member>
      <function name="quark" c:identifier="soup_session_error_quark">
        <doc xml:space="preserve">Registers error quark for SoupSession if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Error quark for SoupSession.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <interface name="SessionFeature" c:symbol-prefix="session_feature" c:type="SoupSessionFeature" glib:type-name="SoupSessionFeature" glib:get-type="soup_session_feature_get_type" glib:type-struct="SessionFeatureInterface">
      <doc xml:space="preserve">Interface for miscellaneous [class@Session] features.

#SoupSessionFeature is the interface used by classes that extend
the functionality of a [class@Session]. Some features like HTTP
authentication handling are implemented internally via
`SoupSessionFeature`s. Other features can be added to the session
by the application. (Eg, [class@Logger], [class@CookieJar].)

See [method@Session.add_feature], etc, to add a feature to a session.</doc>
    </interface>
    <record name="SessionFeatureInterface" c:type="SoupSessionFeatureInterface" disguised="1" glib:is-gtype-struct-for="SessionFeature">
      <doc xml:space="preserve">The interface implemented by [iface@SessionFeature]s.</doc>
    </record>
    <enumeration name="Status" glib:type-name="SoupStatus" glib:get-type="soup_status_get_type" c:type="SoupStatus">
      <doc xml:space="preserve">These represent the known HTTP status code values, plus various
network and internal errors.

Note that no libsoup functions take or return this type directly;
any function that works with status codes will accept unrecognized
status codes as well.</doc>
      <member name="none" value="0" c:identifier="SOUP_STATUS_NONE" glib:nick="none" glib:name="SOUP_STATUS_NONE">
        <doc xml:space="preserve">No status available. (Eg, the message has not
been sent yet)</doc>
      </member>
      <member name="continue" value="100" c:identifier="SOUP_STATUS_CONTINUE" glib:nick="continue" glib:name="SOUP_STATUS_CONTINUE">
        <doc xml:space="preserve">100 Continue (HTTP)</doc>
      </member>
      <member name="switching_protocols" value="101" c:identifier="SOUP_STATUS_SWITCHING_PROTOCOLS" glib:nick="switching-protocols" glib:name="SOUP_STATUS_SWITCHING_PROTOCOLS">
        <doc xml:space="preserve">101 Switching Protocols (HTTP)</doc>
      </member>
      <member name="processing" value="102" c:identifier="SOUP_STATUS_PROCESSING" glib:nick="processing" glib:name="SOUP_STATUS_PROCESSING">
        <doc xml:space="preserve">102 Processing (WebDAV)</doc>
      </member>
      <member name="ok" value="200" c:identifier="SOUP_STATUS_OK" glib:nick="ok" glib:name="SOUP_STATUS_OK">
        <doc xml:space="preserve">200 Success (HTTP). Also used by many lower-level
soup routines to indicate success.</doc>
      </member>
      <member name="created" value="201" c:identifier="SOUP_STATUS_CREATED" glib:nick="created" glib:name="SOUP_STATUS_CREATED">
        <doc xml:space="preserve">201 Created (HTTP)</doc>
      </member>
      <member name="accepted" value="202" c:identifier="SOUP_STATUS_ACCEPTED" glib:nick="accepted" glib:name="SOUP_STATUS_ACCEPTED">
        <doc xml:space="preserve">202 Accepted (HTTP)</doc>
      </member>
      <member name="non_authoritative" value="203" c:identifier="SOUP_STATUS_NON_AUTHORITATIVE" glib:nick="non-authoritative" glib:name="SOUP_STATUS_NON_AUTHORITATIVE">
        <doc xml:space="preserve">203 Non-Authoritative Information
(HTTP)</doc>
      </member>
      <member name="no_content" value="204" c:identifier="SOUP_STATUS_NO_CONTENT" glib:nick="no-content" glib:name="SOUP_STATUS_NO_CONTENT">
        <doc xml:space="preserve">204 No Content (HTTP)</doc>
      </member>
      <member name="reset_content" value="205" c:identifier="SOUP_STATUS_RESET_CONTENT" glib:nick="reset-content" glib:name="SOUP_STATUS_RESET_CONTENT">
        <doc xml:space="preserve">205 Reset Content (HTTP)</doc>
      </member>
      <member name="partial_content" value="206" c:identifier="SOUP_STATUS_PARTIAL_CONTENT" glib:nick="partial-content" glib:name="SOUP_STATUS_PARTIAL_CONTENT">
        <doc xml:space="preserve">206 Partial Content (HTTP)</doc>
      </member>
      <member name="multi_status" value="207" c:identifier="SOUP_STATUS_MULTI_STATUS" glib:nick="multi-status" glib:name="SOUP_STATUS_MULTI_STATUS">
        <doc xml:space="preserve">207 Multi-Status (WebDAV)</doc>
      </member>
      <member name="multiple_choices" value="300" c:identifier="SOUP_STATUS_MULTIPLE_CHOICES" glib:nick="multiple-choices" glib:name="SOUP_STATUS_MULTIPLE_CHOICES">
        <doc xml:space="preserve">300 Multiple Choices (HTTP)</doc>
      </member>
      <member name="moved_permanently" value="301" c:identifier="SOUP_STATUS_MOVED_PERMANENTLY" glib:nick="moved-permanently" glib:name="SOUP_STATUS_MOVED_PERMANENTLY">
        <doc xml:space="preserve">301 Moved Permanently (HTTP)</doc>
      </member>
      <member name="found" value="302" c:identifier="SOUP_STATUS_FOUND" glib:nick="found" glib:name="SOUP_STATUS_FOUND">
        <doc xml:space="preserve">302 Found (HTTP)</doc>
      </member>
      <member name="moved_temporarily" value="302" c:identifier="SOUP_STATUS_MOVED_TEMPORARILY" glib:nick="moved-temporarily" glib:name="SOUP_STATUS_MOVED_TEMPORARILY">
        <doc xml:space="preserve">302 Moved Temporarily (old name,
RFC 2068)</doc>
      </member>
      <member name="see_other" value="303" c:identifier="SOUP_STATUS_SEE_OTHER" glib:nick="see-other" glib:name="SOUP_STATUS_SEE_OTHER">
        <doc xml:space="preserve">303 See Other (HTTP)</doc>
      </member>
      <member name="not_modified" value="304" c:identifier="SOUP_STATUS_NOT_MODIFIED" glib:nick="not-modified" glib:name="SOUP_STATUS_NOT_MODIFIED">
        <doc xml:space="preserve">304 Not Modified (HTTP)</doc>
      </member>
      <member name="use_proxy" value="305" c:identifier="SOUP_STATUS_USE_PROXY" glib:nick="use-proxy" glib:name="SOUP_STATUS_USE_PROXY">
        <doc xml:space="preserve">305 Use Proxy (HTTP)</doc>
      </member>
      <member name="not_appearing_in_this_protocol" value="306" c:identifier="SOUP_STATUS_NOT_APPEARING_IN_THIS_PROTOCOL" glib:nick="not-appearing-in-this-protocol" glib:name="SOUP_STATUS_NOT_APPEARING_IN_THIS_PROTOCOL">
        <doc xml:space="preserve">306 [Unused] (HTTP)</doc>
      </member>
      <member name="temporary_redirect" value="307" c:identifier="SOUP_STATUS_TEMPORARY_REDIRECT" glib:nick="temporary-redirect" glib:name="SOUP_STATUS_TEMPORARY_REDIRECT">
        <doc xml:space="preserve">307 Temporary Redirect (HTTP)</doc>
      </member>
      <member name="permanent_redirect" value="308" c:identifier="SOUP_STATUS_PERMANENT_REDIRECT" glib:nick="permanent-redirect" glib:name="SOUP_STATUS_PERMANENT_REDIRECT">
        <doc xml:space="preserve">308 Permanent Redirect (HTTP)</doc>
      </member>
      <member name="bad_request" value="400" c:identifier="SOUP_STATUS_BAD_REQUEST" glib:nick="bad-request" glib:name="SOUP_STATUS_BAD_REQUEST">
        <doc xml:space="preserve">400 Bad Request (HTTP)</doc>
      </member>
      <member name="unauthorized" value="401" c:identifier="SOUP_STATUS_UNAUTHORIZED" glib:nick="unauthorized" glib:name="SOUP_STATUS_UNAUTHORIZED">
        <doc xml:space="preserve">401 Unauthorized (HTTP)</doc>
      </member>
      <member name="payment_required" value="402" c:identifier="SOUP_STATUS_PAYMENT_REQUIRED" glib:nick="payment-required" glib:name="SOUP_STATUS_PAYMENT_REQUIRED">
        <doc xml:space="preserve">402 Payment Required (HTTP)</doc>
      </member>
      <member name="forbidden" value="403" c:identifier="SOUP_STATUS_FORBIDDEN" glib:nick="forbidden" glib:name="SOUP_STATUS_FORBIDDEN">
        <doc xml:space="preserve">403 Forbidden (HTTP)</doc>
      </member>
      <member name="not_found" value="404" c:identifier="SOUP_STATUS_NOT_FOUND" glib:nick="not-found" glib:name="SOUP_STATUS_NOT_FOUND">
        <doc xml:space="preserve">404 Not Found (HTTP)</doc>
      </member>
      <member name="method_not_allowed" value="405" c:identifier="SOUP_STATUS_METHOD_NOT_ALLOWED" glib:nick="method-not-allowed" glib:name="SOUP_STATUS_METHOD_NOT_ALLOWED">
        <doc xml:space="preserve">405 Method Not Allowed (HTTP)</doc>
      </member>
      <member name="not_acceptable" value="406" c:identifier="SOUP_STATUS_NOT_ACCEPTABLE" glib:nick="not-acceptable" glib:name="SOUP_STATUS_NOT_ACCEPTABLE">
        <doc xml:space="preserve">406 Not Acceptable (HTTP)</doc>
      </member>
      <member name="proxy_authentication_required" value="407" c:identifier="SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED" glib:nick="proxy-authentication-required" glib:name="SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED">
        <doc xml:space="preserve">407 Proxy Authentication
Required (HTTP)</doc>
      </member>
      <member name="proxy_unauthorized" value="407" c:identifier="SOUP_STATUS_PROXY_UNAUTHORIZED" glib:nick="proxy-unauthorized" glib:name="SOUP_STATUS_PROXY_UNAUTHORIZED">
        <doc xml:space="preserve">shorter alias for
%SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED</doc>
      </member>
      <member name="request_timeout" value="408" c:identifier="SOUP_STATUS_REQUEST_TIMEOUT" glib:nick="request-timeout" glib:name="SOUP_STATUS_REQUEST_TIMEOUT">
        <doc xml:space="preserve">408 Request Timeout (HTTP)</doc>
      </member>
      <member name="conflict" value="409" c:identifier="SOUP_STATUS_CONFLICT" glib:nick="conflict" glib:name="SOUP_STATUS_CONFLICT">
        <doc xml:space="preserve">409 Conflict (HTTP)</doc>
      </member>
      <member name="gone" value="410" c:identifier="SOUP_STATUS_GONE" glib:nick="gone" glib:name="SOUP_STATUS_GONE">
        <doc xml:space="preserve">410 Gone (HTTP)</doc>
      </member>
      <member name="length_required" value="411" c:identifier="SOUP_STATUS_LENGTH_REQUIRED" glib:nick="length-required" glib:name="SOUP_STATUS_LENGTH_REQUIRED">
        <doc xml:space="preserve">411 Length Required (HTTP)</doc>
      </member>
      <member name="precondition_failed" value="412" c:identifier="SOUP_STATUS_PRECONDITION_FAILED" glib:nick="precondition-failed" glib:name="SOUP_STATUS_PRECONDITION_FAILED">
        <doc xml:space="preserve">412 Precondition Failed (HTTP)</doc>
      </member>
      <member name="request_entity_too_large" value="413" c:identifier="SOUP_STATUS_REQUEST_ENTITY_TOO_LARGE" glib:nick="request-entity-too-large" glib:name="SOUP_STATUS_REQUEST_ENTITY_TOO_LARGE">
        <doc xml:space="preserve">413 Request Entity Too Large
(HTTP)</doc>
      </member>
      <member name="request_uri_too_long" value="414" c:identifier="SOUP_STATUS_REQUEST_URI_TOO_LONG" glib:nick="request-uri-too-long" glib:name="SOUP_STATUS_REQUEST_URI_TOO_LONG">
        <doc xml:space="preserve">414 Request-URI Too Long (HTTP)</doc>
      </member>
      <member name="unsupported_media_type" value="415" c:identifier="SOUP_STATUS_UNSUPPORTED_MEDIA_TYPE" glib:nick="unsupported-media-type" glib:name="SOUP_STATUS_UNSUPPORTED_MEDIA_TYPE">
        <doc xml:space="preserve">415 Unsupported Media Type
(HTTP)</doc>
      </member>
      <member name="requested_range_not_satisfiable" value="416" c:identifier="SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE" glib:nick="requested-range-not-satisfiable" glib:name="SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE">
        <doc xml:space="preserve">416 Requested Range
Not Satisfiable (HTTP)</doc>
      </member>
      <member name="invalid_range" value="416" c:identifier="SOUP_STATUS_INVALID_RANGE" glib:nick="invalid-range" glib:name="SOUP_STATUS_INVALID_RANGE">
        <doc xml:space="preserve">shorter alias for
%SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE</doc>
      </member>
      <member name="expectation_failed" value="417" c:identifier="SOUP_STATUS_EXPECTATION_FAILED" glib:nick="expectation-failed" glib:name="SOUP_STATUS_EXPECTATION_FAILED">
        <doc xml:space="preserve">417 Expectation Failed (HTTP)</doc>
      </member>
      <member name="misdirected_request" value="421" c:identifier="SOUP_STATUS_MISDIRECTED_REQUEST" glib:nick="misdirected-request" glib:name="SOUP_STATUS_MISDIRECTED_REQUEST">
        <doc xml:space="preserve">421 Misdirected Request</doc>
      </member>
      <member name="unprocessable_entity" value="422" c:identifier="SOUP_STATUS_UNPROCESSABLE_ENTITY" glib:nick="unprocessable-entity" glib:name="SOUP_STATUS_UNPROCESSABLE_ENTITY">
        <doc xml:space="preserve">422 Unprocessable Entity
(WebDAV)</doc>
      </member>
      <member name="locked" value="423" c:identifier="SOUP_STATUS_LOCKED" glib:nick="locked" glib:name="SOUP_STATUS_LOCKED">
        <doc xml:space="preserve">423 Locked (WebDAV)</doc>
      </member>
      <member name="failed_dependency" value="424" c:identifier="SOUP_STATUS_FAILED_DEPENDENCY" glib:nick="failed-dependency" glib:name="SOUP_STATUS_FAILED_DEPENDENCY">
        <doc xml:space="preserve">424 Failed Dependency (WebDAV)</doc>
      </member>
      <member name="internal_server_error" value="500" c:identifier="SOUP_STATUS_INTERNAL_SERVER_ERROR" glib:nick="internal-server-error" glib:name="SOUP_STATUS_INTERNAL_SERVER_ERROR">
        <doc xml:space="preserve">500 Internal Server Error
(HTTP)</doc>
      </member>
      <member name="not_implemented" value="501" c:identifier="SOUP_STATUS_NOT_IMPLEMENTED" glib:nick="not-implemented" glib:name="SOUP_STATUS_NOT_IMPLEMENTED">
        <doc xml:space="preserve">501 Not Implemented (HTTP)</doc>
      </member>
      <member name="bad_gateway" value="502" c:identifier="SOUP_STATUS_BAD_GATEWAY" glib:nick="bad-gateway" glib:name="SOUP_STATUS_BAD_GATEWAY">
        <doc xml:space="preserve">502 Bad Gateway (HTTP)</doc>
      </member>
      <member name="service_unavailable" value="503" c:identifier="SOUP_STATUS_SERVICE_UNAVAILABLE" glib:nick="service-unavailable" glib:name="SOUP_STATUS_SERVICE_UNAVAILABLE">
        <doc xml:space="preserve">503 Service Unavailable (HTTP)</doc>
      </member>
      <member name="gateway_timeout" value="504" c:identifier="SOUP_STATUS_GATEWAY_TIMEOUT" glib:nick="gateway-timeout" glib:name="SOUP_STATUS_GATEWAY_TIMEOUT">
        <doc xml:space="preserve">504 Gateway Timeout (HTTP)</doc>
      </member>
      <member name="http_version_not_supported" value="505" c:identifier="SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED" glib:nick="http-version-not-supported" glib:name="SOUP_STATUS_HTTP_VERSION_NOT_SUPPORTED">
        <doc xml:space="preserve">505 HTTP Version Not
Supported (HTTP)</doc>
      </member>
      <member name="insufficient_storage" value="507" c:identifier="SOUP_STATUS_INSUFFICIENT_STORAGE" glib:nick="insufficient-storage" glib:name="SOUP_STATUS_INSUFFICIENT_STORAGE">
        <doc xml:space="preserve">507 Insufficient Storage
(WebDAV)</doc>
      </member>
      <member name="not_extended" value="510" c:identifier="SOUP_STATUS_NOT_EXTENDED" glib:nick="not-extended" glib:name="SOUP_STATUS_NOT_EXTENDED">
        <doc xml:space="preserve">510 Not Extended (RFC 2774)</doc>
      </member>
      <function name="get_phrase" c:identifier="soup_status_get_phrase">
        <doc xml:space="preserve">Looks up the stock HTTP description of @status_code.

*There is no reason for you to ever use this
function.* If you wanted the textual description for the
[property@Message:status-code] of a given [class@Message], you should just
look at the message's [property@Message:reason-phrase]. However, you
should only do that for use in debugging messages; HTTP reason
phrases are not localized, and are not generally very descriptive
anyway, and so they should never be presented to the user directly.
Instead, you should create you own error messages based on the
status code, and on what you were trying to do.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the (terse, English) description of @status_code</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="status_code" transfer-ownership="none">
            <doc xml:space="preserve">an HTTP status code</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <enumeration name="TLDError" glib:type-name="SoupTLDError" glib:get-type="soup_tld_error_get_type" c:type="SoupTLDError" glib:error-domain="soup-tld-error-quark">
      <doc xml:space="preserve">Error codes for %SOUP_TLD_ERROR.</doc>
      <member name="invalid_hostname" value="0" c:identifier="SOUP_TLD_ERROR_INVALID_HOSTNAME" glib:nick="invalid-hostname" glib:name="SOUP_TLD_ERROR_INVALID_HOSTNAME">
        <doc xml:space="preserve">A hostname was syntactically
  invalid.</doc>
      </member>
      <member name="is_ip_address" value="1" c:identifier="SOUP_TLD_ERROR_IS_IP_ADDRESS" glib:nick="is-ip-address" glib:name="SOUP_TLD_ERROR_IS_IP_ADDRESS">
        <doc xml:space="preserve">The passed-in "hostname" was
  actually an IP address (and thus has no base domain or
  public suffix).</doc>
      </member>
      <member name="not_enough_domains" value="2" c:identifier="SOUP_TLD_ERROR_NOT_ENOUGH_DOMAINS" glib:nick="not-enough-domains" glib:name="SOUP_TLD_ERROR_NOT_ENOUGH_DOMAINS">
        <doc xml:space="preserve">The passed-in hostname
  did not have enough components. Eg, calling
  [func@tld_get_base_domain] on &lt;literal&gt;"co.uk"&lt;/literal&gt;.</doc>
      </member>
      <member name="no_base_domain" value="3" c:identifier="SOUP_TLD_ERROR_NO_BASE_DOMAIN" glib:nick="no-base-domain" glib:name="SOUP_TLD_ERROR_NO_BASE_DOMAIN">
        <doc xml:space="preserve">The passed-in hostname has
  no recognized public suffix.</doc>
      </member>
      <member name="no_psl_data" value="4" c:identifier="SOUP_TLD_ERROR_NO_PSL_DATA" glib:nick="no-psl-data" glib:name="SOUP_TLD_ERROR_NO_PSL_DATA">
        <doc xml:space="preserve">The Public Suffix List was not
  available.</doc>
      </member>
      <function name="quark" c:identifier="soup_tld_error_quark">
        <doc xml:space="preserve">Registers error quark for soup_tld_get_base_domain() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Error quark for Soup TLD functions.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <function-macro name="UNAVAILABLE" c:identifier="SOUP_UNAVAILABLE" introspectable="0">
      <doc xml:space="preserve">Marks a symbol unavailable before the given major and minor version.

You should use `SOUP_AVAILABLE_IN_*` in order to handle versioning.</doc>
      <parameters>
        <parameter name="maj">
          <doc xml:space="preserve">the major version that introduced the symbol</doc>
        </parameter>
        <parameter name="min">
          <doc xml:space="preserve">the minor version that introduced the symbol</doc>
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="URIComponent" glib:type-name="SoupURIComponent" glib:get-type="soup_uri_component_get_type" c:type="SoupURIComponent">
      <doc xml:space="preserve">Enum values passed to [func@uri_copy] to indicate the components of
the URI that should be updated with the given values.</doc>
      <member name="none" value="0" c:identifier="SOUP_URI_NONE" glib:nick="none" glib:name="SOUP_URI_NONE">
        <doc xml:space="preserve">no component</doc>
      </member>
      <member name="scheme" value="1" c:identifier="SOUP_URI_SCHEME" glib:nick="scheme" glib:name="SOUP_URI_SCHEME">
        <doc xml:space="preserve">the URI scheme component</doc>
      </member>
      <member name="user" value="2" c:identifier="SOUP_URI_USER" glib:nick="user" glib:name="SOUP_URI_USER">
        <doc xml:space="preserve">the URI user component</doc>
      </member>
      <member name="password" value="3" c:identifier="SOUP_URI_PASSWORD" glib:nick="password" glib:name="SOUP_URI_PASSWORD">
        <doc xml:space="preserve">the URI password component</doc>
      </member>
      <member name="auth_params" value="4" c:identifier="SOUP_URI_AUTH_PARAMS" glib:nick="auth-params" glib:name="SOUP_URI_AUTH_PARAMS">
        <doc xml:space="preserve">the URI authentication parameters component</doc>
      </member>
      <member name="host" value="5" c:identifier="SOUP_URI_HOST" glib:nick="host" glib:name="SOUP_URI_HOST">
        <doc xml:space="preserve">the URI host component</doc>
      </member>
      <member name="port" value="6" c:identifier="SOUP_URI_PORT" glib:nick="port" glib:name="SOUP_URI_PORT">
        <doc xml:space="preserve">the URI port component</doc>
      </member>
      <member name="path" value="7" c:identifier="SOUP_URI_PATH" glib:nick="path" glib:name="SOUP_URI_PATH">
        <doc xml:space="preserve">the URI path component</doc>
      </member>
      <member name="query" value="8" c:identifier="SOUP_URI_QUERY" glib:nick="query" glib:name="SOUP_URI_QUERY">
        <doc xml:space="preserve">the URI query component</doc>
      </member>
      <member name="fragment" value="9" c:identifier="SOUP_URI_FRAGMENT" glib:nick="fragment" glib:name="SOUP_URI_FRAGMENT">
        <doc xml:space="preserve">the URI fragment component</doc>
      </member>
    </enumeration>
    <constant name="VERSION_MIN_REQUIRED" value="2" c:type="SOUP_VERSION_MIN_REQUIRED">
      <doc xml:space="preserve">A macro that should be defined by the user prior to including
`libsoup.h`.

The definition should be one of the predefined libsoup
version macros: %SOUP_VERSION_2_24, %SOUP_VERSION_2_26, ...

This macro defines the earliest version of libsoup that the package
is required to be able to compile against.

If the compiler is configured to warn about the use of deprecated
functions, then using functions that were deprecated in version
%SOUP_VERSION_MIN_REQUIRED or earlier will cause warnings (but
using functions deprecated in later releases will not).</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="WebsocketCloseCode" glib:type-name="SoupWebsocketCloseCode" glib:get-type="soup_websocket_close_code_get_type" c:type="SoupWebsocketCloseCode">
      <doc xml:space="preserve">Pre-defined close codes that can be passed to
[method@WebsocketConnection.close] or received from
[method@WebsocketConnection.get_close_code].

However, other codes are also allowed.</doc>
      <member name="normal" value="1000" c:identifier="SOUP_WEBSOCKET_CLOSE_NORMAL" glib:nick="normal" glib:name="SOUP_WEBSOCKET_CLOSE_NORMAL">
        <doc xml:space="preserve">a normal, non-error close</doc>
      </member>
      <member name="going_away" value="1001" c:identifier="SOUP_WEBSOCKET_CLOSE_GOING_AWAY" glib:nick="going-away" glib:name="SOUP_WEBSOCKET_CLOSE_GOING_AWAY">
        <doc xml:space="preserve">the client/server is going away</doc>
      </member>
      <member name="protocol_error" value="1002" c:identifier="SOUP_WEBSOCKET_CLOSE_PROTOCOL_ERROR" glib:nick="protocol-error" glib:name="SOUP_WEBSOCKET_CLOSE_PROTOCOL_ERROR">
        <doc xml:space="preserve">a protocol error occurred</doc>
      </member>
      <member name="unsupported_data" value="1003" c:identifier="SOUP_WEBSOCKET_CLOSE_UNSUPPORTED_DATA" glib:nick="unsupported-data" glib:name="SOUP_WEBSOCKET_CLOSE_UNSUPPORTED_DATA">
        <doc xml:space="preserve">the endpoint received data
  of a type that it does not support.</doc>
      </member>
      <member name="no_status" value="1005" c:identifier="SOUP_WEBSOCKET_CLOSE_NO_STATUS" glib:nick="no-status" glib:name="SOUP_WEBSOCKET_CLOSE_NO_STATUS">
        <doc xml:space="preserve">reserved value indicating that
  no close code was present; must not be sent.</doc>
      </member>
      <member name="abnormal" value="1006" c:identifier="SOUP_WEBSOCKET_CLOSE_ABNORMAL" glib:nick="abnormal" glib:name="SOUP_WEBSOCKET_CLOSE_ABNORMAL">
        <doc xml:space="preserve">reserved value indicating that
  the connection was closed abnormally; must not be sent.</doc>
      </member>
      <member name="bad_data" value="1007" c:identifier="SOUP_WEBSOCKET_CLOSE_BAD_DATA" glib:nick="bad-data" glib:name="SOUP_WEBSOCKET_CLOSE_BAD_DATA">
        <doc xml:space="preserve">the endpoint received data that
  was invalid (eg, non-UTF-8 data in a text message).</doc>
      </member>
      <member name="policy_violation" value="1008" c:identifier="SOUP_WEBSOCKET_CLOSE_POLICY_VIOLATION" glib:nick="policy-violation" glib:name="SOUP_WEBSOCKET_CLOSE_POLICY_VIOLATION">
        <doc xml:space="preserve">generic error code
  indicating some sort of policy violation.</doc>
      </member>
      <member name="too_big" value="1009" c:identifier="SOUP_WEBSOCKET_CLOSE_TOO_BIG" glib:nick="too-big" glib:name="SOUP_WEBSOCKET_CLOSE_TOO_BIG">
        <doc xml:space="preserve">the endpoint received a message
  that is too big to process.</doc>
      </member>
      <member name="no_extension" value="1010" c:identifier="SOUP_WEBSOCKET_CLOSE_NO_EXTENSION" glib:nick="no-extension" glib:name="SOUP_WEBSOCKET_CLOSE_NO_EXTENSION">
        <doc xml:space="preserve">the client is closing the
  connection because the server failed to negotiate a required
  extension.</doc>
      </member>
      <member name="server_error" value="1011" c:identifier="SOUP_WEBSOCKET_CLOSE_SERVER_ERROR" glib:nick="server-error" glib:name="SOUP_WEBSOCKET_CLOSE_SERVER_ERROR">
        <doc xml:space="preserve">the server is closing the
  connection because it was unable to fulfill the request.</doc>
      </member>
      <member name="tls_handshake" value="1015" c:identifier="SOUP_WEBSOCKET_CLOSE_TLS_HANDSHAKE" glib:nick="tls-handshake" glib:name="SOUP_WEBSOCKET_CLOSE_TLS_HANDSHAKE">
        <doc xml:space="preserve">reserved value indicating that
  the TLS handshake failed; must not be sent.</doc>
      </member>
    </enumeration>
    <class name="WebsocketConnection" c:symbol-prefix="websocket_connection" c:type="SoupWebsocketConnection" parent="GObject.Object" final="1" glib:type-name="SoupWebsocketConnection" glib:get-type="soup_websocket_connection_get_type" glib:type-struct="WebsocketConnectionClass">
      <doc xml:space="preserve">The WebSocket Protocol

Provides support for the [WebSocket](http://tools.ietf.org/html/rfc6455)
protocol.

To connect to a WebSocket server, create a [class@Session] and call
[method@Session.websocket_connect_async]. To accept WebSocket
connections, create a [class@Server] and add a handler to it with
[method@Server.add_websocket_handler].

(Lower-level support is available via
[func@websocket_client_prepare_handshake] and
[func@websocket_client_verify_handshake], for handling the client side of the
WebSocket handshake, and [func@websocket_server_process_handshake] for
handling the server side.)

#SoupWebsocketConnection handles the details of WebSocket communication. You
can use [method@WebsocketConnection.send_text] and
[method@WebsocketConnection.send_binary] to send data, and the
[signal@WebsocketConnection::message] signal to receive data.
(#SoupWebsocketConnection currently only supports asynchronous I/O.)</doc>
      <constructor name="new" c:identifier="soup_websocket_connection_new">
        <doc xml:space="preserve">Creates a #SoupWebsocketConnection on @stream with the given active @extensions.

This should be called after completing the handshake to begin using the WebSocket
protocol.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #SoupWebsocketConnection</doc>
          <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream connected to the WebSocket server</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">the URI of the connection</doc>
            <type name="GLib.Uri" c:type="GUri*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of connection (client/side)</doc>
            <type name="WebsocketConnectionType" c:type="SoupWebsocketConnectionType"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the Origin of the client</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the subprotocol in use</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="extensions" transfer-ownership="full">
            <doc xml:space="preserve">a #GList of #SoupWebsocketExtension objects</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="WebsocketExtension"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <method name="close" c:identifier="soup_websocket_connection_close">
        <doc xml:space="preserve">Close the connection in an orderly fashion.

Note that until the [signal@WebsocketConnection::closed] signal fires, the connection
is not yet completely closed. The close message is not even sent until the
main loop runs.

The @code and @data are sent to the peer along with the close request.
If @code is %SOUP_WEBSOCKET_CLOSE_NO_STATUS a close message with no body
(without code and data) is sent.
Note that the @data must be UTF-8 valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:space="preserve">close code</doc>
            <type name="gushort" c:type="gushort"/>
          </parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">close data</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_close_code" c:identifier="soup_websocket_connection_get_close_code">
        <doc xml:space="preserve">Get the close code received from the WebSocket peer.

This only becomes valid once the WebSocket is in the
%SOUP_WEBSOCKET_STATE_CLOSED state. The value will often be in the
[enum@WebsocketCloseCode] enumeration, but may also be an application
defined close code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the close code or zero.</doc>
          <type name="gushort" c:type="gushort"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_close_data" c:identifier="soup_websocket_connection_get_close_data">
        <doc xml:space="preserve">Get the close data received from the WebSocket peer.

This only becomes valid once the WebSocket is in the
%SOUP_WEBSOCKET_STATE_CLOSED state. The data may be freed once
the main loop is run, so copy it if you need to keep it around.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the close data or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type" c:identifier="soup_websocket_connection_get_connection_type" glib:get-property="connection-type">
        <doc xml:space="preserve">Get the connection type (client/server) of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection type</doc>
          <type name="WebsocketConnectionType" c:type="SoupWebsocketConnectionType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extensions" c:identifier="soup_websocket_connection_get_extensions" glib:get-property="extensions">
        <doc xml:space="preserve">Get the extensions chosen via negotiation with the peer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #SoupWebsocketExtension objects</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="WebsocketExtension"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_io_stream" c:identifier="soup_websocket_connection_get_io_stream" glib:get-property="io-stream">
        <doc xml:space="preserve">Get the I/O stream the WebSocket is communicating over.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WebSocket's I/O stream.</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_keepalive_interval" c:identifier="soup_websocket_connection_get_keepalive_interval" glib:get-property="keepalive-interval">
        <doc xml:space="preserve">Gets the keepalive interval in seconds or 0 if disabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the keepalive interval.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_incoming_payload_size" c:identifier="soup_websocket_connection_get_max_incoming_payload_size" glib:get-property="max-incoming-payload-size">
        <doc xml:space="preserve">Gets the maximum payload size allowed for incoming packets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum payload size.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_origin" c:identifier="soup_websocket_connection_get_origin" glib:get-property="origin">
        <doc xml:space="preserve">Get the origin of the WebSocket.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the origin</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="soup_websocket_connection_get_protocol" glib:get-property="protocol">
        <doc xml:space="preserve">Get the protocol chosen via negotiation with the peer.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the chosen protocol</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_state" c:identifier="soup_websocket_connection_get_state" glib:get-property="state">
        <doc xml:space="preserve">Get the current state of the WebSocket.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the state</doc>
          <type name="WebsocketState" c:type="SoupWebsocketState"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uri" c:identifier="soup_websocket_connection_get_uri" glib:get-property="uri">
        <doc xml:space="preserve">Get the URI of the WebSocket.

For servers this represents the address of the WebSocket, and
for clients it is the address connected to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URI</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="send_binary" c:identifier="soup_websocket_connection_send_binary">
        <doc xml:space="preserve">Send a binary message to the peer.

If @length is 0, @data may be %NULL.

The message is queued to be sent and will be sent when the main loop
is run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the message contents</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message" c:identifier="soup_websocket_connection_send_message">
        <doc xml:space="preserve">Send a message of the given @type to the peer. Note that this method,
allows to send text messages containing %NULL characters.

The message is queued to be sent and will be sent when the main loop
is run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of message contents</doc>
            <type name="WebsocketDataType" c:type="SoupWebsocketDataType"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message data as #GBytes</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_text" c:identifier="soup_websocket_connection_send_text">
        <doc xml:space="preserve">Send a %NULL-terminated text (UTF-8) message to the peer.

If you need to send text messages containing %NULL characters use
[method@WebsocketConnection.send_message] instead.

The message is queued to be sent and will be sent when the main loop
is run.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">the message contents</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_keepalive_interval" c:identifier="soup_websocket_connection_set_keepalive_interval" glib:set-property="keepalive-interval">
        <doc xml:space="preserve">Sets the interval in seconds on when to send a ping message which will serve
as a keepalive message.

If set to 0 the keepalive message is disabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:space="preserve">the interval to send a ping message or 0 to disable it</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_incoming_payload_size" c:identifier="soup_websocket_connection_set_max_incoming_payload_size" glib:set-property="max-incoming-payload-size">
        <doc xml:space="preserve">Sets the maximum payload size allowed for incoming packets.

It does not limit the outgoing packet size.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the WebSocket</doc>
            <type name="WebsocketConnection" c:type="SoupWebsocketConnection*"/>
          </instance-parameter>
          <parameter name="max_incoming_payload_size" transfer-ownership="none">
            <doc xml:space="preserve">the maximum payload size</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <property name="connection-type" writable="1" construct-only="1" transfer-ownership="none" getter="get_connection_type">
        <doc xml:space="preserve">The type of connection (client/server).</doc>
        <type name="WebsocketConnectionType"/>
      </property>
      <property name="extensions" writable="1" construct-only="1" transfer-ownership="none" getter="get_extensions">
        <doc xml:space="preserve">List of [class@WebsocketExtension] objects that are active in the connection.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="io-stream" writable="1" construct-only="1" transfer-ownership="none" getter="get_io_stream">
        <doc xml:space="preserve">The underlying IO stream the WebSocket is communicating
over.

The input and output streams must be pollable streams.</doc>
        <type name="Gio.IOStream"/>
      </property>
      <property name="keepalive-interval" writable="1" construct="1" transfer-ownership="none" setter="set_keepalive_interval" getter="get_keepalive_interval">
        <doc xml:space="preserve">Interval in seconds on when to send a ping message which will
serve as a keepalive message.

If set to 0 the keepalive message is disabled.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="max-incoming-payload-size" writable="1" construct="1" transfer-ownership="none" setter="set_max_incoming_payload_size" getter="get_max_incoming_payload_size">
        <doc xml:space="preserve">The maximum payload size for incoming packets.

The protocol expects or 0 to not limit it.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="origin" writable="1" construct-only="1" transfer-ownership="none" getter="get_origin">
        <doc xml:space="preserve">The client's Origin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="protocol" writable="1" construct-only="1" transfer-ownership="none" getter="get_protocol">
        <doc xml:space="preserve">The chosen protocol, or %NULL if a protocol was not agreed
upon.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="state" transfer-ownership="none" getter="get_state">
        <doc xml:space="preserve">The current state of the WebSocket.</doc>
        <type name="WebsocketState"/>
      </property>
      <property name="uri" writable="1" construct-only="1" transfer-ownership="none" getter="get_uri">
        <doc xml:space="preserve">The URI of the WebSocket.

For servers this represents the address of the WebSocket,
and for clients it is the address connected to.</doc>
        <type name="GLib.Uri"/>
      </property>
      <glib:signal name="closed" when="first">
        <doc xml:space="preserve">Emitted when the connection has completely closed.

This happens either due to an orderly close from the peer, one
initiated via [method@WebsocketConnection.close] or a fatal error
condition that caused a close.

This signal will be emitted once.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="closing" when="last">
        <doc xml:space="preserve">This signal will be emitted during an orderly close.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="error" when="first">
        <doc xml:space="preserve">Emitted when an error occurred on the WebSocket.

This may be fired multiple times. Fatal errors will be followed by
the [signal@WebsocketConnection::closed] signal being emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">the error that occured</doc>
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="message" when="first">
        <doc xml:space="preserve">Emitted when we receive a message from the peer.

As a convenience, the @message data will always be
%NULL-terminated, but the NUL byte will not be included in
the length count.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of message contents</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message data</doc>
            <type name="GLib.Bytes"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="pong" when="first">
        <doc xml:space="preserve">Emitted when we receive a Pong frame (solicited or
unsolicited) from the peer.

As a convenience, the @message data will always be
%NULL-terminated, but the NUL byte will not be included in
the length count.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the application data (if any)</doc>
            <type name="GLib.Bytes"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="WebsocketConnectionClass" c:type="SoupWebsocketConnectionClass" glib:is-gtype-struct-for="WebsocketConnection">
      <doc xml:space="preserve">The abstract base class for [class@WebsocketConnection].</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="WebsocketConnectionType" glib:type-name="SoupWebsocketConnectionType" glib:get-type="soup_websocket_connection_type_get_type" c:type="SoupWebsocketConnectionType">
      <doc xml:space="preserve">The type of a [class@WebsocketConnection].</doc>
      <member name="unknown" value="0" c:identifier="SOUP_WEBSOCKET_CONNECTION_UNKNOWN" glib:nick="unknown" glib:name="SOUP_WEBSOCKET_CONNECTION_UNKNOWN">
        <doc xml:space="preserve">unknown/invalid connection</doc>
      </member>
      <member name="client" value="1" c:identifier="SOUP_WEBSOCKET_CONNECTION_CLIENT" glib:nick="client" glib:name="SOUP_WEBSOCKET_CONNECTION_CLIENT">
        <doc xml:space="preserve">a client-side connection</doc>
      </member>
      <member name="server" value="2" c:identifier="SOUP_WEBSOCKET_CONNECTION_SERVER" glib:nick="server" glib:name="SOUP_WEBSOCKET_CONNECTION_SERVER">
        <doc xml:space="preserve">a server-side connection</doc>
      </member>
    </enumeration>
    <enumeration name="WebsocketDataType" glib:type-name="SoupWebsocketDataType" glib:get-type="soup_websocket_data_type_get_type" c:type="SoupWebsocketDataType">
      <doc xml:space="preserve">The type of data contained in a [signal@WebsocketConnection::message] signal.</doc>
      <member name="text" value="1" c:identifier="SOUP_WEBSOCKET_DATA_TEXT" glib:nick="text" glib:name="SOUP_WEBSOCKET_DATA_TEXT">
        <doc xml:space="preserve">UTF-8 text</doc>
      </member>
      <member name="binary" value="2" c:identifier="SOUP_WEBSOCKET_DATA_BINARY" glib:nick="binary" glib:name="SOUP_WEBSOCKET_DATA_BINARY">
        <doc xml:space="preserve">binary data</doc>
      </member>
    </enumeration>
    <enumeration name="WebsocketError" glib:type-name="SoupWebsocketError" glib:get-type="soup_websocket_error_get_type" c:type="SoupWebsocketError" glib:error-domain="soup-websocket-error-quark">
      <doc xml:space="preserve">WebSocket-related errors.</doc>
      <member name="failed" value="0" c:identifier="SOUP_WEBSOCKET_ERROR_FAILED" glib:nick="failed" glib:name="SOUP_WEBSOCKET_ERROR_FAILED">
        <doc xml:space="preserve">a generic error</doc>
      </member>
      <member name="not_websocket" value="1" c:identifier="SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET" glib:nick="not-websocket" glib:name="SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET">
        <doc xml:space="preserve">attempted to handshake with a
  server that does not appear to understand WebSockets.</doc>
      </member>
      <member name="bad_handshake" value="2" c:identifier="SOUP_WEBSOCKET_ERROR_BAD_HANDSHAKE" glib:nick="bad-handshake" glib:name="SOUP_WEBSOCKET_ERROR_BAD_HANDSHAKE">
        <doc xml:space="preserve">the WebSocket handshake failed
  because some detail was invalid (eg, incorrect accept key).</doc>
      </member>
      <member name="bad_origin" value="3" c:identifier="SOUP_WEBSOCKET_ERROR_BAD_ORIGIN" glib:nick="bad-origin" glib:name="SOUP_WEBSOCKET_ERROR_BAD_ORIGIN">
        <doc xml:space="preserve">the WebSocket handshake failed
  because the "Origin" header was not an allowed value.</doc>
      </member>
      <function name="quark" c:identifier="soup_websocket_error_quark">
        <doc xml:space="preserve">Registers error quark for SoupWebsocket if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Error quark for SoupWebsocket.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="WebsocketExtension" c:symbol-prefix="websocket_extension" c:type="SoupWebsocketExtension" parent="GObject.Object" abstract="1" glib:type-name="SoupWebsocketExtension" glib:get-type="soup_websocket_extension_get_type" glib:type-struct="WebsocketExtensionClass">
      <doc xml:space="preserve">A WebSocket extension

#SoupWebsocketExtension is the base class for WebSocket extension objects.</doc>
      <virtual-method name="configure" invoker="configure" throws="1">
        <doc xml:space="preserve">Configures @extension with the given @params.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if extension could be configured with the given parameters, or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
          <parameter name="connection_type" transfer-ownership="none">
            <doc xml:space="preserve">either %SOUP_WEBSOCKET_CONNECTION_CLIENT or %SOUP_WEBSOCKET_CONNECTION_SERVER</doc>
            <type name="WebsocketConnectionType" c:type="SoupWebsocketConnectionType"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parameters</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_request_params" invoker="get_request_params">
        <doc xml:space="preserve">Get the parameters strings to be included in the request header.

If the extension doesn't include any parameter in the request, this function
returns %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new allocated string with the parameters</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_response_params" invoker="get_response_params">
        <doc xml:space="preserve">Get the parameters strings to be included in the response header.

If the extension doesn't include any parameter in the response, this function
returns %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new allocated string with the parameters</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="process_incoming_message" invoker="process_incoming_message" throws="1">
        <doc xml:space="preserve">Process a message after it's received.

If the payload isn't changed the given @payload is just returned, otherwise
[method@GLib.Bytes.unref] is called on the given @payload and a new
[struct@GLib.Bytes] is returned with the new data.

Extensions using reserved bits of the header will reset them in @header.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the message payload data, or %NULL in case of error</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
          <parameter name="header" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the message header</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="payload" transfer-ownership="full">
            <doc xml:space="preserve">the payload data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="process_outgoing_message" invoker="process_outgoing_message" throws="1">
        <doc xml:space="preserve">Process a message before it's sent.

If the payload isn't changed the given @payload is just returned, otherwise
[method@Glib.Bytes.unref] is called on the given @payload and a new
[struct@GLib.Bytes] is returned with the new data.

Extensions using reserved bits of the header will change them in @header.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the message payload data, or %NULL in case of error</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
          <parameter name="header" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the message header</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="payload" transfer-ownership="full">
            <doc xml:space="preserve">the payload data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="configure" c:identifier="soup_websocket_extension_configure" throws="1">
        <doc xml:space="preserve">Configures @extension with the given @params.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if extension could be configured with the given parameters, or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
          <parameter name="connection_type" transfer-ownership="none">
            <doc xml:space="preserve">either %SOUP_WEBSOCKET_CONNECTION_CLIENT or %SOUP_WEBSOCKET_CONNECTION_SERVER</doc>
            <type name="WebsocketConnectionType" c:type="SoupWebsocketConnectionType"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the parameters</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_request_params" c:identifier="soup_websocket_extension_get_request_params">
        <doc xml:space="preserve">Get the parameters strings to be included in the request header.

If the extension doesn't include any parameter in the request, this function
returns %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new allocated string with the parameters</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_response_params" c:identifier="soup_websocket_extension_get_response_params">
        <doc xml:space="preserve">Get the parameters strings to be included in the response header.

If the extension doesn't include any parameter in the response, this function
returns %NULL.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new allocated string with the parameters</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="process_incoming_message" c:identifier="soup_websocket_extension_process_incoming_message" throws="1">
        <doc xml:space="preserve">Process a message after it's received.

If the payload isn't changed the given @payload is just returned, otherwise
[method@GLib.Bytes.unref] is called on the given @payload and a new
[struct@GLib.Bytes] is returned with the new data.

Extensions using reserved bits of the header will reset them in @header.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the message payload data, or %NULL in case of error</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
          <parameter name="header" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the message header</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="payload" transfer-ownership="full">
            <doc xml:space="preserve">the payload data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="process_outgoing_message" c:identifier="soup_websocket_extension_process_outgoing_message" throws="1">
        <doc xml:space="preserve">Process a message before it's sent.

If the payload isn't changed the given @payload is just returned, otherwise
[method@Glib.Bytes.unref] is called on the given @payload and a new
[struct@GLib.Bytes] is returned with the new data.

Extensions using reserved bits of the header will change them in @header.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the message payload data, or %NULL in case of error</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
            <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
          </instance-parameter>
          <parameter name="header" direction="inout" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the message header</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="payload" transfer-ownership="full">
            <doc xml:space="preserve">the payload data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="WebsocketExtensionClass" c:type="SoupWebsocketExtensionClass" glib:is-gtype-struct-for="WebsocketExtension">
      <doc xml:space="preserve">The class structure for the #SoupWebsocketExtension.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="name">
        <doc xml:space="preserve">the name of the extension</doc>
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="configure">
        <callback name="configure" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if extension could be configured with the given parameters, or %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
              <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
            </parameter>
            <parameter name="connection_type" transfer-ownership="none">
              <doc xml:space="preserve">either %SOUP_WEBSOCKET_CONNECTION_CLIENT or %SOUP_WEBSOCKET_CONNECTION_SERVER</doc>
              <type name="WebsocketConnectionType" c:type="SoupWebsocketConnectionType"/>
            </parameter>
            <parameter name="params" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">the parameters</doc>
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_request_params">
        <callback name="get_request_params">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a new allocated string with the parameters</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
              <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_response_params">
        <callback name="get_response_params">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a new allocated string with the parameters</doc>
            <type name="utf8" c:type="char*"/>
          </return-value>
          <parameters>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
              <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="process_outgoing_message">
        <callback name="process_outgoing_message" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the message payload data, or %NULL in case of error</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </return-value>
          <parameters>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
              <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
            </parameter>
            <parameter name="header" direction="inout" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">the message header</doc>
              <type name="guint8" c:type="guint8*"/>
            </parameter>
            <parameter name="payload" transfer-ownership="full">
              <doc xml:space="preserve">the payload data</doc>
              <type name="GLib.Bytes" c:type="GBytes*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="process_incoming_message">
        <callback name="process_incoming_message" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the message payload data, or %NULL in case of error</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </return-value>
          <parameters>
            <parameter name="extension" transfer-ownership="none">
              <doc xml:space="preserve">a #SoupWebsocketExtension</doc>
              <type name="WebsocketExtension" c:type="SoupWebsocketExtension*"/>
            </parameter>
            <parameter name="header" direction="inout" caller-allocates="0" transfer-ownership="full">
              <doc xml:space="preserve">the message header</doc>
              <type name="guint8" c:type="guint8*"/>
            </parameter>
            <parameter name="payload" transfer-ownership="full">
              <doc xml:space="preserve">the payload data</doc>
              <type name="GLib.Bytes" c:type="GBytes*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="WebsocketExtensionDeflate" c:symbol-prefix="websocket_extension_deflate" c:type="SoupWebsocketExtensionDeflate" parent="WebsocketExtension" final="1" glib:type-name="SoupWebsocketExtensionDeflate" glib:get-type="soup_websocket_extension_deflate_get_type" glib:type-struct="WebsocketExtensionDeflateClass">
      <doc xml:space="preserve">A SoupWebsocketExtensionDeflate is a [class@WebsocketExtension]
implementing permessage-deflate (RFC 7692).

This extension is used by default in a [class@Session] when [class@WebsocketExtensionManager]
feature is present, and always used by [class@Server].</doc>
    </class>
    <record name="WebsocketExtensionDeflateClass" c:type="SoupWebsocketExtensionDeflateClass" glib:is-gtype-struct-for="WebsocketExtensionDeflate">
      <field name="parent_class">
        <type name="WebsocketExtensionClass" c:type="SoupWebsocketExtensionClass"/>
      </field>
    </record>
    <class name="WebsocketExtensionManager" c:symbol-prefix="websocket_extension_manager" c:type="SoupWebsocketExtensionManager" parent="GObject.Object" final="1" glib:type-name="SoupWebsocketExtensionManager" glib:get-type="soup_websocket_extension_manager_get_type" glib:type-struct="WebsocketExtensionManagerClass">
      <doc xml:space="preserve">SoupWebsocketExtensionManager is the [iface@SessionFeature] that handles WebSockets
extensions for a [class@Session].

A #SoupWebsocketExtensionManager is added to the session by default, and normally
you don't need to worry about it at all. However, if you want to
disable WebSocket extensions, you can remove the feature from the
session with [method@Session.remove_feature_by_type] or disable it on
individual requests with [method@Message.disable_feature].</doc>
      <implements name="SessionFeature"/>
    </class>
    <record name="WebsocketExtensionManagerClass" c:type="SoupWebsocketExtensionManagerClass" glib:is-gtype-struct-for="WebsocketExtensionManager">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="WebsocketState" glib:type-name="SoupWebsocketState" glib:get-type="soup_websocket_state_get_type" c:type="SoupWebsocketState">
      <doc xml:space="preserve">The state of the WebSocket connection.</doc>
      <member name="open" value="1" c:identifier="SOUP_WEBSOCKET_STATE_OPEN" glib:nick="open" glib:name="SOUP_WEBSOCKET_STATE_OPEN">
        <doc xml:space="preserve">the connection is ready to send messages</doc>
      </member>
      <member name="closing" value="2" c:identifier="SOUP_WEBSOCKET_STATE_CLOSING" glib:nick="closing" glib:name="SOUP_WEBSOCKET_STATE_CLOSING">
        <doc xml:space="preserve">the connection is in the process of
  closing down; messages may be received, but not sent</doc>
      </member>
      <member name="closed" value="3" c:identifier="SOUP_WEBSOCKET_STATE_CLOSED" glib:nick="closed" glib:name="SOUP_WEBSOCKET_STATE_CLOSED">
        <doc xml:space="preserve">the connection is completely closed down</doc>
      </member>
    </enumeration>
    <function name="check_version" c:identifier="soup_check_version">
      <doc xml:space="preserve">Like [func@CHECK_VERSION], but the check for soup_check_version is
at runtime instead of compile time.

This is useful for compiling against older versions of libsoup, but using
features from newer versions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the version of the libsoup currently loaded
  is the same as or newer than the passed-in version.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="major" transfer-ownership="none">
          <doc xml:space="preserve">the major version to check</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="minor" transfer-ownership="none">
          <doc xml:space="preserve">the minor version to check</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="micro" transfer-ownership="none">
          <doc xml:space="preserve">the micro version to check</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookie_parse" c:identifier="soup_cookie_parse" moved-to="Cookie.parse">
      <doc xml:space="preserve">Parses @header and returns a #SoupCookie.

If @header contains multiple cookies, only the first one will be parsed.

If @header does not have "path" or "domain" attributes, they will
be defaulted from @origin. If @origin is %NULL, path will default
to "/", but domain will be left as %NULL. Note that this is not a
valid state for a #SoupCookie, and you will need to fill in some
appropriate string for the domain if you want to actually make use
of the cookie.

As of version 3.4.0 the default value of a cookie's same-site-policy
is %SOUP_SAME_SITE_POLICY_LAX.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new #SoupCookie, or %NULL if it could
  not be parsed, or contained an illegal "domain" attribute for a
  cookie originating from @origin.</doc>
        <type name="Cookie" c:type="SoupCookie*"/>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a cookie string (eg, the value of a Set-Cookie header)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">origin of the cookie</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_free" c:identifier="soup_cookies_free" introspectable="0">
      <doc xml:space="preserve">Frees @cookies.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_from_request" c:identifier="soup_cookies_from_request">
      <doc xml:space="preserve">Parses @msg's Cookie request header and returns a [struct@GLib.SList] of
`SoupCookie`s.

As the "Cookie" header, unlike "Set-Cookie", only contains cookie names and
values, none of the other #SoupCookie fields will be filled in. (Thus, you
can't generally pass a cookie returned from this method directly to
[func@cookies_to_response].)</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList of
  `SoupCookie`s, which can be freed with [method@Cookie.free].</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="Cookie"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage containing a "Cookie" request header</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_from_response" c:identifier="soup_cookies_from_response">
      <doc xml:space="preserve">Parses @msg's Set-Cookie response headers and returns a [struct@GLib.SList]
of `SoupCookie`s.

Cookies that do not specify "path" or "domain" attributes will have their
values defaulted from @msg.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList of
  `SoupCookie`s, which can be freed with [method@Cookie.free].</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="Cookie"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage containing a "Set-Cookie" response header</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_to_cookie_header" c:identifier="soup_cookies_to_cookie_header">
      <doc xml:space="preserve">Serializes a [struct@GLib.SList] of #SoupCookie into a string suitable for
setting as the value of the "Cookie" header.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the serialization of @cookies</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_to_request" c:identifier="soup_cookies_to_request">
      <doc xml:space="preserve">Adds the name and value of each cookie in @cookies to @msg's
"Cookie" request.

If @msg already has a "Cookie" request header, these cookies will be appended
to the cookies already present. Be careful that you do not append the same
cookies twice, eg, when requeuing a message.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cookies_to_response" c:identifier="soup_cookies_to_response">
      <doc xml:space="preserve">Appends a "Set-Cookie" response header to @msg for each cookie in
@cookies.

This is in addition to any other "Set-Cookie" headers
@msg may already have.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cookies" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList of #SoupCookie</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cookie"/>
          </type>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_time_new_from_http_string" c:identifier="soup_date_time_new_from_http_string">
      <doc xml:space="preserve">Parses @date_string and tries to extract a date from it.

This recognizes all of the "HTTP-date" formats from RFC 2616, RFC 2822 dates,
and reasonable approximations thereof. (Eg, it is lenient about whitespace,
leading "0"s, etc.)</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new #GDateTime, or %NULL if @date_string
  could not be parsed.</doc>
        <type name="GLib.DateTime" c:type="GDateTime*"/>
      </return-value>
      <parameters>
        <parameter name="date_string" transfer-ownership="none">
          <doc xml:space="preserve">The date as a string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="date_time_to_string" c:identifier="soup_date_time_to_string">
      <doc xml:space="preserve">Converts @date to a string in the format described by @format.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">@date as a string or %NULL</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="date" transfer-ownership="none">
          <doc xml:space="preserve">a #GDateTime</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the format to generate the date in</doc>
          <type name="DateFormat" c:type="SoupDateFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_decode" c:identifier="soup_form_decode">
      <doc xml:space="preserve">Decodes @form.

which is an urlencoded dataset as defined in the HTML 4.01 spec.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a hash
  table containing the name/value pairs from @encoded_form, which you
  can free with [func@GLib.HashTable.destroy].</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="encoded_form" transfer-ownership="none">
          <doc xml:space="preserve">data of type "application/x-www-form-urlencoded"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_decode_multipart" c:identifier="soup_form_decode_multipart">
      <doc xml:space="preserve">Decodes the "multipart/form-data" request in @multipart.

this is a convenience method for the case when you have a single file upload
control in a form. (Or when you don't have any file upload controls, but are
still using "multipart/form-data" anyway.) Pass the name of the file upload
control in @file_control_name, and [func@form_decode_multipart] will extract
the uploaded file data into @filename, @content_type, and @file. All of the
other form control data will be returned (as strings, as with
[func@form_decode] in the returned [struct@GLib.HashTable].

You may pass %NULL for @filename, @content_type and/or @file if you do not
care about those fields. [func@form_decode_multipart] may also
return %NULL in those fields if the client did not provide that
information. You must free the returned filename and content-type
with [func@GLib.free], and the returned file data with [method@Glib.Bytes.unref].

If you have a form with more than one file upload control, you will
need to decode it manually, using [ctor@Multipart.new_from_message]
and [method@Multipart.get_part].</doc>
      <return-value transfer-ownership="container" nullable="1">
        <doc xml:space="preserve">
  a hash table containing the name/value pairs (other than
  @file_control_name) from @msg, which you can free with
  [func@GLib.HashTable.destroy]. On error, it will return %NULL.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="multipart" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMultipart</doc>
          <type name="Multipart" c:type="SoupMultipart*"/>
        </parameter>
        <parameter name="file_control_name" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the name of the HTML file upload control</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="filename" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the name of the uploaded file</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="content_type" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the MIME type of the uploaded file</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="file" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">return location for the uploaded file data</doc>
          <type name="GLib.Bytes" c:type="GBytes**"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode" c:identifier="soup_form_encode" introspectable="0">
      <doc xml:space="preserve">Encodes the given field names and values into a value of type
"application/x-www-form-urlencoded".

Encodes as defined in the HTML 4.01 spec.

This method requires you to know the names of the form fields (or
at the very least, the total number of fields) at compile time; for
working with dynamic forms, use [func@form_encode_hash] or
[func@form_encode_datalist].

See also: [ctor@Message.new_from_encoded_form].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="first_field" transfer-ownership="none">
          <doc xml:space="preserve">name of the first form field</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">value of @first_field, followed by additional field names
  and values, terminated by %NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode_datalist" c:identifier="soup_form_encode_datalist">
      <doc xml:space="preserve">Encodes @form_data_set into a value of type
"application/x-www-form-urlencoded".

Encodes as defined in the HTML 4.01 spec. Unlike [func@form_encode_hash],
this preserves the ordering of the form elements, which may be required in
some situations.

See also: [ctor@Message.new_from_encoded_form].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="form_data_set" transfer-ownership="none">
          <doc xml:space="preserve">a datalist containing name/value pairs</doc>
          <type name="GLib.Data" c:type="GData**"/>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode_hash" c:identifier="soup_form_encode_hash">
      <doc xml:space="preserve">Encodes @form_data_set into a value of type
"application/x-www-form-urlencoded".

Encodes as defined in the HTML 4.01 spec.

Note that the HTML spec states that "The control names/values are
listed in the order they appear in the document." Since this method
takes a hash table, it cannot enforce that; if you care about the
ordering of the form fields, use [func@form_encode_datalist].

See also: [ctor@Message.new_from_encoded_form].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="form_data_set" transfer-ownership="none">
          <doc xml:space="preserve">a hash table containing
  name/value pairs (as strings)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="form_encode_valist" c:identifier="soup_form_encode_valist" introspectable="0">
      <doc xml:space="preserve">See [func@form_encode].

This is mostly an internal method, used by various other methods such as
[func@form_encode].

See also: [ctor@Message.new_from_encoded_form].</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded form</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="first_field" transfer-ownership="none">
          <doc xml:space="preserve">name of the first form field</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve">pointer to additional values, as in [func@form_encode]</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_major_version" c:identifier="soup_get_major_version">
      <doc xml:space="preserve">Returns the major version number of the libsoup library.

e.g. in libsoup version 2.42.0 this is 2.

This function is in the library, so it represents the libsoup library
your code is running against. Contrast with the #SOUP_MAJOR_VERSION
macro, which represents the major version of the libsoup headers you
have included when compiling your code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the major version number of the libsoup library</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="get_micro_version" c:identifier="soup_get_micro_version">
      <doc xml:space="preserve">Returns the micro version number of the libsoup library.

e.g. in libsoup version 2.42.0 this is 0.

This function is in the library, so it represents the libsoup library
your code is running against. Contrast with the #SOUP_MICRO_VERSION
macro, which represents the micro version of the libsoup headers you
have included when compiling your code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the micro version number of the libsoup library</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="get_minor_version" c:identifier="soup_get_minor_version">
      <doc xml:space="preserve">Returns the minor version number of the libsoup library.

e.g. in libsoup version 2.42.0 this is 42.

This function is in the library, so it represents the libsoup library
your code is running against. Contrast with the #SOUP_MINOR_VERSION
macro, which represents the minor version of the libsoup headers you
have included when compiling your code.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the minor version number of the libsoup library</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="header_contains" c:identifier="soup_header_contains">
      <doc xml:space="preserve">Parses @header to see if it contains the token @token (matched
case-insensitively).

Note that this can't be used with lists that have qvalues.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether or not @header contains @token</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">An HTTP header suitable for parsing with
  [func@header_parse_list]</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="token" transfer-ownership="none">
          <doc xml:space="preserve">a token</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_free_list" c:identifier="soup_header_free_list" introspectable="0">
      <doc xml:space="preserve">Frees @list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList returned from [func@header_parse_list] or
[func@header_parse_quality_list]</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="header_free_param_list" c:identifier="soup_header_free_param_list">
      <doc xml:space="preserve">Frees @param_list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="param_list" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable returned from
  [func@header_parse_param_list] or [func@header_parse_semi_param_list]</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="header_g_string_append_param" c:identifier="soup_header_g_string_append_param">
      <doc xml:space="preserve">Appends something like `name=value` to @string, taking care to quote @value
if needed, and if so, to escape any quotes or backslashes in @value.

Alternatively, if @value is a non-ASCII UTF-8 string, it will be
appended using RFC5987 syntax. Although in theory this is supposed
to work anywhere in HTTP that uses this style of parameter, in
reality, it can only be used portably with the Content-Disposition
"filename" parameter.

If @value is %NULL, this will just append @name to @string.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a #GString being used to construct an HTTP header value</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a parameter name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a parameter value, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_g_string_append_param_quoted" c:identifier="soup_header_g_string_append_param_quoted">
      <doc xml:space="preserve">Appends something like `name="value"` to
@string, taking care to escape any quotes or backslashes in @value.

If @value is (non-ASCII) UTF-8, this will instead use RFC 5987
encoding, just like [func@header_g_string_append_param].</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">a #GString being used to construct an HTTP header value</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a parameter name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a parameter value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_list" c:identifier="soup_header_parse_list">
      <doc xml:space="preserve">Parses a header whose content is described by RFC2616 as `#something`.

"something" does not itself contain commas, except as part of quoted-strings.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList of
  list elements, as allocated strings</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_param_list" c:identifier="soup_header_parse_param_list">
      <doc xml:space="preserve">Parses a header which is a comma-delimited list of something like:
`token [ "=" ( token | quoted-string ) ]`.

Tokens that don't have an associated value will still be added to
the resulting hash table, but with a %NULL value.

This also handles RFC5987 encoding (which in HTTP is mostly used
for giving UTF8-encoded filenames in the Content-Disposition
header).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a
  #GHashTable of list elements, which can be freed with
  [func@header_free_param_list].</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_param_list_strict" c:identifier="soup_header_parse_param_list_strict">
      <doc xml:space="preserve">A strict version of [func@header_parse_param_list]
that bails out if there are duplicate parameters.

Note that this function will treat RFC5987-encoded
parameters as duplicated if an ASCII version is also
present. For header fields that might contain
RFC5987-encoded parameters, use
[func@header_parse_param_list] instead.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">
  a #GHashTable of list elements, which can be freed with
  [func@header_free_param_list] or %NULL if there are duplicate
  elements.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_quality_list" c:identifier="soup_header_parse_quality_list">
      <doc xml:space="preserve">Parses a header whose content is a list of items with optional
"qvalue"s (eg, Accept, Accept-Charset, Accept-Encoding,
Accept-Language, TE).

If @unacceptable is not %NULL, then on return, it will contain the
items with qvalue 0. Either way, those items will be removed from
the main list.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GSList of
  acceptable values (as allocated strings), highest-qvalue first.</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="unacceptable" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">on
  return, will contain a list of unacceptable values</doc>
          <type name="GLib.SList" c:type="GSList**">
            <type name="utf8"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_semi_param_list" c:identifier="soup_header_parse_semi_param_list">
      <doc xml:space="preserve">Parses a header which is a semicolon-delimited list of something
like: `token [ "=" ( token | quoted-string ) ]`.

Tokens that don't have an associated value will still be added to
the resulting hash table, but with a %NULL value.

This also handles RFC5987 encoding (which in HTTP is mostly used
for giving UTF8-encoded filenames in the Content-Disposition
header).</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a
  #GHashTable of list elements, which can be freed with
  [func@header_free_param_list].</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_parse_semi_param_list_strict" c:identifier="soup_header_parse_semi_param_list_strict">
      <doc xml:space="preserve">A strict version of [func@header_parse_semi_param_list]
that bails out if there are duplicate parameters.

Note that this function will treat RFC5987-encoded
parameters as duplicated if an ASCII version is also
present. For header fields that might contain
RFC5987-encoded parameters, use
[func@header_parse_semi_param_list] instead.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">
  a #GHashTable of list elements, which can be freed with
  [func@header_free_param_list] or %NULL if there are duplicate
  elements.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <doc xml:space="preserve">a header value</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse" c:identifier="soup_headers_parse">
      <doc xml:space="preserve">Parses the headers of an HTTP request or response in @str and
stores the results in @dest.

Beware that @dest may be modified even on failure.

This is a low-level method; normally you would use
[func@headers_parse_request] or [func@headers_parse_response].</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">success or failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the header string (including the Request-Line or Status-Line,
  but not the trailing blank line)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessageHeaders to store the header values in</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse_request" c:identifier="soup_headers_parse_request">
      <doc xml:space="preserve">Parses the headers of an HTTP request in @str and stores the
results in @req_method, @req_path, @ver, and @req_headers.

Beware that @req_headers may be modified even on failure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%SOUP_STATUS_OK if the headers could be parsed, or an
  HTTP error to be returned to the client if they could not be.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the headers (up to, but not including, the trailing blank line)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="req_headers" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessageHeaders to store the header values in</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
        <parameter name="req_method" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the
  request method</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="req_path" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the
  request path</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="ver" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the HTTP
  version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion*"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse_response" c:identifier="soup_headers_parse_response">
      <doc xml:space="preserve">Parses the headers of an HTTP response in @str and stores the
results in @ver, @status_code, @reason_phrase, and @headers.

Beware that @headers may be modified even on failure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">success or failure.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">the headers (up to, but not including, the trailing blank line)</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of @str</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="headers" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessageHeaders to store the header values in</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
        <parameter name="ver" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the HTTP
  version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion*"/>
        </parameter>
        <parameter name="status_code" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
  the status code</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="reason_phrase" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
  the reason phrase</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_parse_status_line" c:identifier="soup_headers_parse_status_line">
      <doc xml:space="preserve">Parses the HTTP Status-Line string in @status_line into @ver,
@status_code, and @reason_phrase.

@status_line must be terminated by either "\0" or "\r\n".</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @status_line was parsed successfully.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="status_line" transfer-ownership="none">
          <doc xml:space="preserve">an HTTP Status-Line</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ver" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with the HTTP
  version</doc>
          <type name="HTTPVersion" c:type="SoupHTTPVersion*"/>
        </parameter>
        <parameter name="status_code" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
  the status code</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="reason_phrase" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">if non-%NULL, will be filled in with
  the reason phrase</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="message_headers_iter_init" c:identifier="soup_message_headers_iter_init" moved-to="MessageHeadersIter.init">
      <doc xml:space="preserve">Initializes @iter for iterating @hdrs.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iter" direction="out" caller-allocates="1" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a %SoupMessageHeadersIter
  structure</doc>
          <type name="MessageHeadersIter" c:type="SoupMessageHeadersIter*"/>
        </parameter>
        <parameter name="hdrs" transfer-ownership="none">
          <doc xml:space="preserve">a %SoupMessageHeaders</doc>
          <type name="MessageHeaders" c:type="SoupMessageHeaders*"/>
        </parameter>
      </parameters>
    </function>
    <function name="session_error_quark" c:identifier="soup_session_error_quark" moved-to="SessionError.quark">
      <doc xml:space="preserve">Registers error quark for SoupSession if needed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Error quark for SoupSession.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <docsection name="soup-method">
      <doc xml:space="preserve">soup-method.h contains a number of defines for standard HTTP and
WebDAV headers. You do not need to use these defines; you can pass
arbitrary strings to soup_message_new() if you prefer.

The thing that these defines &lt;emphasis&gt;are&lt;/emphasis&gt; useful for is
performing quick comparisons against soup_message_get_method();
because #SoupMessage always contains an interned string, and these
macros return interned strings, you can compare methods directly
against these macros rather than needing to use strcmp(). This is
most useful in #SoupServer handlers. Eg:

&lt;informalexample&gt;&lt;programlisting&gt;
	if (soup_message_get_method (msg) != SOUP_METHOD_GET &amp;amp;&amp;amp; soup_message_get_method (msg) != SOUP_METHOD_HEAD) {
		soup_message_set_status (msg, SOUP_METHOD_NOT_IMPLEMENTED);
		return;
	}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
    </docsection>
    <function name="status_get_phrase" c:identifier="soup_status_get_phrase" moved-to="Status.get_phrase">
      <doc xml:space="preserve">Looks up the stock HTTP description of @status_code.

*There is no reason for you to ever use this
function.* If you wanted the textual description for the
[property@Message:status-code] of a given [class@Message], you should just
look at the message's [property@Message:reason-phrase]. However, you
should only do that for use in debugging messages; HTTP reason
phrases are not localized, and are not generally very descriptive
anyway, and so they should never be presented to the user directly.
Instead, you should create you own error messages based on the
status code, and on what you were trying to do.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the (terse, English) description of @status_code</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="status_code" transfer-ownership="none">
          <doc xml:space="preserve">an HTTP status code</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="tld_domain_is_public_suffix" c:identifier="soup_tld_domain_is_public_suffix">
      <doc xml:space="preserve">Looks whether the @domain passed as argument is a public domain
suffix (.org, .com, .co.uk, etc) or not.

Prior to libsoup 2.46, this function required that @domain be in
UTF-8 if it was an IDN. From 2.46 on, the name can be in either
UTF-8 or ASCII format.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it is a public domain, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">a domain name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tld_error_quark" c:identifier="soup_tld_error_quark" moved-to="TLDError.quark">
      <doc xml:space="preserve">Registers error quark for soup_tld_get_base_domain() if needed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Error quark for Soup TLD functions.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="tld_get_base_domain" c:identifier="soup_tld_get_base_domain" throws="1">
      <doc xml:space="preserve">Finds the base domain for a given @hostname

The base domain is composed by the top level domain (such as .org, .com,
.co.uk, etc) plus the second level domain, for example for
myhost.mydomain.com it will return mydomain.com.

Note that %NULL will be returned for private URLs (those not ending
with any well known TLD) because choosing a base domain for them
would be totally arbitrary.

Prior to libsoup 2.46, this function required that @hostname be in
UTF-8 if it was an IDN. From 2.46 on, the name can be in either
UTF-8 or ASCII format (and the return value will be in the same
format).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a pointer to the start of the base domain in @hostname. If
  an error occurs, %NULL will be returned and @error set.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="hostname" transfer-ownership="none">
          <doc xml:space="preserve">a hostname</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_copy" c:identifier="soup_uri_copy" introspectable="0">
      <doc xml:space="preserve">Return a copy of @uri with the given components updated.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GUri</doc>
        <type name="GLib.Uri" c:type="GUri*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">the #GUri to copy</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </parameter>
        <parameter name="first_component" transfer-ownership="none">
          <doc xml:space="preserve">first #SoupURIComponent to update</doc>
          <type name="URIComponent" c:type="SoupURIComponent"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">value of @first_component  followed by additional
   components and values, terminated by %SOUP_URI_NONE</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_decode_data_uri" c:identifier="soup_uri_decode_data_uri">
      <doc xml:space="preserve">Decodes the given data URI and returns its contents and @content_type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GBytes with the contents of @uri,
   or %NULL if @uri is not a valid data URI</doc>
        <type name="GLib.Bytes" c:type="GBytes*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve">a data URI, in string form</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="content_type" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">location to store content type</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_equal" c:identifier="soup_uri_equal">
      <doc xml:space="preserve">Tests whether or not @uri1 and @uri2 are equal in all parts.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if equal otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri1" transfer-ownership="none">
          <doc xml:space="preserve">a #GUri</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </parameter>
        <parameter name="uri2" transfer-ownership="none">
          <doc xml:space="preserve">another #GUri</doc>
          <type name="GLib.Uri" c:type="GUri*"/>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_client_prepare_handshake" c:identifier="soup_websocket_client_prepare_handshake">
      <doc xml:space="preserve">Adds the necessary headers to @msg to request a WebSocket
handshake including supported WebSocket extensions.

The message body and non-WebSocket-related headers are
not modified.

This is a low-level function; if you use
[method@Session.websocket_connect_async] to create a WebSocket connection, it
will call this for you.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #SoupMessage</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the "Origin" header to set</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="protocols" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">list of
  protocols to offer</doc>
          <array c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
        <parameter name="supported_extensions" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">list
  of supported extension types</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GObject.TypeClass"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_client_verify_handshake" c:identifier="soup_websocket_client_verify_handshake" throws="1">
      <doc xml:space="preserve">Looks at the response status code and headers in @msg and
determines if they contain a valid WebSocket handshake response
(given the handshake request in @msg's request headers).

If @supported_extensions is non-%NULL, extensions included in the
response "Sec-WebSocket-Extensions" are verified too. Accepted
extensions are returned in @accepted_extensions parameter if non-%NULL.

This is a low-level function; if you use
[method@Session.websocket_connect_async] to create a WebSocket
connection, it will call this for you.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg contains a completed valid WebSocket
  handshake, %FALSE and an error if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">#SoupMessage containing both client and server sides of a
  WebSocket handshake</doc>
          <type name="Message" c:type="SoupMessage*"/>
        </parameter>
        <parameter name="supported_extensions" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">list
  of supported extension types</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GObject.TypeClass"/>
          </array>
        </parameter>
        <parameter name="accepted_extensions" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a
  #GList of #SoupWebsocketExtension objects</doc>
          <type name="GLib.List" c:type="GList**">
            <type name="WebsocketExtension"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_error_quark" c:identifier="soup_websocket_error_quark" moved-to="WebsocketError.quark">
      <doc xml:space="preserve">Registers error quark for SoupWebsocket if needed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Error quark for SoupWebsocket.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="websocket_server_check_handshake" c:identifier="soup_websocket_server_check_handshake" throws="1">
      <doc xml:space="preserve">Examines the method and request headers in @msg and determines
whether @msg contains a valid handshake request.

If @origin is non-%NULL, then only requests containing a matching
"Origin" header will be accepted. If @protocols is non-%NULL, then
only requests containing a compatible "Sec-WebSocket-Protocols"
header will be accepted. If @supported_extensions is non-%NULL, then
only requests containing valid supported extensions in
"Sec-WebSocket-Extensions" header will be accepted.

Normally [func@websocket_server_process_handshake]
will take care of this for you, and if you use
[method@Server.add_websocket_handler] to handle accepting WebSocket
connections, it will call that for you. However, this function may
be useful if you need to perform more complicated validation; eg,
accepting multiple different Origins, or handling different protocols
depending on the path.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg contained a valid WebSocket handshake,
  %FALSE and an error if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">#SoupServerMessage containing the client side of a WebSocket handshake</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="origin" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">expected Origin header</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="protocols" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">allowed WebSocket
  protocols.</doc>
          <array c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
        <parameter name="supported_extensions" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">list
  of supported extension types</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GObject.TypeClass"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="websocket_server_process_handshake" c:identifier="soup_websocket_server_process_handshake">
      <doc xml:space="preserve">Examines the method and request headers in @msg and (assuming @msg
contains a valid handshake request), fills in the handshake
response.

If @expected_origin is non-%NULL, then only requests containing a matching
"Origin" header will be accepted. If @protocols is non-%NULL, then
only requests containing a compatible "Sec-WebSocket-Protocols"
header will be accepted. If @supported_extensions is non-%NULL, then
only requests containing valid supported extensions in
"Sec-WebSocket-Extensions" header will be accepted. The accepted extensions
will be returned in @accepted_extensions parameter if non-%NULL.

This is a low-level function; if you use
[method@Server.add_websocket_handler] to handle accepting WebSocket
connections, it will call this for you.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @msg contained a valid WebSocket handshake
  request and was updated to contain a handshake response. %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">#SoupServerMessage containing the client side of a WebSocket handshake</doc>
          <type name="ServerMessage" c:type="SoupServerMessage*"/>
        </parameter>
        <parameter name="expected_origin" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">expected Origin header</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="protocols" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">allowed WebSocket
  protocols.</doc>
          <array c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
        <parameter name="supported_extensions" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">list
  of supported extension types</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GObject.TypeClass"/>
          </array>
        </parameter>
        <parameter name="accepted_extensions" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
          <doc xml:space="preserve">a
  #GList of #SoupWebsocketExtension objects</doc>
          <type name="GLib.List" c:type="GList**">
            <type name="WebsocketExtension"/>
          </type>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
